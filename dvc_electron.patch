diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 2cb2b5bbdc8..e5e366b5172 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -239,6 +239,10 @@ jumbo_source_set("browser") {
     "//ui/snapshot",
     "//ui/touch_selection",
     "//v8:v8_version",
+    "//dolby/services/dolby_voice_client:lib",
+    "//dolby/services/dolby_voice_client/public/cpp:manifest",
+    "//dolby/services/dolby_voice_client/public/mojom:constants",
+    "//dolby/content/browser:dvc_content_browser",
   ]
 
   public_deps = [
@@ -249,6 +253,7 @@ jumbo_source_set("browser") {
     "//media/mojo/mojom:remoting",
     "//third_party/blink/public/mojom:embedded_frame_sink_mojo_bindings",
     "//third_party/leveldatabase",
+    "//dolby/services/dolby_voice_client/public/cpp",
   ]
 
   sources = [
@@ -2016,7 +2021,7 @@ jumbo_source_set("browser") {
   if (!is_fuchsia) {
     # Fuchsia does not support DevTools front-end, so only only build DevTools
     # resources on other platforms.
-    deps += [ "//content/browser/devtools:devtools_resources" ]
+    deps += [ "//content/browser/devtools:devtools_resources"]
   }
 
   if (enable_basic_printing) {
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index bc8031cde18..b2e72b278a1 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -248,6 +248,8 @@
 #include "mojo/public/cpp/bindings/lib/test_random_mojo_delays.h"
 #endif
 
+#include "dolby/content/browser/dvc_device_manager_connection.h"
+
 // One of the linux specific headers defines this as a macro.
 #ifdef DestroyAll
 #undef DestroyAll
@@ -1342,6 +1344,10 @@ int BrowserMainLoop::BrowserThreadsStarted() {
       nullptr);
 #endif
 
+  dvc_device_manager_connection_.reset(
+      new dolby_voice_client::browser::DvcDeviceManagerConnection(
+        GetSystemConnector()->Clone()));
+
   {
     TRACE_EVENT0("startup", "BrowserThreadsStarted::Subsystem:AudioMan");
     InitializeAudio();
@@ -1573,7 +1579,8 @@ void BrowserMainLoop::InitializeAudio() {
       !base::FeatureList::IsEnabled(features::kAudioServiceOutOfProcess)) {
     audio_manager_ =
         media::AudioManager::Create(std::make_unique<media::AudioThreadImpl>(),
-                                    MediaInternals::GetInstance());
+                                    MediaInternals::GetInstance(),
+                                    dvc_device_manager_connection());
     CHECK(audio_manager_);
   }
 
diff --git a/content/browser/browser_main_loop.h b/content/browser/browser_main_loop.h
index 92667bcb896..c1a518323a5 100644
--- a/content/browser/browser_main_loop.h
+++ b/content/browser/browser_main_loop.h
@@ -46,6 +46,12 @@ namespace gpu {
 class GpuChannelEstablishFactory;
 }
 
+namespace dolby_voice_client {
+namespace browser {
+class DvcDeviceManagerConnection;
+}  // namespace browser
+}  // namespace dolby_voice_client
+
 namespace media {
 class AudioManager;
 class AudioSystem;
@@ -156,6 +162,11 @@ class CONTENT_EXPORT BrowserMainLoop {
 
   int GetResultCode() const { return result_code_; }
 
+  dolby_voice_client::browser::DvcDeviceManagerConnection*
+  dvc_device_manager_connection() {
+    return dvc_device_manager_connection_.get();
+  }
+
   media::AudioManager* audio_manager() const;
   bool AudioServiceOutOfProcess() const;
   media::AudioSystem* audio_system() const { return audio_system_.get(); }
@@ -354,6 +365,9 @@ class CONTENT_EXPORT BrowserMainLoop {
   std::unique_ptr<mojo::core::ScopedIPCSupport> mojo_ipc_support_;
   std::unique_ptr<MediaKeysListenerManagerImpl> media_keys_listener_manager_;
 
+  std::unique_ptr<dolby_voice_client::browser::DvcDeviceManagerConnection>
+      dvc_device_manager_connection_;
+
   // |user_input_monitor_| has to outlive |audio_manager_|, so declared first.
   std::unique_ptr<media::UserInputMonitor> user_input_monitor_;
 
diff --git a/content/browser/builtin_service_manifests.cc b/content/browser/builtin_service_manifests.cc
index 26281550f4a..d99fc8b2537 100644
--- a/content/browser/builtin_service_manifests.cc
+++ b/content/browser/builtin_service_manifests.cc
@@ -20,6 +20,8 @@
 #include "services/media_session/public/cpp/manifest.h"
 #include "services/service_manager/public/cpp/manifest_builder.h"
 
+#include "dolby/services/dolby_voice_client/public/cpp/manifest.h"
+
 namespace content {
 
 namespace {
@@ -35,6 +37,7 @@ const std::vector<service_manager::Manifest>& GetBuiltinServiceManifests() {
   static base::NoDestructor<std::vector<service_manager::Manifest>> manifests{
       std::vector<service_manager::Manifest>{
           GetContentBrowserManifest(),
+          GetDolbyVoiceClientManifest(),
 
           audio::GetManifest(IsAudioServiceOutOfProcess()
                                  ? service_manager::Manifest::ExecutionMode::
diff --git a/content/browser/frame_host/render_frame_host_impl.h b/content/browser/frame_host/render_frame_host_impl.h
index 0465d8d793e..2b3460aa740 100644
--- a/content/browser/frame_host/render_frame_host_impl.h
+++ b/content/browser/frame_host/render_frame_host_impl.h
@@ -60,6 +60,7 @@
 #include "content/public/common/javascript_dialog_type.h"
 #include "content/public/common/previews_state.h"
 #include "content/public/common/transferrable_url_loader.mojom.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dolby_voice_client_provider.mojom.h"
 #include "media/mojo/mojom/interface_factory.mojom-forward.h"
 #include "media/mojo/mojom/media_metrics_provider.mojom-forward.h"
 #include "media/mojo/services/media_metrics_provider.h"
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index fefb63c7593..171f33caf7a 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -236,6 +236,11 @@
 #include "url/origin.h"
 #include "url/url_constants.h"
 
+#include "dolby/services/dolby_voice_client/public/mojom/constants.mojom.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dolby_voice_client_provider.mojom.h"
+#include "dolby/services/dolby_voice_client/dolby_voice_client_provider_impl.h"
+#include "dolby/services/dolby_voice_client/switches.h"
+
 #if defined(OS_ANDROID)
 #include "content/public/browser/android/java_interfaces.h"
 #include "ipc/ipc_sync_channel.h"
@@ -1276,6 +1281,18 @@ class RenderProcessHostImpl::IOThreadHostImpl
       return;
     }
 
+    if (auto r = receiver.As<dolby_voice_client::mojom::DolbyVoiceClientProvider>()) {
+      if (!dvc_provider_) {
+        service_manager::Connector* connector = content::GetSystemConnector();
+        DCHECK(connector != nullptr);
+        connector->Connect(dolby_voice_client::mojom::kServiceName,
+                           dvc_provider_.BindNewPipeAndPassReceiver());
+        DCHECK(dvc_provider_);
+      }
+      dvc_provider_receivers_.Add(dvc_provider_.get(), std::move(r));
+      return;
+    }
+
     std::string interface_name = *receiver.interface_name();
     mojo::ScopedMessagePipeHandle pipe = receiver.PassPipe();
     if (binders_->TryBindInterface(interface_name, &pipe))
@@ -1305,6 +1322,9 @@ class RenderProcessHostImpl::IOThreadHostImpl
   mojo::Receiver<mojom::ChildProcessHostBootstrap> bootstrap_receiver_;
   mojo::Receiver<mojom::ChildProcessHost> receiver_{this};
 
+  mojo::ReceiverSet<dolby_voice_client::mojom::DolbyVoiceClientProvider> dvc_provider_receivers_;
+  mojo::Remote<dolby_voice_client::mojom::DolbyVoiceClientProvider> dvc_provider_;
+
   DISALLOW_COPY_AND_ASSIGN(IOThreadHostImpl);
 };
 
@@ -3281,6 +3301,7 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
   };
   renderer_cmd->CopySwitchesFrom(browser_cmd, kSwitchNames,
                                  base::size(kSwitchNames));
+  copyDvcSwitches(browser_cmd, *renderer_cmd);
 
   BrowserChildProcessHostImpl::CopyFeatureAndFieldTrialFlags(renderer_cmd);
   BrowserChildProcessHostImpl::CopyTraceStartupFlags(renderer_cmd);
diff --git a/content/browser/utility_process_host.cc b/content/browser/utility_process_host.cc
index a0786b3ca9f..92d9d677033 100644
--- a/content/browser/utility_process_host.cc
+++ b/content/browser/utility_process_host.cc
@@ -57,6 +57,8 @@
 #include "services/service_manager/zygote/common/zygote_handle.h"  // nogncheck
 #endif
 
+#include "dolby/services/dolby_voice_client/switches.h"
+
 namespace content {
 
 // NOTE: changes to this class need to be reviewed by the security team.
@@ -431,6 +433,7 @@ bool UtilityProcessHost::StartProcess() {
     };
     cmd_line->CopySwitchesFrom(browser_command_line, kSwitchNames,
                                base::size(kSwitchNames));
+    copyDvcSwitches(browser_command_line, *cmd_line);
 
     network_session_configurator::CopyNetworkSwitches(browser_command_line,
                                                       cmd_line.get());
diff --git a/content/public/app/content_browser_manifest.cc b/content/public/app/content_browser_manifest.cc
index 54ab9a3862c..00da15acc3e 100644
--- a/content/public/app/content_browser_manifest.cc
+++ b/content/public/app/content_browser_manifest.cc
@@ -162,6 +162,7 @@ const service_manager::Manifest& GetContentBrowserManifest() {
           .RequireCapability("content_gpu", "browser")
           .RequireCapability("resource_coordinator", "app")
           .RequireCapability("resource_coordinator", "heap_profiler_helper")
+          .RequireCapability("dolby_voice_client", "dolby_voice_client")
           .ExposeInterfaceFilterCapability_Deprecated(
               "navigation:frame", "renderer",
               std::set<const char*>{
diff --git a/content/renderer/BUILD.gn b/content/renderer/BUILD.gn
index 5273f5b6d5f..8635334e1c3 100644
--- a/content/renderer/BUILD.gn
+++ b/content/renderer/BUILD.gn
@@ -418,6 +418,8 @@ target(link_target_type, "renderer") {
     "//ui/native_theme",
     "//ui/surface",
     "//v8",
+    "//dolby/content/renderer:dvc_content_renderer",
+    "//dolby/services/dolby_voice_client/public/cpp",
   ]
   allow_circular_includes_from = []
 
diff --git a/content/renderer/render_thread_impl.cc b/content/renderer/render_thread_impl.cc
index 0cb978a91a4..371aee4a12e 100644
--- a/content/renderer/render_thread_impl.cc
+++ b/content/renderer/render_thread_impl.cc
@@ -146,6 +146,7 @@
 #include "ui/base/layout.h"
 #include "ui/base/ui_base_switches.h"
 #include "ui/display/display_switches.h"
+#include "dolby/content/renderer/dvc_conference_factory_client.h"
 
 #if defined(OS_ANDROID)
 #include <cpu-features.h>
@@ -609,6 +610,9 @@ void RenderThreadImpl::Init() {
   browser_plugin_manager_.reset(new BrowserPluginManager());
   AddObserver(browser_plugin_manager_.get());
 
+  dvc_conference_factory_client_ = std::make_unique<
+    dolby_voice_client::renderer::DvcConferenceFactoryClient>(this);
+
   unfreezable_message_filter_ = new UnfreezableMessageFilter(this);
   AddFilter(unfreezable_message_filter_.get());
 
diff --git a/content/renderer/render_thread_impl.h b/content/renderer/render_thread_impl.h
index c6e78c0dae7..ff4c114cd20 100644
--- a/content/renderer/render_thread_impl.h
+++ b/content/renderer/render_thread_impl.h
@@ -65,6 +65,12 @@
 
 class SkBitmap;
 
+namespace dolby_voice_client {
+namespace renderer {
+class DvcConferenceFactoryClient;
+}
+}
+
 namespace blink {
 class WebVideoCaptureImplManager;
 }
@@ -544,6 +550,9 @@ class CONTENT_EXPORT RenderThreadImpl
 
   std::unique_ptr<BrowserPluginManager> browser_plugin_manager_;
 
+  std::unique_ptr<dolby_voice_client::renderer::DvcConferenceFactoryClient>
+    dvc_conference_factory_client_;
+
   // Filter out unfreezable messages and pass it to unfreezable task runners.
   scoped_refptr<UnfreezableMessageFilter> unfreezable_message_filter_;
 
diff --git a/content/utility/BUILD.gn b/content/utility/BUILD.gn
index 6cd7c287076..b9ca28c3ff6 100644
--- a/content/utility/BUILD.gn
+++ b/content/utility/BUILD.gn
@@ -58,6 +58,7 @@ jumbo_source_set("utility") {
     "//services/video_capture/public/mojom:constants",
     "//third_party/blink/public:blink_headers",
     "//url",
+    "//dolby/services/dolby_voice_client:lib",
   ]
 
   # When pepper CDMs are supported, we also support running the CDM in the
diff --git a/content/utility/utility_service_factory.cc b/content/utility/utility_service_factory.cc
index 327a490eca8..6cfc8cb96ed 100644
--- a/content/utility/utility_service_factory.cc
+++ b/content/utility/utility_service_factory.cc
@@ -27,6 +27,8 @@
 #include "services/network/network_service.h"
 #include "services/service_manager/public/mojom/service.mojom.h"
 
+#include "dolby/services/dolby_voice_client/service_impl.h"
+
 #if BUILDFLAG(ENABLE_LIBRARY_CDMS)
 #include "media/cdm/cdm_adapter_factory.h"           // nogncheck
 #include "media/mojo/mojom/constants.mojom.h"   // nogncheck
@@ -117,6 +119,8 @@ void UtilityServiceFactory::RunService(
   std::unique_ptr<service_manager::Service> service;
   if (service_name == audio::mojom::kServiceName) {
     service = CreateAudioService(std::move(request));
+  } else if (service_name == dolby_voice_client::mojom::kServiceName) {
+    service = dolby_voice_client::ServiceImpl::Create(std::move(request));
   }
 #if BUILDFLAG(ENABLE_LIBRARY_CDMS)
   else if (service_name == media::mojom::kCdmServiceName) {
diff --git a/dolby/LICENSE b/dolby/LICENSE
new file mode 100644
index 00000000000..74eea46e6d5
--- /dev/null
+++ b/dolby/LICENSE
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2019 Dolby Laboratories and Dolby International AB
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/dolby/content/browser/BUILD.gn b/dolby/content/browser/BUILD.gn
new file mode 100644
index 00000000000..b1c417e8e49
--- /dev/null
+++ b/dolby/content/browser/BUILD.gn
@@ -0,0 +1,24 @@
+# Copyright 2020 Dolby Laboratories and Dolby International AB
+# Use of this source code is governed by the MIT license that can be
+# found in the dolby/LICENSE file.
+
+source_set("dvc_content_browser") {
+  sources = [
+    "dvc_device_manager_connection.cc",
+    "dvc_device_manager_connection.h",
+  ]
+
+  public_deps = [
+    "//base",
+    "//services/service_manager/public/cpp",
+    "//dolby/services/dolby_voice_client/public/mojom",
+  ]
+
+  configs += [
+    "//content:content_implementation"
+  ]
+
+  deps = [
+    "//mojo/public/cpp/bindings:bindings",
+  ]
+}
diff --git a/dolby/content/browser/dvc_device_manager_connection.cc b/dolby/content/browser/dvc_device_manager_connection.cc
new file mode 100644
index 00000000000..dca62debc14
--- /dev/null
+++ b/dolby/content/browser/dvc_device_manager_connection.cc
@@ -0,0 +1,73 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/content/browser/dvc_device_manager_connection.h"
+
+#include "content/public/browser/system_connector.h"
+#include "dolby/services/dolby_voice_client/public/mojom/constants.mojom.h"
+#include "mojo/public/cpp/bindings/callback_helpers.h"
+#include "services/service_manager/public/cpp/connector.h"
+
+namespace dolby_voice_client {
+namespace browser {
+
+DvcDeviceManagerConnection::DvcDeviceManagerConnection(
+  std::unique_ptr<service_manager::Connector> connector)
+    : connector_(std::move(connector)) {
+  DCHECK(connector_);
+}
+
+DvcDeviceManagerConnection::~DvcDeviceManagerConnection() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  UninitializeInternal();
+}
+
+void DvcDeviceManagerConnection::LazyConnectToService() {
+  if (dvc_provider_.is_bound())
+    return;
+
+  connector_->BindInterface(
+    service_manager::ServiceFilter::ByName(dolby_voice_client::mojom::kServiceName),
+    dvc_provider_.BindNewPipeAndPassReceiver());
+
+  dvc_provider_->ConnectToDeviceManager(mojo::MakeRequest(&device_manager_));
+  // Unretained |this| is safe, because |this| owns |device_manager_|.
+  device_manager_.set_connection_error_handler(base::BindOnce(
+      &DvcDeviceManagerConnection::OnLostConnectionToDeviceManager,
+      base::Unretained(this)));
+}
+
+void DvcDeviceManagerConnection::OnLostConnectionToDeviceManager() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  // This may indicate that the service has crashed. Uninitialize
+  // here, so that a new connection will be established when clients try to
+  // reconnect.
+  UninitializeInternal();
+}
+
+void DvcDeviceManagerConnection::UninitializeInternal() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (!device_manager_.is_bound())
+    return;
+
+  device_manager_.reset();
+  dvc_provider_.reset();
+}
+
+void DvcDeviceManagerConnection::SetPreferredInputDevice(
+    const std::vector<int8_t>& native_device_id) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  LazyConnectToService();
+  device_manager_->SetPreferredInputDevice(native_device_id);
+}
+
+void DvcDeviceManagerConnection::SetPreferredOutputDevice(
+    const std::vector<int8_t>& native_device_id) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  LazyConnectToService();
+  device_manager_->SetPreferredOutputDevice(native_device_id);
+}
+
+}  // namespace browser
+}  // namespace dolby_voice_client
diff --git a/dolby/content/browser/dvc_device_manager_connection.h b/dolby/content/browser/dvc_device_manager_connection.h
new file mode 100644
index 00000000000..6e8c001f071
--- /dev/null
+++ b/dolby/content/browser/dvc_device_manager_connection.h
@@ -0,0 +1,44 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef DOLBY_CONTENT_BROWSER_DVC_DEVICE_MANAGER_CONNECTION_H_
+#define DOLBY_CONTENT_BROWSER_DVC_DEVICE_MANAGER_CONNECTION_H_
+
+#include "base/threading/thread_checker.h"
+#include "services/service_manager/public/cpp/connector.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dolby_voice_client_provider.mojom.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dvc_device_manager.mojom.h"
+
+namespace dolby_voice_client {
+namespace browser {
+
+class DvcDeviceManagerConnection {
+ public:
+  explicit DvcDeviceManagerConnection(std::unique_ptr<service_manager::Connector> connector);
+  virtual ~DvcDeviceManagerConnection();
+
+  // copy of mojom::DvcDeviceManager interface.
+  virtual void SetPreferredInputDevice(
+      const std::vector<int8_t>& native_device_id);
+  virtual void SetPreferredOutputDevice(
+      const std::vector<int8_t>& native_device_id);
+
+ private:
+  void LazyConnectToService();
+  void OnLostConnectionToDeviceManager();
+  void UninitializeInternal();
+
+  SEQUENCE_CHECKER(sequence_checker_);
+
+  const std::unique_ptr<service_manager::Connector> connector_;
+  // We must hold on to |dvc_provider_| because it holds the
+  // service-side binding for |device_manager_|.
+  mojo::Remote<mojom::DolbyVoiceClientProvider> dvc_provider_;
+  mojom::DvcDeviceManagerPtr device_manager_;
+};
+
+}  // namespace browser
+}  // namespace dolby_voice_client
+
+#endif  // DOLBY_CONTENT_BROWSER_DVC_DEVICE_MANAGER_CONNECTION_H_
diff --git a/dolby/content/renderer/BUILD.gn b/dolby/content/renderer/BUILD.gn
new file mode 100644
index 00000000000..c9de25e2bcb
--- /dev/null
+++ b/dolby/content/renderer/BUILD.gn
@@ -0,0 +1,26 @@
+# Copyright 2020 Dolby Laboratories and Dolby International AB
+# Use of this source code is governed by the MIT license that can be
+# found in the dolby/LICENSE file.
+
+source_set("dvc_content_renderer") {
+  sources = [
+    "dvc_conference_factory_connection.cc",
+    "dvc_conference_factory_connection.h",
+    "dvc_conference_factory_client.cc",
+    "dvc_conference_factory_client.h",
+    "dvc_conference_client.cc",
+    "dvc_conference_client.h",
+    "dvc_utils.cc",
+    "dvc_utils.h",
+  ]
+
+  public_deps = [
+    "//dolby/services/dolby_voice_client:dvc_utils",
+    "//services/service_manager/public/cpp",
+    "//dolby/services/dolby_voice_client/public/mojom",
+  ]
+
+  deps = [
+    "//mojo/public/cpp/bindings:bindings",
+  ]
+}
diff --git a/dolby/content/renderer/dvc_conference_client.cc b/dolby/content/renderer/dvc_conference_client.cc
new file mode 100644
index 00000000000..e187b9e362c
--- /dev/null
+++ b/dolby/content/renderer/dvc_conference_client.cc
@@ -0,0 +1,323 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/content/renderer/dvc_conference_client.h"
+
+#include "base/task/post_task.h"
+#include "dolby/content/renderer/dvc_utils.h"
+#include "dolby/services/dolby_voice_client/dvc_utils.h"
+#include "mojo/public/cpp/bindings/callback_helpers.h"
+
+namespace dolby_voice_client {
+namespace renderer {
+
+DvcConferenceClient::DvcConferenceClient(
+    mojom::DvcConferencePtr conference_ptr,
+    scoped_refptr<base::SingleThreadTaskRunner> task_runner)
+    : conference_ptr_(std::move(conference_ptr)),
+      task_runner_(task_runner),
+      listener_(nullptr),
+      rtp_sink_(nullptr),
+      rtp_sink_binding_(this) {
+  conference_ptr_.set_connection_error_handler(base::Bind(
+      &DvcConferenceClient::OnConnectionError, base::Unretained(this)));
+}
+
+DvcConferenceClient::~DvcConferenceClient() {
+  {
+    ScopedCompletionEvent event;
+    task_runner_->PostTask(
+        FROM_HERE,
+        base::BindOnce(&DvcConferenceClient::ShutdownOnTaskRunner,
+                       base::Unretained(this), base::Unretained(&event)));
+  }
+}
+
+bool DvcConferenceClient::Update(
+    const dolby_voice_client::webrtc_integration::DvcAudioCodec& codec,
+    std::string& error_message) {
+  bool result = false;
+  {
+    ScopedCompletionEvent event;
+    task_runner_->PostTask(
+        FROM_HERE,
+        base::BindOnce(&DvcConferenceClient::UpdateOnTaskRunner,
+                       base::Unretained(this), base::Unretained(&codec),
+                       base::Unretained(&error_message),
+                       base::Unretained(&result), base::Unretained(&event)));
+  }
+  return result;
+}
+
+void DvcConferenceClient::Stop() {
+  {
+    ScopedCompletionEvent event;
+    task_runner_->PostTask(
+        FROM_HERE,
+        base::BindOnce(&DvcConferenceClient::StopOnTaskRunner,
+                       base::Unretained(this), base::Unretained(&event)));
+  }
+}
+
+void DvcConferenceClient::HandleReceivedRtpPacket(const char* data,
+                                                  size_t size) {
+  std::unique_ptr<RtpAudio> rtp_audio = std::make_unique<RtpAudio>(data, size);
+  task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&DvcConferenceClient::HandleReceivedRtpPacketOnTaskRunner,
+                     base::Unretained(this), std::move(rtp_audio), nullptr));
+}
+
+bool DvcConferenceClient::GetAudioSessionStats(
+    dolby_voice_client::webrtc_integration::DvcStats& stats) {
+  bool result = false;
+  {
+    ScopedCompletionEvent event;
+    task_runner_->PostTask(
+        FROM_HERE,
+        base::BindOnce(&DvcConferenceClient::GetAudioSessionStatsOnTaskRunner,
+                       base::Unretained(this), base::Unretained(&stats),
+                       base::Unretained(&result), base::Unretained(&event)));
+  }
+  return result;
+}
+
+void DvcConferenceClient::SetMinimumPlayoutDelay(int32_t delay_ms) {
+  task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&DvcConferenceClient::SetMinimumPlayoutDelayOnTaskRunner,
+                     base::Unretained(this), delay_ms, nullptr));
+}
+
+void DvcConferenceClient::SetMute(bool mute) {
+  task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(&DvcConferenceClient::SetMuteOnTaskRunner,
+                                base::Unretained(this), mute, nullptr));
+}
+
+void DvcConferenceClient::SetRtpSink(
+    dolby_voice_client::webrtc_integration::DvcConference::RtpSink& sink) {
+  {
+    ScopedCompletionEvent event;
+    task_runner_->PostTask(
+        FROM_HERE,
+        base::BindOnce(&DvcConferenceClient::SetRtpSinkOnTaskRunner,
+                       base::Unretained(this), base::Unretained(&sink),
+                       base::Unretained(&event)));
+  }
+}
+
+void DvcConferenceClient::SetConnectionBrokenListener(
+    dolby_voice_client::webrtc_integration::DvcConference::
+        ConnectionBrokenListener* listener) {
+  {
+    ScopedCompletionEvent event;
+    task_runner_->PostTask(
+        FROM_HERE,
+        base::BindOnce(
+            &DvcConferenceClient::SetConnectionBrokenListenerOnTaskRunner,
+            base::Unretained(this), base::Unretained(listener),
+            base::Unretained(&event)));
+  }
+}
+
+void DvcConferenceClient::OnConnectionError() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (listener_)
+    listener_->OnConnectionBroken();
+}
+
+void DvcConferenceClient::OnRtpSinkConnectionError() {
+  OnConnectionError();
+}
+
+void DvcConferenceClient::ShutdownOnTaskRunner(ScopedCompletionEvent* event) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+
+  listener_ = nullptr;
+  rtp_sink_ = nullptr;
+
+  conference_ptr_.reset();
+  rtp_sink_binding_.Close();
+
+  DCHECK(event != nullptr);
+  event->SignalCompleted();
+}
+
+void DvcConferenceClient::UpdateOnTaskRunner(
+    const dolby_voice_client::webrtc_integration::DvcAudioCodec* codec,
+    std::string* error_message,
+    bool* result,
+    ScopedCompletionEvent* event) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  DCHECK(codec != nullptr);
+  if (conference_ptr_.is_bound()) {
+    mojom::AudioCodecPtr codec_ptr(base::in_place, ConvertCodec(*codec));
+    conference_ptr_->Update(
+        std::move(codec_ptr),
+        mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+            base::BindOnce(&DvcConferenceClient::OnUpdateResult,
+                           base::Unretained(this), base::Unretained(result),
+                           base::Unretained(error_message),
+                           base::Unretained(event)),
+            false, "IPC broken"));
+  } else {
+    DCHECK(event != nullptr);
+    event->SignalCompleted();
+  }
+}
+
+void DvcConferenceClient::OnUpdateResult(bool* result,
+                                         std::string* errors,
+                                         ScopedCompletionEvent* event,
+                                         bool remote_status,
+                                         const std::string& remote_errors) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  DCHECK(result != nullptr);
+  DCHECK(errors != nullptr);
+  *result = remote_status;
+  *errors = remote_errors;
+
+  DCHECK(event != nullptr);
+  event->SignalCompleted();
+}
+
+void DvcConferenceClient::StopOnTaskRunner(ScopedCompletionEvent* event) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (conference_ptr_.is_bound())
+    conference_ptr_->Stop();
+
+  DCHECK(event != nullptr);
+  event->SignalCompleted();
+}
+
+void DvcConferenceClient::HandleReceivedRtpPacketOnTaskRunner(
+    std::unique_ptr<RtpAudio> rtp_audio,
+    ScopedCompletionEvent* event) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  DCHECK(rtp_audio);
+  if (conference_ptr_.is_bound()) {
+    std::vector<uint8_t> packet(rtp_audio->Data(), rtp_audio->Data() + rtp_audio->Len());
+    conference_ptr_->HandleReceivedRtpPacket(std::move(packet));
+  }
+  if (event != nullptr)
+    event->SignalCompleted();
+}
+
+void DvcConferenceClient::GetAudioSessionStatsOnTaskRunner(
+    dolby_voice_client::webrtc_integration::DvcStats* stats,
+    bool* result,
+    ScopedCompletionEvent* event) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  DCHECK(stats != nullptr);
+  if (conference_ptr_.is_bound()) {
+    conference_ptr_->GetAudioSessionStats(
+        mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+            base::BindOnce(&DvcConferenceClient::OnGetAudioSessionStatsResult,
+                           base::Unretained(this), base::Unretained(stats),
+                           base::Unretained(result), base::Unretained(event)),
+            mojom::StatsPtr(nullptr)));
+  } else {
+    DCHECK(event != nullptr);
+    event->SignalCompleted();
+  }
+}
+
+void DvcConferenceClient::OnGetAudioSessionStatsResult(
+    dolby_voice_client::webrtc_integration::DvcStats* stats,
+    bool* result,
+    ScopedCompletionEvent* event,
+    mojom::StatsPtr stats_ptr) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (!stats_ptr.is_null()) {
+#define COPY_STAT(name) stats->name = stats_ptr->name
+    COPY_STAT(codec_name);
+    COPY_STAT(in_jitter);
+    COPY_STAT(in_jitter_buffer_ms);
+    COPY_STAT(in_packet_loss_fraction);
+    COPY_STAT(in_packets_total);
+    COPY_STAT(in_conceals_total);
+    COPY_STAT(in_voice_level);
+    COPY_STAT(out_jitter);
+    COPY_STAT(out_jitter_buffer_ms);
+    COPY_STAT(out_packet_loss_fraction);
+    COPY_STAT(out_packets_total);
+    COPY_STAT(out_fec_action_counter);
+    COPY_STAT(transmit_level);
+    COPY_STAT(avg_rtt_to_as);
+    COPY_STAT(echo_delay_ms);
+    COPY_STAT(total_output_energy);
+    COPY_STAT(total_input_energy);
+    *result = true;
+#undef COPY_STAT
+  } else {
+    *result = false;
+  }
+  DCHECK(event != nullptr);
+  event->SignalCompleted();
+}
+
+void DvcConferenceClient::SetMinimumPlayoutDelayOnTaskRunner(
+    int32_t delay_ms,
+    ScopedCompletionEvent* event) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (conference_ptr_.is_bound())
+    conference_ptr_->SetMinimumPlayoutDelay(delay_ms);
+
+  if (event != nullptr)
+    event->SignalCompleted();
+}
+
+void DvcConferenceClient::SetMuteOnTaskRunner(bool mute,
+                                              ScopedCompletionEvent* event) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (conference_ptr_.is_bound())
+    conference_ptr_->SetMute(mute);
+
+  if (event != nullptr)
+    event->SignalCompleted();
+}
+
+void DvcConferenceClient::SetRtpSinkOnTaskRunner(
+    dolby_voice_client::webrtc_integration::DvcConference::RtpSink* sink,
+    ScopedCompletionEvent* event) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (rtp_sink_binding_.is_bound()) {
+    rtp_sink_binding_.Unbind();
+  }
+  if (conference_ptr_.is_bound()) {
+    rtp_sink_ = sink;
+    mojom::DvcConferenceRtpSinkPtr self_ptr;
+    mojom::DvcConferenceRtpSinkRequest req = mojo::MakeRequest(&self_ptr);
+    rtp_sink_binding_.Bind(std::move(req));
+    rtp_sink_binding_.set_connection_error_handler(
+        base::Bind(&DvcConferenceClient::OnRtpSinkConnectionError,
+                   base::Unretained(this)));
+    conference_ptr_->SetRtpSink(std::move(self_ptr));
+  }
+  DCHECK(event != nullptr);
+  event->SignalCompleted();
+}
+
+void DvcConferenceClient::SendRtp(const std::vector<uint8_t>& packet,
+                                  int64_t timestamp_us) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (rtp_sink_ != nullptr) {
+    rtp_sink_->SendRtp(reinterpret_cast<const char*>(packet.data()),
+                       static_cast<size_t>(packet.size()), timestamp_us);
+  }
+}
+
+void DvcConferenceClient::SetConnectionBrokenListenerOnTaskRunner(
+    dolby_voice_client::webrtc_integration::DvcConference::
+        ConnectionBrokenListener* listener,
+    ScopedCompletionEvent* event) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  listener_ = listener;
+  DCHECK(event != nullptr);
+  event->SignalCompleted();
+}
+
+}  // namespace renderer
+}  // namespace dolby_voice_client
diff --git a/dolby/content/renderer/dvc_conference_client.h b/dolby/content/renderer/dvc_conference_client.h
new file mode 100644
index 00000000000..ed876174889
--- /dev/null
+++ b/dolby/content/renderer/dvc_conference_client.h
@@ -0,0 +1,105 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef DOLBY_CONTENT_RENDERER_DVC_CONFERENCE_CLIENT_H_
+#define DOLBY_CONTENT_RENDERER_DVC_CONFERENCE_CLIENT_H_
+
+#include <vector>
+
+#include "base/task_runner.h"
+#include "base/threading/thread_checker.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dvc_conference.mojom.h"
+#include "mojo/public/cpp/bindings/binding.h"
+#include "third_party/webrtc/dvc/dvc_conference_factory.h"
+
+namespace dolby_voice_client {
+
+class RtpAudio;
+class ScopedCompletionEvent;
+
+namespace renderer {
+
+class DvcConferenceClient
+    : public dolby_voice_client::webrtc_integration::DvcConference,
+      mojom::DvcConferenceRtpSink {
+ public:
+  DvcConferenceClient(mojom::DvcConferencePtr conference_ptr,
+                      scoped_refptr<base::SingleThreadTaskRunner> task_runner);
+  ~DvcConferenceClient() override;
+
+  // dolby_voice::dvc_interfaces::Conference interface
+  bool Update(
+      const dolby_voice_client::webrtc_integration::DvcAudioCodec& codec,
+      std::string& error_message) override;
+  void Stop() override;
+  void HandleReceivedRtpPacket(const char* data, size_t size) override;
+  bool GetAudioSessionStats(
+      dolby_voice_client::webrtc_integration::DvcStats& stats) override;
+  void SetMinimumPlayoutDelay(int32_t delay_ms) override;
+  void SetMute(bool mute) override;
+  void SetRtpSink(
+      dolby_voice_client::webrtc_integration::DvcConference::RtpSink& sink)
+      override;
+  void SetConnectionBrokenListener(
+      dolby_voice_client::webrtc_integration::DvcConference::
+          ConnectionBrokenListener* listener) override;
+
+  // mojom::DvcConferenceRtpSink interface
+  void SendRtp(const std::vector<uint8_t>& packet,
+               int64_t timestamp_us) override;
+
+ protected:
+  virtual void OnConnectionError();
+  virtual void OnRtpSinkConnectionError();
+
+  virtual void ShutdownOnTaskRunner(ScopedCompletionEvent* event);
+  virtual void UpdateOnTaskRunner(
+      const dolby_voice_client::webrtc_integration::DvcAudioCodec* codec,
+      std::string* error_message,
+      bool* result,
+      ScopedCompletionEvent* event);
+  virtual void OnUpdateResult(bool* result,
+                              std::string* errors,
+                              ScopedCompletionEvent* event,
+                              bool remote_status,
+                              const std::string& remote_errors);
+  virtual void StopOnTaskRunner(ScopedCompletionEvent* event);
+  virtual void HandleReceivedRtpPacketOnTaskRunner(
+      std::unique_ptr<RtpAudio> rtp_audio,
+      ScopedCompletionEvent* event);
+  virtual void GetAudioSessionStatsOnTaskRunner(
+      dolby_voice_client::webrtc_integration::DvcStats* stats,
+      bool* result,
+      ScopedCompletionEvent* event);
+  virtual void OnGetAudioSessionStatsResult(
+      dolby_voice_client::webrtc_integration::DvcStats* stats,
+      bool* result,
+      ScopedCompletionEvent* event,
+      mojom::StatsPtr stats_ptr);
+  virtual void SetMinimumPlayoutDelayOnTaskRunner(int32_t delay_ms,
+                                                  ScopedCompletionEvent* event);
+  virtual void SetMuteOnTaskRunner(bool mute, ScopedCompletionEvent* event);
+  virtual void SetRtpSinkOnTaskRunner(
+      dolby_voice_client::webrtc_integration::DvcConference::RtpSink* sink,
+      ScopedCompletionEvent* event);
+  virtual void SetConnectionBrokenListenerOnTaskRunner(
+      dolby_voice_client::webrtc_integration::DvcConference::
+          ConnectionBrokenListener* listener,
+      ScopedCompletionEvent* event);
+
+  SEQUENCE_CHECKER(sequence_checker_);
+
+  mojom::DvcConferencePtr conference_ptr_;
+  scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
+
+  dolby_voice_client::webrtc_integration::DvcConference::
+      ConnectionBrokenListener* listener_;
+  dolby_voice_client::webrtc_integration::DvcConference::RtpSink* rtp_sink_;
+  mojo::Binding<mojom::DvcConferenceRtpSink> rtp_sink_binding_;
+};
+
+}  // namespace renderer
+}  // namespace dolby_voice_client
+
+#endif  // DOLBY_CONTENT_RENDERER_DVC_CONFERENCE_CLIENT_H_
diff --git a/dolby/content/renderer/dvc_conference_factory_client.cc b/dolby/content/renderer/dvc_conference_factory_client.cc
new file mode 100644
index 00000000000..220e2a1b7d4
--- /dev/null
+++ b/dolby/content/renderer/dvc_conference_factory_client.cc
@@ -0,0 +1,137 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/content/renderer/dvc_conference_factory_client.h"
+
+#include "base/task/post_task.h"
+#include "dolby/content/renderer/dvc_conference_client.h"
+#include "dolby/content/renderer/dvc_utils.h"
+#include "dolby/services/dolby_voice_client/dvc_utils.h"
+
+namespace dolby_voice_client {
+namespace renderer {
+
+DvcConferenceFactoryClient::DvcConferenceFactoryClient(content::RenderThread* render_thread) {
+  task_runner_ = base::CreateSingleThreadTaskRunner(
+      {base::ThreadPool(), base::MayBlock(), base::TaskShutdownBehavior::BLOCK_SHUTDOWN},
+      base::SingleThreadTaskRunnerThreadMode::DEDICATED);
+  {
+    ScopedCompletionEvent event;
+    task_runner_->PostTask(
+        FROM_HERE,
+        base::BindOnce(&DvcConferenceFactoryClient::InitializeOnTaskRunner,
+                       base::Unretained(this), base::Unretained(render_thread),
+                       base::Unretained(&event)));
+  }
+}
+
+DvcConferenceFactoryClient::~DvcConferenceFactoryClient() {
+  {
+    ScopedCompletionEvent event;
+    task_runner_->PostTask(
+        FROM_HERE,
+        base::BindOnce(&DvcConferenceFactoryClient::ShutDownOnTaskRunner,
+                       base::Unretained(this), base::Unretained(&event)));
+  }
+}
+
+std::unique_ptr<dolby_voice_client::webrtc_integration::DvcConference>
+DvcConferenceFactoryClient::CreateConference() {
+  std::unique_ptr<dolby_voice_client::webrtc_integration::DvcConference>
+      conference;
+  {
+    ScopedCompletionEvent event;
+    task_runner_->PostTask(
+        FROM_HERE,
+        base::BindOnce(
+            &DvcConferenceFactoryClient::CreateConferenceOnTaskRunner,
+            base::Unretained(this), base::Unretained(&conference),
+            base::Unretained(&event)));
+  }
+  return conference;
+}
+
+bool DvcConferenceFactoryClient::GetAudioCodecsList(
+    std::vector<dolby_voice_client::webrtc_integration::DvcAudioCodec>&
+        out_codecs) {
+  {
+    ScopedCompletionEvent event;
+    task_runner_->PostTask(
+        FROM_HERE,
+        base::BindOnce(
+            &DvcConferenceFactoryClient::GetAudioCodecsListOnTaskRunner,
+            base::Unretained(this), base::Unretained(&out_codecs),
+            base::Unretained(&event)));
+  }
+  return !out_codecs.empty();
+}
+
+void DvcConferenceFactoryClient::InitializeOnTaskRunner(
+    content::RenderThread* render_thread,
+    ScopedCompletionEvent* event) {
+  DCHECK(task_runner_->BelongsToCurrentThread());
+
+  connection_ =
+      std::make_unique<DvcConferenceFactoryConnection>(render_thread);
+
+  dolby_voice_client::webrtc_integration::DvcConferenceFactory::
+      SetGlobalInstance(this);
+
+  DCHECK(connection_);
+  DCHECK(event != nullptr);
+  event->SignalCompleted();
+}
+
+void DvcConferenceFactoryClient::ShutDownOnTaskRunner(
+    ScopedCompletionEvent* event) {
+  DCHECK(task_runner_->BelongsToCurrentThread());
+  connection_.reset();
+
+  dolby_voice_client::webrtc_integration::DvcConferenceFactory::
+      SetGlobalInstance(nullptr);
+
+  DCHECK(event != nullptr);
+  event->SignalCompleted();
+}
+
+void DvcConferenceFactoryClient::GetAudioCodecsListOnTaskRunner(
+    std::vector<dolby_voice_client::webrtc_integration::DvcAudioCodec>*
+        out_codecs,
+    ScopedCompletionEvent* event) {
+  DCHECK(task_runner_->BelongsToCurrentThread());
+  connection_->GetAudioCodecsList(base::BindOnce(
+      &DvcConferenceFactoryClient::OnAudioCodecsListReceived,
+      base::Unretained(this), base::Unretained(out_codecs), event));
+}
+
+void DvcConferenceFactoryClient::OnAudioCodecsListReceived(
+    std::vector<dolby_voice_client::webrtc_integration::DvcAudioCodec>*
+        out_codecs,
+    ScopedCompletionEvent* event,
+    std::vector<::dolby_voice_client::mojom::AudioCodecPtr> codec_ptrs) {
+  DCHECK(task_runner_->BelongsToCurrentThread());
+  DCHECK(out_codecs != nullptr);
+
+  for (const auto& codec_ptr : codec_ptrs) {
+    out_codecs->emplace_back(ConvertCodec(*codec_ptr));
+  }
+  DCHECK(event != nullptr);
+  event->SignalCompleted();
+}
+
+void DvcConferenceFactoryClient::CreateConferenceOnTaskRunner(
+    std::unique_ptr<dolby_voice_client::webrtc_integration::DvcConference>*
+        conference_out,
+    ScopedCompletionEvent* event) {
+  DCHECK(task_runner_->BelongsToCurrentThread());
+  DCHECK(conference_out != nullptr);
+  mojom::DvcConferencePtr conference_ptr = connection_->CreateConference();
+  conference_out->reset(
+      new DvcConferenceClient(std::move(conference_ptr), task_runner_));
+  DCHECK(event != nullptr);
+  event->SignalCompleted();
+}
+
+}  // namespace renderer
+}  // namespace dolby_voice_client
diff --git a/dolby/content/renderer/dvc_conference_factory_client.h b/dolby/content/renderer/dvc_conference_factory_client.h
new file mode 100644
index 00000000000..02400136152
--- /dev/null
+++ b/dolby/content/renderer/dvc_conference_factory_client.h
@@ -0,0 +1,58 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef DOLBY_CONTENT_RENDERER_DVC_CONFERENCE_FACTORY_CLIENT_H_
+#define DOLBY_CONTENT_RENDERER_DVC_CONFERENCE_FACTORY_CLIENT_H_
+
+#include "base/task_runner.h"
+#include "dolby/content/renderer/dvc_conference_factory_connection.h"
+#include "third_party/webrtc/dvc/dvc_conference_factory.h"
+
+namespace dolby_voice_client {
+
+class RtpAudio;
+class ScopedCompletionEvent;
+
+namespace renderer {
+
+class DvcConferenceFactoryClient
+    : public dolby_voice_client::webrtc_integration::DvcConferenceFactory {
+ public:
+  DvcConferenceFactoryClient(content::RenderThread* render_thread);
+  ~DvcConferenceFactoryClient() override;
+
+  bool GetAudioCodecsList(
+      std::vector<dolby_voice_client::webrtc_integration::DvcAudioCodec>&
+          out_codecs) override;
+  std::unique_ptr<dolby_voice_client::webrtc_integration::DvcConference>
+  CreateConference() override;
+
+ protected:
+  virtual void InitializeOnTaskRunner(
+      content::RenderThread* render_thread,
+      ScopedCompletionEvent* event);
+  virtual void ShutDownOnTaskRunner(ScopedCompletionEvent* event);
+
+  virtual void GetAudioCodecsListOnTaskRunner(
+      std::vector<dolby_voice_client::webrtc_integration::DvcAudioCodec>*
+          out_codecs,
+      ScopedCompletionEvent* event);
+  virtual void OnAudioCodecsListReceived(
+      std::vector<dolby_voice_client::webrtc_integration::DvcAudioCodec>*
+          out_codecs,
+      ScopedCompletionEvent* event,
+      std::vector<::dolby_voice_client::mojom::AudioCodecPtr> codec_ptrs);
+  virtual void CreateConferenceOnTaskRunner(
+      std::unique_ptr<dolby_voice_client::webrtc_integration::DvcConference>*
+          conference_out,
+      ScopedCompletionEvent* event);
+
+  scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
+  std::unique_ptr<DvcConferenceFactoryConnection> connection_;
+};
+
+}  // namespace renderer
+}  // namespace dolby_voice_client
+
+#endif  // DOLBY_CONTENT_RENDERER_DVC_CONFERENCE_FACTORY_CLIENT_H_
diff --git a/dolby/content/renderer/dvc_conference_factory_connection.cc b/dolby/content/renderer/dvc_conference_factory_connection.cc
new file mode 100644
index 00000000000..2b6c7ddb0a2
--- /dev/null
+++ b/dolby/content/renderer/dvc_conference_factory_connection.cc
@@ -0,0 +1,79 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/content/renderer/dvc_conference_factory_connection.h"
+
+#include "content/public/renderer/render_thread.h"
+#include "content/public/common/service_manager_connection.h"
+#include "dolby/services/dolby_voice_client/public/mojom/constants.mojom.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dvc_conference.mojom.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dvc_conference_types.mojom.h"
+#include "mojo/public/cpp/bindings/callback_helpers.h"
+
+namespace dolby_voice_client {
+namespace renderer {
+
+DvcConferenceFactoryConnection::DvcConferenceFactoryConnection(
+    content::RenderThread* render_thread)
+    : render_thread_(render_thread) {
+}
+
+DvcConferenceFactoryConnection::~DvcConferenceFactoryConnection() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  UninitializeInternal();
+}
+
+void DvcConferenceFactoryConnection::LazyConnectToService() {
+  if (dvc_provider_)
+    return;
+
+  render_thread_->BindHostReceiver(dvc_provider_.BindNewPipeAndPassReceiver());
+
+  dvc_provider_->ConnectToConferenceFactory(
+      mojo::MakeRequest(&conference_factory_));
+  // Unretained |this| is safe, because |this| owns |conference_factory_|.
+  conference_factory_.set_connection_error_handler(base::BindOnce(
+      &DvcConferenceFactoryConnection::OnLostConnectionToConferenceFactory,
+      base::Unretained(this)));
+}
+
+void DvcConferenceFactoryConnection::OnLostConnectionToConferenceFactory() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  // This may indicate that the service has crashed. Uninitialize
+  // here, so that a new connection will be established when clients try to
+  // reconnect.
+  UninitializeInternal();
+}
+
+void DvcConferenceFactoryConnection::UninitializeInternal() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (!conference_factory_.is_bound())
+    return;
+
+  conference_factory_.reset();
+  dvc_provider_.reset();
+}
+
+void DvcConferenceFactoryConnection::GetAudioCodecsList(
+    mojom::DvcConferenceFactory::GetAudioCodecsListCallback callback) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  LazyConnectToService();
+
+  conference_factory_->GetAudioCodecsList(
+      mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+          std::move(callback), std::vector<mojom::AudioCodecPtr>()));
+}
+
+mojom::DvcConferencePtr DvcConferenceFactoryConnection::CreateConference() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  LazyConnectToService();
+
+  mojom::DvcConferencePtr conference;
+  conference_factory_->CreateConference(mojo::MakeRequest(&conference));
+
+  return conference;
+}
+
+}  // namespace renderer
+}  // namespace dolby_voice_client
diff --git a/dolby/content/renderer/dvc_conference_factory_connection.h b/dolby/content/renderer/dvc_conference_factory_connection.h
new file mode 100644
index 00000000000..e1c09564a0b
--- /dev/null
+++ b/dolby/content/renderer/dvc_conference_factory_connection.h
@@ -0,0 +1,48 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef DOLBY_CONTENT_RENDERER_DVC_CONFERENCE_FACTORY_CONNECTION_H_
+#define DOLBY_CONTENT_RENDERER_DVC_CONFERENCE_FACTORY_CONNECTION_H_
+
+#include "base/threading/thread_checker.h"
+#include "mojo/public/cpp/bindings/remote.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dolby_voice_client_provider.mojom.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dvc_conference_factory.mojom.h"
+
+namespace content {
+class RenderThread;
+}
+
+namespace dolby_voice_client {
+namespace renderer {
+
+class DvcConferenceFactoryConnection {
+ public:
+  explicit DvcConferenceFactoryConnection(content::RenderThread* render_thread_impl);
+  virtual ~DvcConferenceFactoryConnection();
+
+  // Copy of mojom::DvcConferenceFactory interface.
+  virtual void GetAudioCodecsList(
+      mojom::DvcConferenceFactory::GetAudioCodecsListCallback callback);
+  virtual mojom::DvcConferencePtr CreateConference();
+
+ protected:
+  void LazyConnectToService();
+  void OnLostConnectionToConferenceFactory();
+  void UninitializeInternal();
+
+  SEQUENCE_CHECKER(sequence_checker_);
+
+  content::RenderThread* render_thread_;
+
+  // We must hold on to |dvc_provider_| because it holds the
+  // service-side binding for |conference_factory_|.
+  mojo::Remote<mojom::DolbyVoiceClientProvider> dvc_provider_;
+  mojom::DvcConferenceFactoryPtr conference_factory_;
+};
+
+}  // namespace renderer
+}  // namespace dolby_voice_client
+
+#endif  // DOLBY_CONTENT_RENDERER_DVC_CONFERENCE_FACTORY_CONNECTION_H_
diff --git a/dolby/content/renderer/dvc_utils.cc b/dolby/content/renderer/dvc_utils.cc
new file mode 100644
index 00000000000..952d0d116b4
--- /dev/null
+++ b/dolby/content/renderer/dvc_utils.cc
@@ -0,0 +1,73 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/content/renderer/dvc_utils.h"
+
+namespace dolby_voice_client {
+namespace renderer {
+
+#define ENSURE_ENUMS_IN_SYNC(TypeA, TypeB, val)                               \
+  static_assert(static_cast<int>(TypeA::val) == static_cast<int>(TypeB::val), \
+                "Enums not in sync!")
+
+ENSURE_ENUMS_IN_SYNC(dolby_voice_client::webrtc_integration::DvcRTPEncoding,
+                     mojom::RTPEncoding,
+                     DVC2);
+ENSURE_ENUMS_IN_SYNC(dolby_voice_client::webrtc_integration::DvcRTPEncoding,
+                     mojom::RTPEncoding,
+                     PCMU);
+ENSURE_ENUMS_IN_SYNC(dolby_voice_client::webrtc_integration::DvcRTPEncoding,
+                     mojom::RTPEncoding,
+                     PCMA);
+ENSURE_ENUMS_IN_SYNC(dolby_voice_client::webrtc_integration::DvcRTPEncoding,
+                     mojom::RTPEncoding,
+                     G722);
+ENSURE_ENUMS_IN_SYNC(dolby_voice_client::webrtc_integration::DvcRTPEncoding,
+                     mojom::RTPEncoding,
+                     TELEPHONE_EVENT);
+
+ENSURE_ENUMS_IN_SYNC(dolby_voice_client::webrtc_integration::DVC2SourceSide,
+                     mojom::DVC2SourceSide,
+                     CLIENT);
+ENSURE_ENUMS_IN_SYNC(dolby_voice_client::webrtc_integration::DVC2SourceSide,
+                     mojom::DVC2SourceSide,
+                     SERVER);
+
+namespace {
+
+template <typename OUT, typename IN>
+OUT Convert(IN val) {
+  return static_cast<OUT>(static_cast<int>(val));
+}
+
+template <typename OUT, typename IN>
+OUT ConvertTCodec(const IN& codec) {
+  OUT ret = {
+      Convert<decltype(ret.encoding), decltype(codec.encoding)>(codec.encoding),
+      codec.clock_rate,
+      codec.rtp_payload_type,
+      codec.has_dvc2_params,
+      Convert<decltype(ret.dvc2_source_side), decltype(codec.dvc2_source_side)>(
+          codec.dvc2_source_side),
+      codec.dvc2_protocol_version};
+  return ret;
+}
+
+}  // namespace
+
+dolby_voice_client::webrtc_integration::DvcAudioCodec ConvertCodec(
+    const mojom::AudioCodec& codec) {
+  return ConvertTCodec<dolby_voice_client::webrtc_integration::DvcAudioCodec,
+                       mojom::AudioCodec>(codec);
+}
+
+mojom::AudioCodec ConvertCodec(
+    const dolby_voice_client::webrtc_integration::DvcAudioCodec& codec) {
+  return ConvertTCodec<mojom::AudioCodec,
+                       dolby_voice_client::webrtc_integration::DvcAudioCodec>(
+      codec);
+}
+
+}  // namespace renderer
+}  // namespace dolby_voice_client
diff --git a/dolby/content/renderer/dvc_utils.h b/dolby/content/renderer/dvc_utils.h
new file mode 100644
index 00000000000..cfd7723be1a
--- /dev/null
+++ b/dolby/content/renderer/dvc_utils.h
@@ -0,0 +1,22 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef DOLBY_CONTENT_RENDERER_DVC_UTILS_H_
+#define DOLBY_CONTENT_RENDERER_DVC_UTILS_H_
+
+#include "dolby/services/dolby_voice_client/public/mojom/dvc_conference_types.mojom.h"
+#include "third_party/webrtc/dvc/dvc_conference_factory.h"
+
+namespace dolby_voice_client {
+namespace renderer {
+
+dolby_voice_client::webrtc_integration::DvcAudioCodec ConvertCodec(
+    const mojom::AudioCodec& codec);
+mojom::AudioCodec ConvertCodec(
+    const dolby_voice_client::webrtc_integration::DvcAudioCodec& codec);
+
+}  // namespace renderer
+}  // namespace dolby_voice_client
+
+#endif  // DOLBY_CONTENT_RENDERER_DVC_UTILS_H_
diff --git a/dolby/services/dolby_voice_client/BUILD.gn b/dolby/services/dolby_voice_client/BUILD.gn
new file mode 100644
index 00000000000..e9a992b158d
--- /dev/null
+++ b/dolby/services/dolby_voice_client/BUILD.gn
@@ -0,0 +1,106 @@
+# Copyright 2020 Dolby Laboratories and Dolby International AB
+# Use of this source code is governed by the MIT license that can be
+# found in the dolby/LICENSE file.
+
+import("//services/service_manager/public/cpp/service_executable.gni")
+import("//testing/test.gni")
+
+import("//dolby/services/dolby_voice_client/dvmc.gni")
+
+config("dvc_sdk") {
+  lib_dirs = [] + dvc_lib_dirs
+  libs = [] + dvc_libs
+  include_dirs = [] + dvc_includes
+}
+
+service_executable("dolby_voice_client") {
+  sources = [
+    "service_main.cc",
+  ]
+
+  deps = [
+    ":lib",
+    "//mojo/public/cpp/system",
+    "//dolby/services/dolby_voice_client/public/cpp",
+    "//dolby/services/dolby_voice_client/public/mojom",
+  ]
+}
+
+source_set("dvc_utils") {
+  sources = [
+    "dvc_utils.cc",
+    "dvc_utils.h",
+    "switches.cc",
+    "vars.cc",
+  ]
+
+  public_deps = [
+    "//base",
+  ]
+}
+
+source_set("lib") {
+  sources = [
+    "dvc_library.cc",
+    "dvc_library.h",
+    "dvc_library_helpers.cc",
+    "dvc_library_helpers.h",
+    "dvc_conference_factory_impl.cc",
+    "dvc_conference_factory_impl.h",
+    "dvc_conference_impl.cc",
+    "dvc_conference_impl.h",
+    "dvc_device_manager_impl.cc",
+    "dvc_device_manager_impl.h",
+    "dolby_voice_client_provider_impl.cc",
+    "dolby_voice_client_provider_impl.h",
+    "service_impl.cc",
+    "service_impl.h",
+    "testing_controls_impl.cc",
+    "testing_controls_impl.h",
+    "dvc_state_dump.cc",
+    "logging.cc",
+  ]
+
+  public_configs = [ ":dvc_sdk" ]
+
+  public_deps = [
+    ":dvc_utils",
+    "//services/service_manager/public/cpp",
+    "//dolby/services/dolby_voice_client/public/cpp",
+    "//dolby/services/dolby_voice_client/public/mojom",
+    "//dolby/services/dolby_voice_client/public/mojom:constants",
+  ]
+}
+
+# source_set("tests") {
+#   testonly = true
+#
+#   sources = [
+#     "test/dolby_voice_client_provider_connectortest.cc",
+#   ]
+#
+#   deps = [
+#     ":lib",
+#     ":dolby_voice_client",
+#     "//base/test:test_support",
+#     "//services/service_manager/public/cpp",
+#     "//services/service_manager/public/cpp:service_test_support",
+#     "//services/service_manager/public/cpp/test:test_support",
+#     "//testing/gmock",
+#     "//testing/gtest",
+#   ]
+#
+#   data_deps = [
+#     ":dolby_voice_client",
+#   ]
+# }
+#
+# service_manifest("unittest_manifest") {
+#   name = "dolby_voice_client_unittests"
+#   source = "test/service_unittest_manifest.json"
+# }
+#
+# catalog("tests_catalog") {
+#   embedded_services = [ ":unittest_manifest" ]
+#   standalone_services = [ ":manifest" ]
+# }
diff --git a/dolby/services/dolby_voice_client/dolby_voice_client_provider_impl.cc b/dolby/services/dolby_voice_client/dolby_voice_client_provider_impl.cc
new file mode 100644
index 00000000000..ff567c3e98e
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dolby_voice_client_provider_impl.cc
@@ -0,0 +1,91 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/services/dolby_voice_client/dolby_voice_client_provider_impl.h"
+
+#include "base/logging.h"
+#include "base/memory/ptr_util.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "dolby/services/dolby_voice_client/dvc_conference_factory_impl.h"
+#include "dolby/services/dolby_voice_client/dvc_device_manager_impl.h"
+#include "logging.h"
+
+namespace dolby_voice_client {
+
+static const std::string kUnableToInitializeDVCLibraryMsg =
+    "Unable to initialize DVC library!";
+
+DolbyVoiceClientProviderImpl::DolbyVoiceClientProviderImpl(
+    std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive)
+    : keepalive_(std::move(keepalive)) {}
+
+DolbyVoiceClientProviderImpl::~DolbyVoiceClientProviderImpl() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+}
+
+void DolbyVoiceClientProviderImpl::ConnectToConferenceFactory(
+    mojom::DvcConferenceFactoryRequest request) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (LazyInitializeConferenceFactory()) {
+    conference_factory_bindings_.AddBinding(conference_factory_.get(),
+                                            std::move(request));
+  } else {
+    request.ResetWithReason(MOJO_RESULT_UNKNOWN,
+                            kUnableToInitializeDVCLibraryMsg);
+  }
+}
+
+void DolbyVoiceClientProviderImpl::ConnectToDeviceManager(
+    mojom::DvcDeviceManagerRequest request) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (LazyInitializeDeviceManager()) {
+    device_manager_bindings_.AddBinding(device_manager_.get(),
+                                        std::move(request));
+  } else {
+    request.ResetWithReason(MOJO_RESULT_UNKNOWN,
+                            kUnableToInitializeDVCLibraryMsg);
+  }
+}
+
+bool DolbyVoiceClientProviderImpl::LazyInitializeConferenceFactory() {
+  if (conference_factory_)
+    return true;
+
+  if (LazyInitializeDvcLibrary()) {
+    conference_factory_ = std::make_unique<DvcConferenceFactoryImpl>(
+        keepalive_->Clone(), *dvc_library_.get());
+    return true;
+  } else {
+    return false;
+  }
+}
+
+bool DolbyVoiceClientProviderImpl::LazyInitializeDeviceManager() {
+  if (device_manager_)
+    return true;
+
+  if (LazyInitializeDvcLibrary()) {
+    device_manager_ = std::make_unique<DvcDeviceManagerImpl>(
+        keepalive_->Clone(), *dvc_library_.get());
+    return true;
+  } else {
+    return false;
+  }
+}
+
+bool DolbyVoiceClientProviderImpl::LazyInitializeDvcLibrary() {
+  if (dvc_library_)
+    return true;
+
+  dvc_library_ = std::make_unique<DvcLibrary>();
+  if (dvc_library_->Initialize(base::ThreadTaskRunnerHandle::Get())) {
+    return true;
+  } else {
+    DVEF_ERROR_LOG << "Unable to initialize DVC library!";
+    dvc_library_.reset();
+    return false;
+  }
+}
+
+}  // namespace dolby_voice_client
diff --git a/dolby/services/dolby_voice_client/dolby_voice_client_provider_impl.h b/dolby/services/dolby_voice_client/dolby_voice_client_provider_impl.h
new file mode 100644
index 00000000000..a4c8b95fea6
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dolby_voice_client_provider_impl.h
@@ -0,0 +1,55 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef SERVICES_DOLBY_VOICE_CLIENT_PROVIDER_H_
+#define SERVICES_DOLBY_VOICE_CLIENT_PROVIDER_H_
+
+#include <memory>
+
+#include "base/threading/thread_checker.h"
+#include "mojo/public/cpp/bindings/binding_set.h"
+#include "services/service_manager/public/cpp/service.h"
+#include "services/service_manager/public/cpp/service_keepalive.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dolby_voice_client_provider.mojom.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dvc_device_manager.mojom.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dvc_conference_factory.mojom.h"
+
+namespace dolby_voice_client {
+
+class DvcLibrary;
+
+class DolbyVoiceClientProviderImpl : public mojom::DolbyVoiceClientProvider {
+ public:
+  DolbyVoiceClientProviderImpl(
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive);
+  ~DolbyVoiceClientProviderImpl() override;
+
+  // mojom::DolbyVoiceClientProvider implementation.
+  void ConnectToConferenceFactory(
+      mojom::DvcConferenceFactoryRequest request) override;
+  void ConnectToDeviceManager(mojom::DvcDeviceManagerRequest request) override;
+
+ private:
+  bool LazyInitializeDvcLibrary();
+  bool LazyInitializeConferenceFactory();
+  bool LazyInitializeDeviceManager();
+
+  SEQUENCE_CHECKER(sequence_checker_);
+
+  std::unique_ptr<DvcLibrary> dvc_library_;
+
+  mojo::BindingSet<mojom::DvcConferenceFactory> conference_factory_bindings_;
+  std::unique_ptr<mojom::DvcConferenceFactory> conference_factory_;
+
+  mojo::BindingSet<mojom::DvcDeviceManager> device_manager_bindings_;
+  std::unique_ptr<mojom::DvcDeviceManager> device_manager_;
+
+  const std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_;
+
+  DISALLOW_COPY_AND_ASSIGN(DolbyVoiceClientProviderImpl);
+};
+
+}  // namespace dolby_voice_client
+
+#endif  // SERVICES_DOLBY_VOICE_CLIENT_PROVIDER_H_
diff --git a/dolby/services/dolby_voice_client/dvc_conference_factory_impl.cc b/dolby/services/dolby_voice_client/dvc_conference_factory_impl.cc
new file mode 100644
index 00000000000..cfea62b1336
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_conference_factory_impl.cc
@@ -0,0 +1,128 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/services/dolby_voice_client/dvc_conference_factory_impl.h"
+
+#include <algorithm>
+
+#include "base/logging.h"
+#include "base/memory/ptr_util.h"
+#include "dolby/services/dolby_voice_client/dvc_conference_impl.h"
+
+namespace dolby_voice_client {
+
+DvcConferenceFactoryImpl::DvcConferenceFactoryImpl(
+    std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive,
+    DvcLibrary& dvc_library)
+    : dvc_library_(dvc_library), keepalive_(std::move(keepalive)) {
+  dvc_library_.AddListener(this);
+}
+
+DvcConferenceFactoryImpl::~DvcConferenceFactoryImpl() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  dvc_library_.RemoveListener(this);
+}
+
+void DvcConferenceFactoryImpl::GetAudioCodecsList(
+    GetAudioCodecsListCallback callback) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  std::vector<mojom::AudioCodecPtr> out_codecs;
+  const auto& codecs = dvc_library_.GetCodecs();
+  for (const auto& codec : codecs) {
+    out_codecs.emplace_back(base::in_place, codec.encoding, codec.clock_rate,
+                            codec.rtp_payload_type, codec.has_dvc2_params,
+                            codec.dvc2_source_side,
+                            codec.dvc2_protocol_version);
+  }
+  std::move(callback).Run(std::move(out_codecs));
+}
+
+void DvcConferenceFactoryImpl::CreateConference(
+    mojom::DvcConferenceRequest request) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  std::unique_ptr<DvcConferenceImpl> conference =
+      std::make_unique<DvcConferenceImpl>(
+          keepalive_->Clone(), std::move(request), dvc_library_, *this);
+  conferences_.emplace_back(std::move(conference));
+}
+
+void DvcConferenceFactoryImpl::RtpAudioCallback(
+    DVC_Handle handle,
+    std::unique_ptr<RtpAudio> rtp_audio) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  for (auto& conference : conferences_) {
+    if (handle == conference->GetClientHandle())
+      conference->HandleRtpAudio(std::move(rtp_audio));
+  }
+}
+
+void DvcConferenceFactoryImpl::OnConnectionStatusChanged(
+    DVC_Handle handle,
+    DVC_Status current_conf_status,
+    std::string& error_desc) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  for (auto& conference : conferences_) {
+    if (handle == conference->GetClientHandle())
+      conference->OnConnectionStatusChanged(current_conf_status, error_desc);
+  }
+}
+
+void DvcConferenceFactoryImpl::OnDeviceChanged(DVC_Direction direction,
+                                               int no_device,
+                                               DVC_DeviceGuid guid) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  // Ignore
+}
+
+void DvcConferenceFactoryImpl::OnDeviceAdded(DVC_DeviceGuid guid) {
+
+}
+
+void DvcConferenceFactoryImpl::OnDeviceRemoved(DVC_DeviceGuid guid) {
+
+}
+
+bool DvcConferenceFactoryImpl::OnStartAudioProcessing(DvcConferenceImpl* conf,
+                                                      std::string* err_desc) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  int started_conferences = 0;
+  for (auto& conference : conferences_) {
+    if (conference && conference->IsActive())
+      started_conferences++;
+  }
+  if (started_conferences > 0) {
+    return dvc_library_.ResumeAudio(DVC_DIRECTION_INPUT_AND_OUTPUT, err_desc);
+  } else {
+    if (err_desc != nullptr)
+      *err_desc = "No active conferences";
+    return false;
+  }
+}
+
+bool DvcConferenceFactoryImpl::OnStopAudioProcessing(DvcConferenceImpl* conf,
+                                                     std::string* err_desc) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  int started_conferences = 0;
+  for (auto& conference : conferences_) {
+    if (conference && conference->IsActive())
+      started_conferences++;
+  }
+  if (started_conferences == 0) {
+    return dvc_library_.PauseAudio(DVC_DIRECTION_INPUT_AND_OUTPUT, err_desc);
+  }
+  return true;
+}
+
+void DvcConferenceFactoryImpl::OnConferenceDisconnected(DvcConferenceImpl* conf,
+                                                        std::string& reason) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  auto comparator =
+      [conf](const std::unique_ptr<DvcConferenceImpl>& c) -> bool {
+    return conf == c.get();
+  };
+  conferences_.erase(
+      std::remove_if(conferences_.begin(), conferences_.end(), comparator));
+}
+
+}  // namespace dolby_voice_client
diff --git a/dolby/services/dolby_voice_client/dvc_conference_factory_impl.h b/dolby/services/dolby_voice_client/dvc_conference_factory_impl.h
new file mode 100644
index 00000000000..0e6cf1327e6
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_conference_factory_impl.h
@@ -0,0 +1,68 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef SERVICES_DOLBY_VOICE_CLIENT_CONFERENCE_FACTORY_H_
+#define SERVICES_DOLBY_VOICE_CLIENT_CONFERENCE_FACTORY_H_
+
+#include <memory>
+
+#include "base/threading/thread_checker.h"
+#include "mojo/public/cpp/bindings/binding_set.h"
+#include "services/service_manager/public/cpp/service.h"
+#include "services/service_manager/public/cpp/service_context_ref.h"
+
+#include "dolby/services/dolby_voice_client/dvc_conference_impl.h"
+#include "dolby/services/dolby_voice_client/dvc_library.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dvc_conference_factory.mojom.h"
+
+namespace dolby_voice_client {
+
+class DvcConferenceFactoryImpl : public mojom::DvcConferenceFactory,
+                                 public DvcLibrary::Listener,
+                                 public DvcConferenceImpl::Listener {
+ public:
+  DvcConferenceFactoryImpl(
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> service_ref,
+      DvcLibrary& dvc_library);
+  ~DvcConferenceFactoryImpl() override;
+
+  // mojom::DvcConferenceFactory implementation.
+  void GetAudioCodecsList(GetAudioCodecsListCallback callback) override;
+  void CreateConference(mojom::DvcConferenceRequest request) override;
+
+  // DvcLibrary::Listener implementation
+  void RtpAudioCallback(DVC_Handle handle,
+                        std::unique_ptr<RtpAudio> rtp_audio) override;
+  void OnConnectionStatusChanged(DVC_Handle handle,
+                                 DVC_Status current_conf_status,
+                                 std::string& error_desc) override;
+  void OnDeviceChanged(DVC_Direction direction,
+                       int no_device,
+                       DVC_DeviceGuid guid) override;
+  void OnDeviceAdded(DVC_DeviceGuid guid) override;
+  void OnDeviceRemoved(DVC_DeviceGuid guid) override;
+
+  // DvcConferenceImpl::Listener implementation
+  bool OnStartAudioProcessing(DvcConferenceImpl* conf,
+                              std::string* err_desc) override;
+  bool OnStopAudioProcessing(DvcConferenceImpl* conf,
+                             std::string* err_desc) override;
+  void OnConferenceDisconnected(DvcConferenceImpl* conf,
+                                std::string& reason) override;
+
+ private:
+  void OnBindingConnectionError(uint32_t custom_reason,
+                                const std::string& description);
+
+  SEQUENCE_CHECKER(sequence_checker_);
+  DvcLibrary& dvc_library_;
+  std::vector<std::unique_ptr<DvcConferenceImpl>> conferences_;
+  const std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_;
+
+  DISALLOW_COPY_AND_ASSIGN(DvcConferenceFactoryImpl);
+};
+
+}  // namespace dolby_voice_client
+
+#endif  // SERVICES_DOLBY_VOICE_CLIENT_CONFERENCE_FACTORY_H_
diff --git a/dolby/services/dolby_voice_client/dvc_conference_impl.cc b/dolby/services/dolby_voice_client/dvc_conference_impl.cc
new file mode 100644
index 00000000000..b6f13c19ac8
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_conference_impl.cc
@@ -0,0 +1,333 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/services/dolby_voice_client/dvc_conference_impl.h"
+
+#include "base/memory/ptr_util.h"
+
+#include <cstring>
+
+#include "logging.h"
+
+namespace dolby_voice_client {
+
+namespace {
+
+double CalculateAdditionalEnergy(double level) {
+  double additional_energy = level;
+  if (additional_energy <= -100.0)
+    additional_energy = 0;
+  else
+    additional_energy = pow(10, additional_energy / 20);
+
+  additional_energy *= additional_energy;
+
+  return additional_energy;
+}
+
+}  // namespace
+
+DvcConferenceImpl::DvcConferenceImpl(
+    std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive,
+    mojom::DvcConferenceRequest request,
+    DvcLibrary& library,
+    Listener& listener)
+    : keepalive_(std::move(keepalive)),
+      binding_(this, std::move(request)),
+      dvc_library_(library),
+      listener_(listener),
+      client_handle_(DVC_INVALID_HANDLE),
+      active_(false) {
+  binding_.set_connection_error_with_reason_handler(base::BindRepeating(
+      &DvcConferenceImpl::OnBindingConnectionError, base::Unretained(this)));
+}
+
+DvcConferenceImpl::~DvcConferenceImpl() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  StopInternal(true);
+  if (client_handle_ != DVC_INVALID_HANDLE) {
+    std::string err_desc;
+    if (!dvc_library_.DestroyClient(client_handle_, &err_desc)) {
+      DVEF_ERROR_LOG << "Can't destroy client: " << err_desc;
+    }
+    client_handle_ = DVC_INVALID_HANDLE;
+  }
+}
+
+bool DvcConferenceImpl::HandleRtpAudio(std::unique_ptr<RtpAudio> rtp_audio) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (active_ && rtp_audio) {
+    int64_t timestamp_us = rtp_audio->TimeStamp().ToInternalValue();
+    if (rtp_sink_.is_bound()) {
+      std::vector<uint8_t> packet(rtp_audio->Data(), rtp_audio->Data() + rtp_audio->Len());
+      rtp_sink_->SendRtp(std::move(packet), timestamp_us);
+      return true;
+    }
+  }
+  return false;
+}
+
+void DvcConferenceImpl::OnConnectionStatusChanged(
+    DVC_Status current_conf_status,
+    std::string& error_desc) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (active_) {
+    if (current_conf_status.connection_status ==
+            DVC_CONNECTION_STATUS_FAILED) {
+      std::string close_reason = "Conference media connection failed: ";
+      close_reason.append(error_desc + " (" +
+                          std::to_string(current_conf_status.error) + ")");
+
+      binding_.CloseWithReason(MOJO_RESULT_UNKNOWN, close_reason);
+      OnConferenceDisconnectedInternal(close_reason, true);
+    }
+  }
+}
+
+void DvcConferenceImpl::Update(mojom::AudioCodecPtr codec,
+                               UpdateCallback callback) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  std::string err_desc;
+  if (client_handle_ == DVC_INVALID_HANDLE) {
+    if (!dvc_library_.CreateClient(&client_handle_, &err_desc)) {
+      err_desc = "Can't create client: " + err_desc;
+      DVEF_ERROR_LOG << err_desc;
+      std::move(callback).Run(false, err_desc);
+      return;
+    }
+  }
+
+  if (active_) {
+    ResetInternalStats();
+    if (!dvc_library_.StopRtpAudioCommunication(client_handle_, &err_desc)) {
+      err_desc = "Can't stop active conference: " + err_desc;
+      DVEF_ERROR_LOG << err_desc;
+      std::move(callback).Run(false, err_desc);
+      return;
+    }
+    active_ = false;
+    listener_.OnStopAudioProcessing(this, &err_desc);
+  }
+
+  RtpCommunicationParamsWrapper params;
+  if (!params.SetFromMojo(*codec)) {
+    err_desc = "No codecs supported";
+    DVEF_ERROR_LOG << err_desc;
+    std::move(callback).Run(false, err_desc);
+    return;
+  }
+
+  if (!dvc_library_.StartRtpAudioCommunication(client_handle_, &params.params,
+                                               &err_desc)) {
+    err_desc = "Can't start rtp communication: " + err_desc;
+    DVEF_ERROR_LOG << err_desc;
+    std::move(callback).Run(false, err_desc);
+    return;
+  }
+
+  active_ = true;
+  if (!listener_.OnStartAudioProcessing(this, &err_desc)) {
+    Stop();
+    err_desc = "Can't start audio processing: " + err_desc;
+    DVEF_ERROR_LOG << "error: " << err_desc;
+    std::move(callback).Run(false, err_desc);
+    return;
+  }
+
+  std::move(callback).Run(true, err_desc);
+}
+
+void DvcConferenceImpl::Stop() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  StopInternal(false);
+}
+
+void DvcConferenceImpl::StopInternal(bool destroying) {
+  if (active_) {
+    ResetInternalStats();
+
+    std::string err_desc;
+    if (!dvc_library_.StopRtpAudioCommunication(client_handle_, &err_desc)) {
+      DVEF_ERROR_LOG << "Can't stop conference: " << err_desc;
+    }
+    active_ = false;
+
+    if (!destroying && !listener_.OnStopAudioProcessing(this, &err_desc)) {
+      DVEF_ERROR_LOG << "Can't stop audio processing: " << err_desc;
+    }
+  }
+}
+
+void DvcConferenceImpl::ResetInternalStats() {
+  prev_in_packets_total_ = 0;
+  total_output_energy_ = 0.0;
+  prev_out_packets_total_ = 0;
+  total_input_energy_ = 0.0;
+}
+
+void DvcConferenceImpl::HandleReceivedRtpPacket(
+    const std::vector<uint8_t>& packet) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (active_) {
+    std::string err_desc;
+    if (!dvc_library_.HandleRtpAudio(
+            client_handle_, reinterpret_cast<const char*>(packet.data()),
+            static_cast<unsigned int>(packet.size()), &err_desc)) {
+      DVEF_ERROR_LOG << err_desc;
+    }
+  }
+}
+
+void DvcConferenceImpl::GetAudioSessionStats(
+    GetAudioSessionStatsCallback callback) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  std::string err_desc;
+  DVC_ClientStats client_stats;
+  if (!dvc_library_.GetClientStats(client_handle_, &client_stats, &err_desc)) {
+    DVEF_ERROR_LOG << err_desc;
+    mojom::StatsPtr stats_ptr(base::in_place, mojom::Stats());
+    std::move(callback).Run(std::move(stats_ptr));
+    return;
+  }
+
+  mojom::Stats stats;
+  stats.codec_name = CodecIdToName(client_stats.codec);
+  stats.in_jitter = client_stats.downlink_jitter;
+  stats.in_jitter_buffer_ms = client_stats.downlink_latency;
+
+  const unsigned int downlink_total_packets =
+      client_stats.downlink_packet_played_count +
+      client_stats.downlink_packet_loss_count;
+  if (downlink_total_packets > 0)
+    stats.in_packet_loss_fraction =
+        static_cast<double>(client_stats.downlink_packet_loss_count) /
+        downlink_total_packets;
+  else
+    stats.in_packet_loss_fraction = 0;
+
+  stats.in_packets_total = client_stats.downlink_packet_count;
+  stats.in_conceals_total = client_stats.downlink_packet_corrected_count;
+  stats.in_voice_level =
+      (client_stats.audio_stats.output_level + 100) / 100 * 32767;
+
+  stats.out_jitter = client_stats.uplink_jitter;
+  stats.out_jitter_buffer_ms = client_stats.uplink_latency;
+
+  const unsigned int uplink_total_packets =
+      client_stats.uplink_packet_played_count +
+      client_stats.uplink_packet_loss_count;
+  if (uplink_total_packets > 0)
+    stats.out_packet_loss_fraction =
+        static_cast<double>(client_stats.uplink_packet_loss_count) /
+        uplink_total_packets;
+  else
+    stats.out_packet_loss_fraction = 0;
+
+  stats.out_packets_total = client_stats.uplink_packet_count;
+  stats.transmit_level =
+      (client_stats.audio_stats.transmit_level + 100) / 100 * 32767;
+  stats.avg_rtt_to_as = client_stats.round_trip_time;
+  stats.out_fec_action_counter = client_stats.uplink_packet_corrected_count;
+
+  stats.echo_delay_ms = client_stats.io_latency;
+
+  CalculateTotalEnergy(client_stats, stats);
+
+  std::move(callback).Run(mojom::StatsPtr(base::in_place, stats));
+}
+
+void DvcConferenceImpl::CalculateTotalEnergy(
+    const DVC_ClientStats& client_stats,
+    mojom::Stats& stats) {
+  constexpr double kPacketDurationSeconds = 0.02;
+  double additional_energy;
+
+  additional_energy =
+      CalculateAdditionalEnergy(client_stats.audio_stats.transmit_level);
+  total_output_energy_ += additional_energy *
+                          (stats.in_packets_total - prev_in_packets_total_) *
+                          kPacketDurationSeconds;
+  prev_in_packets_total_ = stats.in_packets_total;
+  stats.total_output_energy = total_output_energy_;
+
+  additional_energy =
+      CalculateAdditionalEnergy(client_stats.audio_stats.output_level);
+  total_input_energy_ += additional_energy *
+                         (stats.out_packets_total - prev_out_packets_total_) *
+                         kPacketDurationSeconds;
+  prev_out_packets_total_ = stats.out_packets_total;
+  stats.total_input_energy = total_input_energy_;
+}
+
+void DvcConferenceImpl::SetMinimumPlayoutDelay(int32_t delay_ms) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (active_) {
+    int calculated_delay = 20 * ((delay_ms + 10) / 20);
+    if (calculated_delay < 0) {
+      calculated_delay = 0;
+      DVEF_WARN_LOG << "Delay " << delay_ms
+                   << " lower than 0 is below bounds, trying best-effort "
+                      "approach to set zero delay";
+    } else if (calculated_delay > 900) {
+      calculated_delay = 900;
+      DVEF_WARN_LOG << "Delay " << delay_ms
+                   << " higher than 900 is above bounds, trying best-effort "
+                      "approach to set 900ms delay";
+    }
+
+    std::string err_desc;
+    if (!dvc_library_.SetDownlinkMinimumLatency(
+            client_handle_, static_cast<unsigned int>(calculated_delay),
+            &err_desc)) {
+      DVEF_ERROR_LOG << err_desc;
+    }
+  }
+}
+
+void DvcConferenceImpl::SetMute(bool mute) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (active_) {
+    std::string err_desc;
+    if (!dvc_library_.SetMute(client_handle_, DVC_DIRECTION_INPUT,
+                              mute ? 1 : 0, &err_desc)) {
+      DVEF_ERROR_LOG << err_desc;
+    }
+  }
+}
+
+void DvcConferenceImpl::SetRtpSink(mojom::DvcConferenceRtpSinkPtr sink) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  rtp_sink_ = std::move(sink);
+  rtp_sink_.set_connection_error_with_reason_handler(base::BindRepeating(
+      &DvcConferenceImpl::OnRtpSinkConnectionError, base::Unretained(this)));
+}
+
+void DvcConferenceImpl::OnConferenceDisconnectedInternal(std::string& reason,
+                                                         bool log_error) {
+  LOG_IF(ERROR, log_error) << reason;
+  Stop();
+  listener_.OnConferenceDisconnected(this, reason);
+}
+
+void DvcConferenceImpl::OnBindingConnectionError(
+    uint32_t custom_reason,
+    const std::string& description) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  std::string reason = "Binding connection error";
+  reason.append(", custom_reason: " + std::to_string(custom_reason));
+  reason.append(", description: " + description);
+  OnConferenceDisconnectedInternal(reason, (custom_reason != MOJO_RESULT_OK));
+}
+
+void DvcConferenceImpl::OnRtpSinkConnectionError(
+    uint32_t custom_reason,
+    const std::string& description) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  std::string reason = "RtpSink connection error";
+  reason.append(", custom_reason: " + std::to_string(custom_reason));
+  reason.append(", description: " + description);
+  OnConferenceDisconnectedInternal(reason, (custom_reason != MOJO_RESULT_OK));
+}
+
+}  // namespace dolby_voice_client
diff --git a/dolby/services/dolby_voice_client/dvc_conference_impl.h b/dolby/services/dolby_voice_client/dvc_conference_impl.h
new file mode 100644
index 00000000000..5ff880f08da
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_conference_impl.h
@@ -0,0 +1,94 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef SERVICES_DOLBY_VOICE_CLIENT_CONFERENCE_H_
+#define SERVICES_DOLBY_VOICE_CLIENT_CONFERENCE_H_
+
+#include <memory>
+
+#include "base/threading/thread_checker.h"
+#include "mojo/public/cpp/bindings/binding.h"
+#include "services/service_manager/public/cpp/service.h"
+#include "services/service_manager/public/cpp/service_keepalive.h"
+
+#include "dolby/services/dolby_voice_client/dvc_library.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dvc_conference.mojom.h"
+
+namespace dolby_voice_client {
+
+class DvcConferenceImpl : public mojom::DvcConference {
+ public:
+  class Listener {
+   public:
+    virtual ~Listener(){}
+
+    virtual bool OnStartAudioProcessing(DvcConferenceImpl* conf,
+                                        std::string* err_desc) = 0;
+    virtual bool OnStopAudioProcessing(DvcConferenceImpl* conf,
+                                       std::string* err_desc) = 0;
+    virtual void OnConferenceDisconnected(DvcConferenceImpl* conf,
+                                          std::string& reason) = 0;
+  };
+
+  DvcConferenceImpl(
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive,
+      mojom::DvcConferenceRequest request,
+      DvcLibrary& library,
+      Listener& listener);
+  ~DvcConferenceImpl() override;
+
+  bool IsActive() { return active_; }
+  DVC_Handle GetClientHandle() { return client_handle_; }
+
+  bool HandleRtpAudio(std::unique_ptr<RtpAudio> rtp_audio);
+  void OnConnectionStatusChanged(DVC_Status current_conf_status,
+                                 std::string& error_desc);
+
+  // mojom::DvcConference implementation.
+  void Update(mojom::AudioCodecPtr codec, UpdateCallback callback) override;
+  void Stop() override;
+  void HandleReceivedRtpPacket(const std::vector<uint8_t>& packet) override;
+  void GetAudioSessionStats(GetAudioSessionStatsCallback callback) override;
+  void SetMinimumPlayoutDelay(int32_t delay_ms) override;
+  void SetMute(bool mute) override;
+  void SetRtpSink(mojom::DvcConferenceRtpSinkPtr sink) override;
+
+ protected:
+  void StopInternal(bool destroying);
+  void ResetInternalStats();
+  void CalculateTotalEnergy(const DVC_ClientStats& client_stats,
+                            mojom::Stats& stats);
+
+  void OnConferenceDisconnectedInternal(std::string& reason, bool log_error);
+
+  void OnBindingConnectionError(uint32_t custom_reason,
+                                const std::string& description);
+  void OnRtpSinkConnectionError(uint32_t custom_reason,
+                                const std::string& description);
+
+  SEQUENCE_CHECKER(sequence_checker_);
+
+  const std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_;
+  mojo::Binding<mojom::DvcConference> binding_;
+
+  DvcLibrary& dvc_library_;
+  Listener& listener_;
+
+  DVC_Handle client_handle_;
+
+  bool active_;
+  mojom::DvcConferenceRtpSinkPtr rtp_sink_;
+
+  double total_output_energy_ = 0.0;
+  unsigned long long prev_in_packets_total_ = 0;
+
+  double total_input_energy_ = 0.0;
+  unsigned long long prev_out_packets_total_ = 0;
+
+  DISALLOW_COPY_AND_ASSIGN(DvcConferenceImpl);
+};
+
+}  // namespace dolby_voice_client
+
+#endif  // SERVICES_DOLBY_VOICE_CLIENT_CONFERENCE_H_
diff --git a/dolby/services/dolby_voice_client/dvc_device_manager_impl.cc b/dolby/services/dolby_voice_client/dvc_device_manager_impl.cc
new file mode 100644
index 00000000000..23fcc24ef19
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_device_manager_impl.cc
@@ -0,0 +1,33 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/services/dolby_voice_client/dvc_device_manager_impl.h"
+
+#include "base/memory/ptr_util.h"
+#include "dolby/services/dolby_voice_client/dvc_library.h"
+
+namespace dolby_voice_client {
+
+DvcDeviceManagerImpl::DvcDeviceManagerImpl(
+    std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive,
+    DvcLibrary& dvc_library)
+    : keepalive_(std::move(keepalive)), dvc_library_(dvc_library) {}
+
+DvcDeviceManagerImpl::~DvcDeviceManagerImpl() {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+}
+
+void DvcDeviceManagerImpl::SetPreferredInputDevice(
+    const std::vector<int8_t>& native_device_id) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  dvc_library_.SetPreferredInputDevice(native_device_id);
+}
+
+void DvcDeviceManagerImpl::SetPreferredOutputDevice(
+    const std::vector<int8_t>& native_device_id) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  dvc_library_.SetPreferredOutputDevice(native_device_id);
+}
+
+}  // namespace dolby_voice_client
diff --git a/dolby/services/dolby_voice_client/dvc_device_manager_impl.h b/dolby/services/dolby_voice_client/dvc_device_manager_impl.h
new file mode 100644
index 00000000000..45200d224a9
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_device_manager_impl.h
@@ -0,0 +1,44 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef SERVICES_DOLBY_VOICE_CLIENT_DEVICE_MANAGER_H_
+#define SERVICES_DOLBY_VOICE_CLIENT_DEVICE_MANAGER_H_
+
+#include <memory>
+
+#include "base/threading/thread_checker.h"
+#include "mojo/public/cpp/bindings/binding_set.h"
+#include "services/service_manager/public/cpp/service.h"
+#include "services/service_manager/public/cpp/service_keepalive.h"
+
+#include "dolby/services/dolby_voice_client/public/mojom/dvc_device_manager.mojom.h"
+
+namespace dolby_voice_client {
+
+class DvcLibrary;
+
+class DvcDeviceManagerImpl : public mojom::DvcDeviceManager {
+ public:
+  DvcDeviceManagerImpl(
+      std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive,
+      DvcLibrary& dvc_library);
+  ~DvcDeviceManagerImpl() override;
+
+  // mojom::DvcDeviceManager implementation.
+  void SetPreferredInputDevice(
+      const std::vector<int8_t>& native_device_id) override;
+  void SetPreferredOutputDevice(
+      const std::vector<int8_t>& native_device_id) override;
+
+ private:
+  SEQUENCE_CHECKER(sequence_checker_);
+  const std::unique_ptr<service_manager::ServiceKeepaliveRef> keepalive_;
+  DvcLibrary& dvc_library_;
+
+  DISALLOW_COPY_AND_ASSIGN(DvcDeviceManagerImpl);
+};
+
+}  // namespace dolby_voice_client
+
+#endif  // SERVICES_DOLBY_VOICE_CLIENT_DEVICE_MANAGER_H_
diff --git a/dolby/services/dolby_voice_client/dvc_library.cc b/dolby/services/dolby_voice_client/dvc_library.cc
new file mode 100644
index 00000000000..7c33587bace
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_library.cc
@@ -0,0 +1,576 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/services/dolby_voice_client/dvc_library.h"
+
+#include <algorithm>
+#include <fstream>
+#include <iomanip>
+#include <utility>
+
+#include "build/build_config.h"
+
+#include "dolby/services/dolby_voice_client/dvc_state_dump.h"
+#include "dolby/services/dolby_voice_client/logging.h"
+#include "dolby/services/dolby_voice_client/vars.h"
+
+namespace dolby_voice_client {
+
+static_assert(DVC_VERSION_MAJOR == 3,
+              "The DVC integration sample code is meant to work with the 3.X.X "
+              "versions of Dolby Voice "
+              "Client library, any other use should be made at your "
+              "own risk!");
+
+namespace {
+
+#if OS_WIN
+std::tm* localtime_r(const std::time_t* t, std::tm* tm) {
+  return (_localtime64_s(tm, t) == 0) ? tm : nullptr;
+}
+#endif  // OS_WIN
+
+bool IsSameNativeId(const DVC_NativeDeviceInfo& a,
+                    const DVC_NativeDeviceInfo& b) {
+#if OS_MACOSX
+  return a.macos_coreaudio.id == b.macos_coreaudio.id;
+#elif OS_WIN
+  return (strncmp(a.windows_wasapi.guid, b.windows_wasapi.guid,
+                  sizeof(a.windows_wasapi.guid) - 1) == 0);
+#elif OS_LINUX
+  return a.linux_pulseaudio.index == b.linux_pulseaudio.index;
+#endif
+}
+
+DVC_NativeDeviceInfo ToNativeInfo(
+    const std::vector<int8_t>& native_device_id) {
+  DVC_NativeDeviceInfo ret{};
+#if OS_MACOSX
+  DCHECK(native_device_id.size() == sizeof(ret.macos_coreaudio.id));
+  if (native_device_id.size() == sizeof(ret.macos_coreaudio.id)) {
+    memcpy(&ret.macos_coreaudio.id, native_device_id.data(),
+           sizeof(ret.macos_coreaudio.id));
+  }
+#elif OS_WIN
+  size_t num = std::min(native_device_id.size(),
+                        static_cast<size_t>(DVC_MAX_NATIVE_ID_SIZE));
+  memcpy(ret.windows_wasapi.guid, native_device_id.data(), num);
+  ret.windows_wasapi.guid[num] = '\0';
+#elif OS_LINUX
+  DCHECK(native_device_id.size() == sizeof(ret.linux_pulseaudio.index));
+  if (native_device_id.size() == sizeof(ret.linux_pulseaudio.index)) {
+    memcpy(&ret.linux_pulseaudio.index, native_device_id.data(),
+           sizeof(ret.linux_pulseaudio.index));
+  }
+#endif
+
+  return ret;
+}
+
+}  // end anonymous namespace
+
+DvcLibrary::DvcLibrary() : exit_notify_(GenericNotify::Make()) {}
+
+DvcLibrary::~DvcLibrary() {
+  Shutdown();
+}
+
+bool DvcLibrary::Initialize(
+    const scoped_refptr<base::SingleThreadTaskRunner>& task_runner,
+    std::string* error_reason) {
+  DVC_Config dvc_config{};
+  dvc_config.callbacks_config.callback_context = this;
+  dvc_config.callbacks_config.library_callbacks_config.connection_status_changed = OnConnectionStatusChanged;
+  dvc_config.callbacks_config.device_callbacks_config.current_device_changed = OnDeviceChanged;
+  dvc_config.callbacks_config.device_callbacks_config.device_added = OnDeviceAdded;
+  dvc_config.callbacks_config.device_callbacks_config.device_removed = OnDeviceRemoved;
+  dvc_config.callbacks_config.packets_callbacks_config.rtp_packet_ready = RtpAudioCallback;
+
+  dvc_config.callbacks_config.library_callbacks_config.log_entry_ready = LogCallback;
+  dvc_config.logging.level = DVC_LOG_DEBUG;
+
+  DVC_Error err = DVC_Initialize(&dvc_config, DVC_VERSION);
+  if (err != DVC_ERROR_NONE) {
+    DVEF_ERROR_LOG << "Can not initialize the DVC library: "
+               << DVC_ErrorToString(err);
+    return false;
+  }
+
+  DVC_EventHandle dvc_event_handle;
+  err = DVC_GetEventHandle(&dvc_event_handle);
+  if (err != DVC_ERROR_NONE) {
+    DVEF_ERROR_LOG << "Can not get event handle: " << DVC_ErrorToString(err);
+    DVC_Shutdown();
+    return false;
+  }
+
+  // From now, the initialization will not fail.
+  mojo_task_runner_ = task_runner;
+
+  std::vector<DoCallbacksRunnable::EventWithCallback> events;
+  events.emplace_back(dvc_event_handle, []() { DVC_DoCallbacks(); });
+  runnable_.reset(
+      new DoCallbacksRunnable(exit_notify_->GetEventHandle(), events));
+  runnable_->Start();
+
+  GenerateAudioCodecsList();
+
+  is_initialized_ = true;
+
+  err = DVC_PauseAudio(DVC_DIRECTION_INPUT_AND_OUTPUT);
+  if (err != DVC_ERROR_NONE) {
+    DVEF_WARN_LOG << "Can not stop audio processing, CPU will be overused: "
+                 << DVC_ErrorToString(err);
+  }
+
+  const auto audio_logging_length =
+    getDolbyValueOr(switches::kDvcAudioLoggingLength, 0);
+  if (audio_logging_length > 0) {
+    err = DVC_SetAudioLoggingLength(audio_logging_length);
+    if (not err) {
+      DVEF_LOG << "Audio logging length set to " << audio_logging_length;
+      should_dump_state = true;
+    } else {
+      DVEF_ERROR_LOG
+        << "DVC_SetAudioLoggingLength failed: " << DVC_ErrorToString(err);
+    }
+  }
+
+  return true;
+}
+
+bool DvcLibrary::Shutdown(std::string* error_reason) {
+  if (mojo_task_runner_.get()) {
+    DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+    exit_notify_->Notify();
+    runnable_->Join();
+    exit_notify_->ClearNotify();
+    runnable_.reset();
+
+    DVC_Error err = DVC_Shutdown();
+    if (err != DVC_ERROR_NONE) {
+      DVEF_ERROR_LOG << "Can not shutdown the DVC library: "
+                 << DVC_ErrorToString(err);
+      return false;
+    }
+    listeners_.clear();
+    mojo_task_runner_ = nullptr;
+    is_initialized_ = false;
+
+    return true;
+  }
+  return false;
+}
+
+bool DvcLibrary::IsInitialized() {
+  return is_initialized_;
+}
+
+bool DvcLibrary::AddListener(Listener* listener) {
+  auto result = listeners_.insert(listener);
+  return result.second;
+}
+
+bool DvcLibrary::RemoveListener(Listener* listener) {
+  return (listeners_.erase(listener) != 0);
+}
+
+const std::vector<mojom::AudioCodec>& DvcLibrary::GetCodecs(
+    std::string* error_reason) const {
+  return codecs_;
+}
+
+void DvcLibrary::GenerateAudioCodecsList() {
+  codecs_.clear();
+  unsigned int length = 0;
+  const DVC_CodecConfig* configs = nullptr;
+  DVC_Error err = DVC_GetAvailableCodecConfigs(&configs, &length);
+  if (err != DVC_ERROR_NONE) {
+    DVEF_ERROR_LOG << "Can not get codecs list: " << DVC_ErrorToString(err);
+    return;
+  }
+
+  for (auto i = 0u; i < length; ++i) {
+    const auto& codec = configs[i];
+    if (not (codec.encoding == DVC_RTP_ENCODING_DVC2
+             and codec.encoding_parameters)) {
+      TranslateDVCCLCodec(codec, codecs_);
+    }
+  }
+}
+
+bool DvcLibrary::SetPreferredDeviceByNativeId(
+    const std::vector<int8_t>& native_device_id,
+    DVC_Direction dir) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  DVC_NativeDeviceInfo info = ToNativeInfo(native_device_id);
+  DVC_NativeDeviceInfo* other;
+
+  if (dir == DVC_DIRECTION_INPUT) {
+    other = &preferred_input_;
+  } else if (dir == DVC_DIRECTION_OUTPUT) {
+    other = &preferred_output_;
+  } else {
+    NOTREACHED();
+    return false;
+  }
+
+  if (!IsSameNativeId(info, *other)) {
+    *other = info;
+    for (const auto& dev : devices_) {
+      if (ShouldSetPreferredDevice(dev.second, dir)) {
+        if (SetPreferredDevice(dev.second, dir))
+          return true;
+      }
+    }
+  }
+  return false;
+}
+
+bool DvcLibrary::ShouldSetPreferredDevice(const DVC_Device& new_device,
+                                          DVC_Direction dir) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  if (new_device.direction & dir) {
+    const DVC_NativeDeviceInfo* info;
+    if (dir == DVC_DIRECTION_INPUT) {
+      info = &preferred_input_;
+    } else if (dir == DVC_DIRECTION_OUTPUT) {
+      info = &preferred_output_;
+    } else {
+      return false;
+    }
+    return IsSameNativeId(new_device.native_device_info, *info);
+  }
+  return false;
+}
+
+bool DvcLibrary::SetPreferredDevice(const DVC_Device& new_device,
+                                    DVC_Direction dir) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+
+  const auto err = DVC_SetDevice(dir, new_device.guid);
+  if (err != DVC_ERROR_NONE) {
+    DVEF_ERROR_LOG << "Can not set preferred device " << new_device.name << ": "
+               << DVC_ErrorToString(err);
+    return false;
+  }
+  return true;
+}
+
+bool DvcLibrary::MaybeSetPreferredDevice(const DVC_Device& new_device) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  bool success = true;
+  for (auto dir : {DVC_DIRECTION_INPUT, DVC_DIRECTION_OUTPUT}) {
+    if (ShouldSetPreferredDevice(new_device, dir)) {
+      success &= SetPreferredDevice(new_device, dir);
+    }
+  }
+  return success;
+}
+
+void DvcLibrary::RtpAudioCallback(DVC_Handle handle,
+                                  const void* data,
+                                  unsigned int len,
+                                  void* context) {
+  DvcLibrary* self = static_cast<DvcLibrary*>(context);
+  std::unique_ptr<RtpAudio> rtp_audio = std::make_unique<RtpAudio>(data, len);
+  self->mojo_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&DvcLibrary::OnRtpAudioCallbackOnMojoThread,
+                     base::Unretained(self), handle, std::move(rtp_audio)));
+}
+
+void DvcLibrary::OnConnectionStatusChanged(DVC_Handle handle,
+                                           DVC_Status current_conf_status,
+                                           void* context) {
+  DvcLibrary* self = static_cast<DvcLibrary*>(context);
+  self->mojo_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&DvcLibrary::OnConnectionStatusChangedOnMojoThread,
+                     base::Unretained(self), handle, current_conf_status));
+}
+
+void DvcLibrary::OnDeviceChanged(DVC_Direction direction,
+                                 int no_device,
+                                 DVC_DeviceGuid guid,
+                                 void* context) {
+  DvcLibrary* self = static_cast<DvcLibrary*>(context);
+  self->mojo_task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(&DvcLibrary::OnDeviceChangedOnMojoThread,
+                                base::Unretained(self), direction, no_device, guid));
+}
+
+void DvcLibrary::OnDeviceAdded(DVC_DeviceGuid guid,
+                               void* context) {
+  DvcLibrary* self = static_cast<DvcLibrary*>(context);
+  self->mojo_task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(&DvcLibrary::OnDeviceAddedOnMojoThread,
+                                base::Unretained(self), guid));
+}
+
+void DvcLibrary::OnDeviceRemoved(DVC_DeviceGuid guid,
+                                 void* context) {
+  DvcLibrary* self = static_cast<DvcLibrary*>(context);
+  self->mojo_task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(&DvcLibrary::OnDeviceRemovedOnMojoThread,
+                                base::Unretained(self), guid));
+}
+
+void DvcLibrary::LogCallback(DVC_Handle handle,
+                             DVC_LogLevel level,
+                             time_t timestamp_sec,
+                             unsigned timestamp_usec,
+                             const char* subsystem,
+                             const char* msg_id,
+                             const char* message,
+                             void* context) {
+  std::string subsystem_str = subsystem != nullptr ? subsystem : "";
+  std::string msg_id_str = msg_id != nullptr ? msg_id : "";
+  std::string message_str = message != nullptr ? message : "";
+
+  std::stringstream log_message_ss;
+
+  std::tm tm;
+  auto* t = localtime_r(&timestamp_sec, &tm);
+
+  log_message_ss << std::setfill('0') << std::setw(2) << t->tm_hour << ":"
+                 << std::setfill('0') << std::setw(2) << t->tm_min << ":"
+                 << std::setfill('0') << std::setw(2) << t->tm_sec << "."
+                 << std::setfill('0') << std::setw(6) << timestamp_usec << ": "
+                 << std::setfill(' ') << std::setw(9) << LogLevelToString(level)
+                 << " " << subsystem_str << " " << msg_id_str << " "
+                 << message_str;
+
+  switch (level) {
+    case DVC_LOG_NONE:
+    case DVC_LOG_DEBUG: {
+      DVEF_LOG << log_message_ss.str();
+      break;
+    }
+    case DVC_LOG_EMERGENCY:
+    case DVC_LOG_ALERT:
+    case DVC_LOG_CRITICAL:
+    case DVC_LOG_ERROR: {
+      DVEF_ERROR_LOG << log_message_ss.str();
+      break;
+    }
+    case DVC_LOG_WARNING: {
+      DVEF_WARN_LOG << log_message_ss.str();
+      break;
+    }
+    case DVC_LOG_NOTICE:
+    case DVC_LOG_INFO:
+    case DVC_LOG_DEFAULT: {
+      DVEF_LOG << log_message_ss.str();
+      break;
+    }
+  }
+}
+
+void DvcLibrary::OnRtpAudioCallbackOnMojoThread(
+    DVC_Handle handle,
+    std::unique_ptr<RtpAudio> rtp_audio) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  for (auto* listener : listeners_)
+    listener->RtpAudioCallback(handle, std::move(rtp_audio));
+}
+
+void DvcLibrary::OnConnectionStatusChangedOnMojoThread(
+    DVC_Handle handle,
+    const DVC_Status current_conf_status) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  std::string err_desc;
+  HandleResult(current_conf_status.error, &err_desc);
+  for (auto* listener : listeners_)
+    listener->OnConnectionStatusChanged(handle, current_conf_status, err_desc);
+}
+
+void DvcLibrary::OnDeviceChangedOnMojoThread(DVC_Direction direction,
+                                             int no_device,
+                                             DVC_DeviceGuid guid) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  std::string id(guid.data, DVC_DEVICE_GUID_SIZE);
+
+  DVC_Device device{};
+  DVC_Error err = DVC_GetDevice(guid, &device);
+  if (err != DVC_ERROR_NONE) {
+    DVEF_ERROR_LOG << "Can not get device " << id << ": "
+               << DVC_ErrorToString(err);
+    return;
+  }
+
+  auto it = devices_.find(id);
+  if (it != devices_.end()) {
+    it->second = device;
+  }
+
+  for (auto* listener : listeners_)
+    listener->OnDeviceChanged(direction, no_device, guid);
+}
+
+void DvcLibrary::OnDeviceAddedOnMojoThread(DVC_DeviceGuid guid) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  std::string id(guid.data, DVC_DEVICE_GUID_SIZE);
+
+  DVC_Device device{};
+  DVC_Error err = DVC_GetDevice(guid, &device);
+  if (err != DVC_ERROR_NONE) {
+	  DVEF_ERROR_LOG << "Can not get device " << id << ": "
+	             << DVC_ErrorToString(err);
+	  return;
+  }
+
+  auto it = devices_.find(id);
+  if (it != devices_.end()) {
+	    it->second = device;
+  } else {
+	  devices_.insert(std::make_pair(id, device));
+	  MaybeSetPreferredDevice(device);
+  }
+
+  for (auto* listener : listeners_)
+	listener->OnDeviceAdded(guid);
+}
+
+void DvcLibrary::OnDeviceRemovedOnMojoThread(DVC_DeviceGuid guid) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  std::string id(guid.data, DVC_DEVICE_GUID_SIZE);
+
+  auto it = devices_.find(id);
+	DCHECK(it != devices_.end());
+	if (it != devices_.end())
+		devices_.erase(it);
+
+  for (auto* listener : listeners_)
+    listener->OnDeviceRemoved(guid);
+ }
+
+bool DvcLibrary::HandleResult(DVC_Error error, std::string* error_reason) {
+  if (error != DVC_ERROR_NONE) {
+    if (error_reason != nullptr) {
+      *error_reason = DVC_ErrorToString(error);
+    }
+    return false;
+  }
+  return true;
+}
+
+bool DvcLibrary::PauseAudio(DVC_Direction direction, std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  DVC_Error error = DVC_PauseAudio(direction);
+  return HandleResult(error, error_reason);
+}
+
+bool DvcLibrary::ResumeAudio(DVC_Direction direction, std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  DVC_Error error = DVC_ResumeAudio(direction);
+  return HandleResult(error, error_reason);
+}
+
+bool DvcLibrary::GetAudioStats(DVC_AudioStats* stats,
+                               std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  DVC_Error error = DVC_GetAudioStats(stats);
+  return HandleResult(error, error_reason);
+}
+
+bool DvcLibrary::SetPreferredInputDevice(
+    const std::vector<int8_t>& native_device_id,
+    std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  return SetPreferredDeviceByNativeId(native_device_id, DVC_DIRECTION_INPUT);
+}
+
+bool DvcLibrary::SetPreferredOutputDevice(
+  const std::vector<int8_t>& native_device_id,
+    std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  return SetPreferredDeviceByNativeId(native_device_id, DVC_DIRECTION_OUTPUT);
+}
+
+bool DvcLibrary::CreateClient(DVC_Handle* handle, std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  DVC_Error error = DVC_CreateClient(handle);
+  return HandleResult(error, error_reason);
+}
+
+bool DvcLibrary::DestroyClient(DVC_Handle handle, std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  DVC_Error error = DVC_DestroyClient(handle);
+  return HandleResult(error, error_reason);
+}
+
+bool DvcLibrary::StartRtpAudioCommunication(
+    DVC_Handle handle,
+    const DVC_RtpCommunicationConfig* config,
+    std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  DVC_Error error = DVC_StartRtpCommunication(handle, config);
+  return HandleResult(error, error_reason);
+}
+
+bool DvcLibrary::HandleRtpAudio(DVC_Handle handle,
+                                const char* data,
+                                unsigned int len,
+                                std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  DVC_Error error = DVC_HandleRtpPacket(handle, data, len);
+  return HandleResult(error, error_reason);
+}
+
+bool DvcLibrary::HandleRtcpPacket(DVC_Handle handle,
+                                  const char* data,
+                                  unsigned int len,
+                                  std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  DVC_Error error = DVC_HandleRtcpPacket(handle, data, len);
+  return HandleResult(error, error_reason);
+}
+
+bool DvcLibrary::StopRtpAudioCommunication(DVC_Handle handle,
+                                           std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+
+  if (should_dump_state) {
+    StateDump{handle};
+  }
+
+  DVC_Error error = DVC_StopRtpCommunication(handle);
+  return HandleResult(error, error_reason);
+}
+
+bool DvcLibrary::SetDownlinkMinimumLatency(DVC_Handle handle,
+                                           unsigned int latency,
+                                           std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  DVC_Error error = DVC_SetDownlinkMinimumLatency(handle, latency);
+  return HandleResult(error, error_reason);
+}
+
+bool DvcLibrary::GetDownlinkMinimumLatency(DVC_Handle handle,
+                                           unsigned int* latency,
+                                           std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  DVC_Error error = DVC_GetDownlinkMinimumLatency(handle, latency);
+  return HandleResult(error, error_reason);
+}
+
+bool DvcLibrary::GetClientStats(DVC_Handle handle,
+                                DVC_ClientStats* stats,
+                                std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  DVC_Error error = DVC_GetClientStats(handle, stats);
+  return HandleResult(error, error_reason);
+}
+
+bool DvcLibrary::SetMute(DVC_Handle handle,
+                         DVC_Direction direction,
+                         int mute,
+                         std::string* error_reason) {
+  DCHECK(mojo_task_runner_->BelongsToCurrentThread());
+  DVC_Error error = DVC_SetMute(handle, direction, mute);
+  return HandleResult(error, error_reason);
+}
+
+}  // namespace dolby_voice_client
diff --git a/dolby/services/dolby_voice_client/dvc_library.h b/dolby/services/dolby_voice_client/dvc_library.h
new file mode 100644
index 00000000000..d850445b5ab
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_library.h
@@ -0,0 +1,184 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef SERVICES_DOLBY_VOICE_CLIENT_DVC_LIBRARY_H_
+#define SERVICES_DOLBY_VOICE_CLIENT_DVC_LIBRARY_H_
+
+#include <atomic>
+#include <string>
+#include <unordered_set>
+#include <vector>
+
+#include <dvclient.h>
+
+#include "base/bind.h"
+#include "base/macros.h"
+#include "base/memory/scoped_refptr.h"
+#include "base/single_thread_task_runner.h"
+#include "base/threading/simple_thread.h"
+#include "base/time/time.h"
+
+#include "dvc_library_helpers.h"
+#include "dvc_utils.h"
+
+namespace dolby_voice_client {
+
+class DvcLibrary {
+ public:
+  class Listener {
+   public:
+    virtual ~Listener() = default;
+
+    virtual void RtpAudioCallback(DVC_Handle handle,
+                                  std::unique_ptr<RtpAudio> rtp_audio) = 0;
+    virtual void OnConnectionStatusChanged(DVC_Handle handle,
+                                           DVC_Status current_conf_status,
+                                           std::string& error_desc) = 0;
+    virtual void OnDeviceChanged(DVC_Direction direction,
+                                 int no_device,
+                                 DVC_DeviceGuid guid) = 0;
+    virtual void OnDeviceAdded(DVC_DeviceGuid guid) = 0;
+    virtual void OnDeviceRemoved(DVC_DeviceGuid guid) = 0;
+  };
+
+  DvcLibrary();
+  virtual ~DvcLibrary();
+
+  virtual bool Initialize(
+      const scoped_refptr<base::SingleThreadTaskRunner>& task_runner,
+      std::string* error_reason = nullptr);
+  virtual bool Shutdown(std::string* error_reason = nullptr);
+
+  virtual bool IsInitialized();
+
+  virtual bool AddListener(Listener* listener);
+  virtual bool RemoveListener(Listener* listener);
+
+  virtual const std::vector<mojom::AudioCodec>& GetCodecs(
+      std::string* error_reason = nullptr) const;
+
+  virtual bool PauseAudio(DVC_Direction direction, std::string* error_reason = nullptr);
+  virtual bool ResumeAudio(DVC_Direction direction, std::string* error_reason = nullptr);
+
+  virtual bool GetAudioStats(DVC_AudioStats* stats,
+                             std::string* error_reason = nullptr);
+
+  virtual bool SetPreferredInputDevice(
+      const std::vector<int8_t>& native_device_id,
+      std::string* error_reason = nullptr);
+  virtual bool SetPreferredOutputDevice(
+      const std::vector<int8_t>& native_device_id,
+      std::string* error_reason = nullptr);
+
+  virtual bool CreateClient(DVC_Handle* handle,
+                            std::string* error_reason = nullptr);
+  virtual bool DestroyClient(DVC_Handle handle,
+                             std::string* error_reason = nullptr);
+  virtual bool StartRtpAudioCommunication(
+      DVC_Handle handle,
+      const DVC_RtpCommunicationConfig* config,
+      std::string* error_reason = nullptr);
+  virtual bool HandleRtpAudio(DVC_Handle handle,
+                              const char* data,
+                              unsigned int len,
+                              std::string* error_reason = nullptr);
+  virtual bool HandleRtcpPacket(DVC_Handle handle,
+                                const char* data,
+                                unsigned int len,
+                                std::string* error_reason = nullptr);
+  virtual bool StopRtpAudioCommunication(DVC_Handle handle,
+                                         std::string* error_reason = nullptr);
+
+  virtual bool SetDownlinkMinimumLatency(DVC_Handle handle,
+                                         unsigned int latency,
+                                         std::string* error_reason = nullptr);
+  virtual bool GetDownlinkMinimumLatency(DVC_Handle handle,
+                                         unsigned int* latency,
+                                         std::string* error_reason = nullptr);
+
+  virtual bool SetMute(DVC_Handle handle,
+                       DVC_Direction direction,
+                       int mute,
+                       std::string* error_reason = nullptr);
+
+  virtual bool GetClientStats(DVC_Handle handle,
+                              DVC_ClientStats* stats,
+                              std::string* error_reason = nullptr);
+
+ protected:
+  // start DVCCL callbacks
+  static void RtpAudioCallback(DVC_Handle handle,
+                               const void* data,
+                               unsigned int len,
+                               void* context);
+  static void OnConnectionStatusChanged(DVC_Handle,
+                                        DVC_Status current_conf_status,
+                                        void* context);
+  static void OnDeviceChanged(DVC_Direction direction,
+                              int no_device,
+                              DVC_DeviceGuid guid,
+                              void* context);
+  static void OnDeviceAdded(DVC_DeviceGuid guid, void* context);
+  static void OnDeviceRemoved(DVC_DeviceGuid guid, void* context);
+  static void LogCallback(DVC_Handle,
+                          DVC_LogLevel level,
+                          time_t timestamp_sec,
+                          unsigned timestamp_usec,
+                          const char* subsystem,
+                          const char* msg_id,
+                          const char* message,
+                          void* context);
+  // end DVCCL callbacks
+  virtual void OnRtpAudioCallbackOnMojoThread(
+      DVC_Handle handle,
+      std::unique_ptr<RtpAudio> rtp_audio);
+  virtual void OnConnectionStatusChangedOnMojoThread(
+      DVC_Handle handle,
+      const DVC_Status current_conf_status);
+  virtual void OnDeviceChangedOnMojoThread(DVC_Direction direction,
+                                           int no_device,
+                                           DVC_DeviceGuid guid);
+  virtual void OnDeviceAddedOnMojoThread(DVC_DeviceGuid guid);
+  virtual void OnDeviceRemovedOnMojoThread(DVC_DeviceGuid guid);
+
+  virtual void GenerateAudioCodecsList();
+
+  virtual bool SetPreferredDeviceByNativeId(
+      const std::vector<int8_t>& native_device_id,
+      DVC_Direction dir);
+
+  virtual bool ShouldSetPreferredDevice(const DVC_Device& new_device,
+                                        DVC_Direction dir);
+  virtual bool SetPreferredDevice(const DVC_Device& new_device,
+                                  DVC_Direction dir);
+  virtual bool MaybeSetPreferredDevice(const DVC_Device& new_device);
+
+  virtual bool HandleResult(DVC_Error err, std::string* error_reason);
+
+ private:
+  std::atomic<bool> is_initialized_;
+
+  scoped_refptr<base::SingleThreadTaskRunner> mojo_task_runner_;
+
+  std::unordered_set<Listener*> listeners_;
+
+  // Handling DoCallbacks:
+  std::unique_ptr<GenericNotify> exit_notify_;
+  std::unique_ptr<DoCallbacksRunnable> runnable_;
+
+  // Cached codecs list:
+  std::vector<mojom::AudioCodec> codecs_;
+
+  DVC_NativeDeviceInfo preferred_input_;
+  DVC_NativeDeviceInfo preferred_output_;
+  std::unordered_map<std::string, DVC_Device> devices_;
+
+  bool should_dump_state = false;
+
+  DISALLOW_COPY_AND_ASSIGN(DvcLibrary);
+};
+
+}  // namespace dolby_voice_client
+
+#endif  // SERVICES_DOLBY_VOICE_CLIENT_DVC_LIBRARY_H_
diff --git a/dolby/services/dolby_voice_client/dvc_library_helpers.cc b/dolby/services/dolby_voice_client/dvc_library_helpers.cc
new file mode 100644
index 00000000000..19de95272f7
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_library_helpers.cc
@@ -0,0 +1,295 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/services/dolby_voice_client/dvc_library_helpers.h"
+
+#include "dolby/services/dolby_voice_client/vars.h"
+#include "dolby/services/dolby_voice_client/logging.h"
+
+#include "build/build_config.h"
+#include "third_party/webrtc/dvc/dvc_constants.h"
+
+#if OS_WIN
+#include <stdlib.h>
+#include <windows.h>
+#endif
+
+namespace dolby_voice_client {
+
+namespace {
+
+#if OS_POSIX
+class GenericNotifyImpl final : public GenericNotify {
+ public:
+  GenericNotifyImpl() {
+    if (pipe(m_pipe) != 0) {
+      m_pipe[0] = 0;
+    }
+  }
+
+  ~GenericNotifyImpl() override {
+    if (m_pipe[0]) {
+      close(m_pipe[1]);
+      close(m_pipe[0]);
+    }
+  }
+
+  DVC_EventHandle GetEventHandle() const override { return m_pipe[0]; }
+
+  void Notify() override {
+    ++m_pending;
+    (void)write(m_pipe[1], "c", 1);
+  }
+
+  void ClearNotify() override {
+    if (m_pending > 0) {
+      char c;
+      (void)read(m_pipe[0], &c, 1);
+      --m_pending;
+    }
+  }
+
+ private:
+  int m_pipe[2];
+  int m_pending = 0;
+};
+#elif OS_WIN
+class GenericNotifyImpl final : public GenericNotify {
+ public:
+  GenericNotifyImpl() : m_event(CreateEvent(nullptr, FALSE, FALSE, nullptr)) {
+    //if (!m_event)
+      //throw std::runtime_error("Can not create exit notifier event!");
+  }
+
+  ~GenericNotifyImpl() override { CloseHandle(m_event); }
+
+  DVC_EventHandle GetEventHandle() const override { return m_event; }
+
+  void Notify() override { SetEvent(m_event); }
+
+  void ClearNotify() override { ResetEvent(m_event); }
+
+ private:
+  HANDLE m_event;
+};
+#else
+#error Unsupported platform
+#endif
+
+}  // end anonymous namespace
+
+GenericNotify::~GenericNotify() {}
+
+std::unique_ptr<GenericNotify> GenericNotify::Make() {
+  return std::unique_ptr<GenericNotify>(new GenericNotifyImpl());
+}
+
+bool RtpCommunicationParamsWrapper::SetFromMojo(
+    const mojom::AudioCodec& codec) {
+  if (codec.encoding == mojom::RTPEncoding::TELEPHONE_EVENT)
+    return false;
+
+  params = {};
+  protocol = {};
+  dvc2_params = {};
+
+  params.reserved = nullptr;
+  params.protocol_config = &protocol;
+  protocol.dtmf_payload_type = 101;
+  protocol.codec_config.clock_rate = codec.clock_rate;
+  protocol.codec_config.encoding = CodecToRtpEncoding(codec);
+
+  if (protocol.codec_config.encoding == static_cast<DVC_RtpEncoding>(-1))
+    return false;
+  if (protocol.codec_config.encoding == DVC_RTP_ENCODING_DVC2 &&
+      codec.has_dvc2_params) {
+    switch (codec.dvc2_source_side) {
+      case mojom::DVC2SourceSide::CLIENT:
+        dvc2_params.source = DVC_SOURCE_SIDE_CLIENT;
+        break;
+      case mojom::DVC2SourceSide::SERVER:
+        dvc2_params.source = DVC_SOURCE_SIDE_SERVER;
+        break;
+      default:
+        return false;
+    }
+
+    dvc2_params.connection_mode = DVC_CONNECTION_MODE_CS;
+
+    dvc2_params.protocol_version = codec.dvc2_protocol_version;
+
+    protocol.codec_config.encoding_parameters = &dvc2_params;
+  }
+  protocol.rtp_payload_type = static_cast<char>(codec.rtp_payload_type);
+  return true;
+}
+
+DoCallbacksRunnable::DoCallbacksRunnable(
+    DVC_EventHandle exit_notify,
+    const std::vector<EventWithCallback>& events)
+    : base::SimpleThread("DVCCallbackThread"), events_(events), exit_(false) {
+  events_.emplace_back(exit_notify, [this]() { exit_ = true; });
+}
+
+DoCallbacksRunnable::~DoCallbacksRunnable() {}
+
+void DoCallbacksRunnable::Run() {
+  while (!exit_) {
+    bool err = !HandleEvents();
+    if (err)
+      break;
+  }
+}
+
+bool DoCallbacksRunnable::HandleEvents() {
+#if OS_POSIX
+  fd_set fds;
+  FD_ZERO(&fds);
+  for (auto& handle : events_)
+    FD_SET(std::get<0>(handle), &fds);
+
+  int status = select(FD_SETSIZE, &fds, nullptr, nullptr, nullptr);
+  if (status > 0) {
+    for (auto& handle : events_) {
+      if (FD_ISSET(std::get<0>(handle), &fds))
+        std::get<1>(handle)();
+    }
+    return true;
+  } else {
+    return false;
+  }
+#elif OS_WIN
+  HANDLE handles[MAXIMUM_WAIT_OBJECTS];
+  if (events_.size() > MAXIMUM_WAIT_OBJECTS) {
+    // "Too many handles"
+    return false;
+  }
+  for (auto i = 0u; i < events_.size(); ++i)
+    handles[i] = std::get<0>(events_[i]);
+
+  DWORD status = WaitForMultipleObjects(static_cast<DWORD>(events_.size()),
+                                        handles, FALSE, INFINITE);
+
+  if (status >= WAIT_OBJECT_0 && status - WAIT_OBJECT_0 < events_.size()) {
+    std::get<1>(events_[status - WAIT_OBJECT_0])();
+    return true;
+  } else {
+    return false;
+  }
+#else
+#error Unsupported platform
+#endif
+}
+
+std::string LogLevelToString(DVC_LogLevel level) {
+  switch (level) {
+    case DVC_LOG_DEFAULT:
+      return "DEFAULT";
+    case DVC_LOG_NONE:
+      return "NONE";
+    case DVC_LOG_EMERGENCY:
+      return "EMERGENCY";
+    case DVC_LOG_ALERT:
+      return "ALERT";
+    case DVC_LOG_CRITICAL:
+      return "CRITICAL";
+    case DVC_LOG_ERROR:
+      return "ERROR";
+    case DVC_LOG_WARNING:
+      return "WARNING";
+    case DVC_LOG_NOTICE:
+      return "NOTICE";
+    case DVC_LOG_INFO:
+      return "INFO";
+    case DVC_LOG_DEBUG:
+      return "DEBUG";
+  }
+  return "UNKNOWN";
+}
+
+mojom::RTPEncoding CodecConfigRtpEncoding(const DVC_CodecConfig& config) {
+  switch (config.encoding) {
+    case DVC_RTP_ENCODING_DVC2:
+      return mojom::RTPEncoding::DVC2;
+    case DVC_RTP_ENCODING_PCMU:
+      return mojom::RTPEncoding::PCMU;
+    case DVC_RTP_ENCODING_PCMA:
+      return mojom::RTPEncoding::PCMA;
+    case DVC_RTP_ENCODING_G722:
+      return mojom::RTPEncoding::G722;
+    case DVC_RTP_ENCODING_TELEPHONE_EVENT:
+      return mojom::RTPEncoding::TELEPHONE_EVENT;
+  }
+  NOTREACHED();
+  return static_cast<mojom::RTPEncoding>(-1);
+}
+
+int CodecConfigPayloadType(const DVC_CodecConfig& config) {
+  switch (config.encoding) {
+    case DVC_RTP_ENCODING_DVC2:
+      return getDolbyValueOr(switches::kDvcPayloadType,
+                             webrtc_integration::DVC_PAYLOAD_TYPE);
+    case DVC_RTP_ENCODING_PCMU:
+      return 0;
+    case DVC_RTP_ENCODING_PCMA:
+      return 8;
+    case DVC_RTP_ENCODING_G722:
+      return 9;
+    case DVC_RTP_ENCODING_TELEPHONE_EVENT:
+      return 101;
+  }
+  NOTREACHED();
+  return -1;
+}
+
+void TranslateDVCCLCodec(const DVC_CodecConfig& config,
+                         std::vector<mojom::AudioCodec>& codecs) {
+  switch (config.encoding) {
+    case DVC_RTP_ENCODING_TELEPHONE_EVENT:
+    case DVC_RTP_ENCODING_PCMU:
+    case DVC_RTP_ENCODING_PCMA:
+    case DVC_RTP_ENCODING_G722:
+    case DVC_RTP_ENCODING_DVC2: {
+      codecs.emplace_back(
+          CodecConfigRtpEncoding(config), config.clock_rate,
+          CodecConfigPayloadType(config), false /* has_dvc2_params */,
+          mojom::DVC2SourceSide::CLIENT, 0);
+      return;
+    }
+  }
+  NOTREACHED();
+}
+
+DVC_RtpEncoding CodecToRtpEncoding(const mojom::AudioCodec& codec) {
+  if (codec.encoding == mojom::RTPEncoding::DVC2)
+    return DVC_RTP_ENCODING_DVC2;
+  if (codec.encoding == mojom::RTPEncoding::PCMU)
+    return DVC_RTP_ENCODING_PCMU;
+  if (codec.encoding == mojom::RTPEncoding::PCMA)
+    return DVC_RTP_ENCODING_PCMA;
+  if (codec.encoding == mojom::RTPEncoding::G722)
+    return DVC_RTP_ENCODING_G722;
+
+  return static_cast<DVC_RtpEncoding>(-1);
+}
+
+std::string CodecIdToName(DVC_RtpEncoding id) {
+  switch (id) {
+    case DVC_RTP_ENCODING_DVC2:
+      return getDolbyValueOr(switches::kDvcCodecName,
+                             webrtc_integration::DVC_CODEC_NAME);
+    case DVC_RTP_ENCODING_PCMA:
+      return "PCMA";
+    case DVC_RTP_ENCODING_PCMU:
+      return "PCMU";
+    case DVC_RTP_ENCODING_G722:
+      return "G722";
+    case DVC_RTP_ENCODING_TELEPHONE_EVENT:
+      return "TELEPHONE_EVENT";
+  }
+  NOTREACHED();
+  return "";
+}
+
+}  // namespace dolby_voice_client
diff --git a/dolby/services/dolby_voice_client/dvc_library_helpers.h b/dolby/services/dolby_voice_client/dvc_library_helpers.h
new file mode 100644
index 00000000000..ea7edecbdb4
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_library_helpers.h
@@ -0,0 +1,62 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef SERVICES_DOLBY_VOICE_CLIENT_DVC_LIBRARY_HELPERS_H_
+#define SERVICES_DOLBY_VOICE_CLIENT_DVC_LIBRARY_HELPERS_H_
+
+#include <functional>
+#include <memory>
+#include <vector>
+
+#include "base/threading/simple_thread.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dvc_conference_types.mojom.h"
+
+#include <dvclient.h>
+
+namespace dolby_voice_client {
+
+class GenericNotify {
+ public:
+  virtual ~GenericNotify();
+  virtual DVC_EventHandle GetEventHandle() const = 0;
+  virtual void Notify() = 0;
+  virtual void ClearNotify() = 0;
+  static std::unique_ptr<GenericNotify> Make();
+};
+
+struct RtpCommunicationParamsWrapper {
+  bool SetFromMojo(const mojom::AudioCodec& codec);
+
+  DVC_RtpCommunicationConfig params;
+  DVC_ProtocolConfig protocol;
+  DVC_Dvc2CodecParameters dvc2_params;
+};
+
+class DoCallbacksRunnable : public base::SimpleThread {
+ public:
+  using EventWithCallback =
+      std::tuple<DVC_EventHandle, std::function<void()>>;
+  explicit DoCallbacksRunnable(DVC_EventHandle exit_notify,
+                               const std::vector<EventWithCallback>& events);
+  ~DoCallbacksRunnable() override;
+  void Run() override;
+
+ private:
+  bool HandleEvents();
+
+  std::vector<EventWithCallback> events_;
+  bool exit_;
+};
+
+std::string LogLevelToString(DVC_LogLevel level);
+mojom::RTPEncoding CodecConfigRtpEncoding(const DVC_CodecConfig& config);
+std::string CodecIdToName(DVC_RtpEncoding id);
+int CodecConfigPayloadType(const DVC_CodecConfig& config);
+void TranslateDVCCLCodec(const DVC_CodecConfig& config,
+                         std::vector<mojom::AudioCodec>& codecs);
+DVC_RtpEncoding CodecToRtpEncoding(const mojom::AudioCodec& codec);
+
+}  // namespace dolby_voice_client
+
+#endif  // SERVICES_DOLBY_VOICE_CLIENT_DVC_LIBRARY_HELPERS_H_
diff --git a/dolby/services/dolby_voice_client/dvc_state_dump.cc b/dolby/services/dolby_voice_client/dvc_state_dump.cc
new file mode 100644
index 00000000000..4ae4d331de3
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_state_dump.cc
@@ -0,0 +1,57 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc_state_dump.h"
+
+#include <fstream>
+
+#include "logging.h"
+#include "vars.h"
+
+using namespace base;
+using namespace dolby_voice_client;
+using namespace std;
+
+namespace
+{
+auto writeBinaryFile(string path, const char* data, streamsize count)
+{
+  ofstream file{path, ios::binary | ios::trunc};
+  return file and file.write(data, count).good();
+}
+}
+
+StateDump::StateDump(DVC_Handle handle) : error(DVC_CreateStateDump(handle, &state_dump))
+{
+  if (not error)
+  {
+    writeToFile();
+  }
+  else
+  {
+    DVEF_ERROR_LOG << "DVC_CreateStateDump failed: " << DVC_ErrorToString(error);
+  }
+}
+
+StateDump::~StateDump()
+{
+  if ((error = DVC_DeleteStateDump(&state_dump)))
+  {
+    DVEF_ERROR_LOG << "DVC_DeleteStateDump failed: " << DVC_ErrorToString(error);
+  }
+}
+
+void StateDump::writeToFile() const
+{
+  auto path = getDolbyValueOr(switches::kDvcStateDumpPath, "");
+  if (path.empty())
+  {
+    path = timestamped("dvc_dump.zip");
+  }
+  writeBinaryFile(path,
+                  static_cast<const char*>(state_dump.data),
+                  state_dump.size) ?
+    DVEF_LOG << "State dump written to file " << path :
+    DVEF_ERROR_LOG << "Could not write state dump to file " << path;
+}
diff --git a/dolby/services/dolby_voice_client/dvc_state_dump.h b/dolby/services/dolby_voice_client/dvc_state_dump.h
new file mode 100644
index 00000000000..92b9b499ab3
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_state_dump.h
@@ -0,0 +1,23 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#pragma once
+
+#include <dvclient.h>
+
+namespace dolby_voice_client
+{
+class StateDump
+{
+public:
+  StateDump(DVC_Handle);
+  ~StateDump();
+
+private:
+  void writeToFile() const;
+
+  DVC_ZippedStateDump state_dump;
+  DVC_Error error;
+};
+}
diff --git a/dolby/services/dolby_voice_client/dvc_utils.cc b/dolby/services/dolby_voice_client/dvc_utils.cc
new file mode 100644
index 00000000000..cdbe4468616
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_utils.cc
@@ -0,0 +1,66 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/services/dolby_voice_client/dvc_utils.h"
+
+#include "logging.h"
+
+namespace dolby_voice_client {
+
+RtpAudio::RtpAudio(const void* data,
+                   unsigned int len,
+                   int64_t capture_timestamp_us) {
+  if (data != nullptr && len > 0) {
+    const auto* char_data = static_cast<const char*>(data);
+    data_.insert(data_.begin(), char_data, char_data + len);
+    created_timestamp_ = base::TimeTicks::Now();
+    if (capture_timestamp_us != -1) {
+      capture_timestamp_ =
+          base::TimeTicks::FromInternalValue(capture_timestamp_us);
+    } else {
+      capture_timestamp_ = created_timestamp_;
+    }
+  }
+}
+
+RtpAudio::~RtpAudio() = default;
+
+namespace {
+constexpr base::WaitableEvent::ResetPolicy kResetPolicy =
+    base::WaitableEvent::ResetPolicy::MANUAL;
+
+constexpr base::WaitableEvent::InitialState kInitialState =
+    base::WaitableEvent::InitialState::NOT_SIGNALED;
+}  // namespace
+
+ScopedTimeMeasurementMs::ScopedTimeMeasurementMs(std::string measurement_name)
+    : measurement_name_(measurement_name) {
+  start_time_ = base::TimeTicks::Now();
+}
+
+ScopedTimeMeasurementMs::~ScopedTimeMeasurementMs() {
+  base::TimeDelta delta = base::TimeTicks::Now() - start_time_;
+  DVEF_LOG << "ScopedTimeMeasurementMs: " << measurement_name_
+              << ", value: " << delta.InMilliseconds() << " ms";
+}
+
+ScopedCompletionEvent::ScopedCompletionEvent()
+    : event_(kResetPolicy, kInitialState) {
+  static_assert(kResetPolicy == base::WaitableEvent::ResetPolicy::MANUAL,
+                "The reset policy must be set to MANUAL");
+  static_assert(
+      kInitialState == base::WaitableEvent::InitialState::NOT_SIGNALED,
+      "The initial state must be set to NOT_SIGNALED");
+}
+
+ScopedCompletionEvent::~ScopedCompletionEvent() {
+  if (!event_.IsSignaled())
+    event_.Wait();
+}
+
+void ScopedCompletionEvent::SignalCompleted() {
+  event_.Signal();
+}
+
+}  // namespace dolby_voice_client
diff --git a/dolby/services/dolby_voice_client/dvc_utils.h b/dolby/services/dolby_voice_client/dvc_utils.h
new file mode 100644
index 00000000000..a180def35c6
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvc_utils.h
@@ -0,0 +1,58 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef SERVICES_DOLBY_VOICE_CLIENT_DVC_UTILS_H_
+#define SERVICES_DOLBY_VOICE_CLIENT_DVC_UTILS_H_
+
+#include "base/logging.h"
+#include "base/single_thread_task_runner.h"
+#include "base/synchronization/waitable_event.h"
+#include "base/time/time.h"
+
+namespace dolby_voice_client {
+
+class RtpAudio {
+ public:
+  RtpAudio(const void* data,
+           unsigned int len,
+           int64_t capture_timestamp_us = -1);
+  virtual ~RtpAudio();
+
+  const char* Data() { return data_.data(); }
+  size_t Len() { return data_.size(); }
+  base::TimeTicks TimeStamp() { return created_timestamp_; }
+  base::TimeDelta TimeSinceCaptured() {
+    return (created_timestamp_ - capture_timestamp_);
+  }
+
+ protected:
+  std::vector<char> data_;
+  base::TimeTicks created_timestamp_;
+  base::TimeTicks capture_timestamp_;
+};
+
+class ScopedTimeMeasurementMs {
+ public:
+  ScopedTimeMeasurementMs(std::string measurement_name);
+  virtual ~ScopedTimeMeasurementMs();
+
+ protected:
+  std::string measurement_name_;
+  base::TimeTicks start_time_;
+};
+
+class ScopedCompletionEvent final {
+ public:
+  ScopedCompletionEvent();
+  ~ScopedCompletionEvent();
+
+  void SignalCompleted();
+
+ private:
+  base::WaitableEvent event_;
+};
+
+}  // namespace dolby_voice_client
+
+#endif  // SERVICES_DOLBY_VOICE_CLIENT_DVC_UTILS_H_
diff --git a/dolby/services/dolby_voice_client/dvmc.gni b/dolby/services/dolby_voice_client/dvmc.gni
new file mode 100644
index 00000000000..aadee347d02
--- /dev/null
+++ b/dolby/services/dolby_voice_client/dvmc.gni
@@ -0,0 +1,30 @@
+# Copyright 2020 Dolby Laboratories and Dolby International AB
+# Use of this source code is governed by the MIT license that can be
+# found in the dolby/LICENSE file.
+
+# Dolby Voice Client SDK defines
+
+declare_args() {
+  dvmc_sdk_root = ""
+}
+
+assert (dvmc_sdk_root != "",
+        "You must pass dvmc_sdk_root variable, " +
+        "stating where is the DVMC SDK unpacked")
+
+dvc_lib_dirs = []
+dvc_libs = []
+dvc_includes = []
+
+if (is_mac) {
+  dvc_lib_dirs = [dvmc_sdk_root + "/client/lib/macos"]
+  dvc_libs = ["dvclient"]
+} else if (is_win) {
+  dvc_lib_dirs = [dvmc_sdk_root + "/client/lib/windows/win64"]
+  dvc_libs = ["dvclient.lib"]
+} else if (is_linux) {
+  dvc_lib_dirs += [ dvmc_sdk_root + "/client/lib/linux/amd64" ]
+  dvc_libs += ["dvclient"]
+}
+
+dvc_includes = [dvmc_sdk_root + "/client/include"]
diff --git a/dolby/services/dolby_voice_client/logging.cc b/dolby/services/dolby_voice_client/logging.cc
new file mode 100644
index 00000000000..c963fcbfd51
--- /dev/null
+++ b/dolby/services/dolby_voice_client/logging.cc
@@ -0,0 +1,63 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "logging.h"
+
+#include <iomanip>
+
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/path_service.h"
+#include "base/time/time.h"
+#include "vars.h"
+
+using namespace base;
+using namespace std;
+
+namespace
+{
+auto getExecutableFolder()
+{
+    FilePath log_filename;
+    PathService::Get(DIR_EXE, &log_filename);
+#ifdef __APPLE__
+    log_filename = log_filename.AppendASCII("../../../../../..");
+#endif
+    return log_filename;
+}
+
+auto createLogFolder()
+{
+    const auto log_folder = getExecutableFolder().AppendASCII("dvc_logs");
+    CreateDirectory(log_folder);
+    return log_folder;
+}
+}
+
+string timestamped(string file)
+{
+    static const auto log_folder = createLogFolder();
+    Time::Exploded now;
+    Time::Now().LocalExplode(&now);
+    ostringstream ret;
+    ret << log_folder.value()
+        << "/"
+        << now.year << "-"
+        << setfill('0')
+        << setw(2) << now.month << "-"
+        << setw(2) << now.day_of_month << "_"
+        << setw(2) << now.hour << "-"
+        << setw(2) << now.minute << "-"
+        << setw(2) << now.second << "_"
+        << file;
+    return ret.str();
+}
+
+void logToFileIfRequested()
+{
+    if (getDolbyValueOr(switches::kDvcLogToFile, 0))
+    {
+        (void)freopen(timestamped("electron.log").c_str(), "w", stderr);
+    }
+}
diff --git a/dolby/services/dolby_voice_client/logging.h b/dolby/services/dolby_voice_client/logging.h
new file mode 100644
index 00000000000..607cc0f4c1f
--- /dev/null
+++ b/dolby/services/dolby_voice_client/logging.h
@@ -0,0 +1,15 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#pragma once
+
+#include "base/logging.h"
+
+#define DVEF_LOG_BASE(Level) LOG(Level) << "### DVEF ### [" << __func__ << "] "
+#define DVEF_LOG DVEF_LOG_BASE(INFO)
+#define DVEF_WARN_LOG DVEF_LOG_BASE(WARNING)
+#define DVEF_ERROR_LOG DVEF_LOG_BASE(ERROR)
+
+std::string timestamped(std::string);
+void logToFileIfRequested();
diff --git a/dolby/services/dolby_voice_client/public/cpp/BUILD.gn b/dolby/services/dolby_voice_client/public/cpp/BUILD.gn
new file mode 100644
index 00000000000..e177f4c6e49
--- /dev/null
+++ b/dolby/services/dolby_voice_client/public/cpp/BUILD.gn
@@ -0,0 +1,30 @@
+# Copyright 2020 Dolby Laboratories and Dolby International AB
+# Use of this source code is governed by the MIT license that can be
+# found in the dolby/LICENSE file.
+
+source_set("cpp") {
+  sources = [
+  ]
+
+  public_deps = [
+    "//base",
+    "//services/service_manager/public/cpp",
+    "//dolby/services/dolby_voice_client/public/mojom",
+  ]
+
+  deps = [
+    "//mojo/public/cpp/bindings:bindings",
+  ]
+}
+
+source_set("manifest") {
+  sources = [
+    "manifest.cc",
+    "manifest.h",
+  ]
+  deps = [
+    "//base",
+    "//dolby/services/dolby_voice_client/public/mojom",
+    "//services/service_manager/public/cpp",
+  ]
+}
\ No newline at end of file
diff --git a/dolby/services/dolby_voice_client/public/cpp/manifest.cc b/dolby/services/dolby_voice_client/public/cpp/manifest.cc
new file mode 100644
index 00000000000..09d832c4924
--- /dev/null
+++ b/dolby/services/dolby_voice_client/public/cpp/manifest.cc
@@ -0,0 +1,38 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/services/dolby_voice_client/public/cpp/manifest.h"
+
+#include "base/no_destructor.h"
+#include "content/public/common/service_names.mojom.h"
+#include "dolby/services/dolby_voice_client/public/mojom/constants.mojom.h"
+#include "services/service_manager/public/cpp/manifest_builder.h"
+
+namespace content {
+
+const service_manager::Manifest& GetDolbyVoiceClientManifest() {
+  static base::NoDestructor<service_manager::Manifest> manifest{
+      service_manager::ManifestBuilder()
+          .WithServiceName(dolby_voice_client::mojom::kServiceName)
+          .WithDisplayName("Dolby Voice Client")
+          .WithOptions(service_manager::ManifestOptionsBuilder()
+                           .WithExecutionMode(
+                               service_manager::Manifest::ExecutionMode::
+                                   kOutOfProcessBuiltin)
+                           .WithSandboxType("none")
+                           .WithInstanceSharingPolicy(
+                               service_manager::Manifest::
+                                   InstanceSharingPolicy::kSharedAcrossGroups)
+                           .Build())
+          .ExposeCapability("dolby_voice_client",
+                            std::set<const char*>{
+                                "dolby_voice_client.mojom.DolbyVoiceClientProvider",
+                                "dolby_voice_client.mojom.TestingControls",
+                            })
+          .RequireCapability("service_manager", "service_manager:service_manager")
+          .Build()};
+  return *manifest;
+}
+
+}  // namespace content
diff --git a/dolby/services/dolby_voice_client/public/cpp/manifest.h b/dolby/services/dolby_voice_client/public/cpp/manifest.h
new file mode 100644
index 00000000000..c811a651e29
--- /dev/null
+++ b/dolby/services/dolby_voice_client/public/cpp/manifest.h
@@ -0,0 +1,17 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef DOLBY_SERVICES_DOLBY_VOICE_CLIENT_SERVICE_MANIFEST_H_
+#define DOLBY_SERVICES_DOLBY_VOICE_CLIENT_SERVICE_MANIFEST_H_
+
+
+#include "services/service_manager/public/cpp/manifest.h"
+
+namespace content {
+
+const service_manager::Manifest& GetDolbyVoiceClientManifest();
+
+}  // namespace content
+
+#endif  // DOLBY_SERVICES_DOLBY_VOICE_CLIENT_SERVICE_MANIFEST_H_
diff --git a/dolby/services/dolby_voice_client/public/mojom/BUILD.gn b/dolby/services/dolby_voice_client/public/mojom/BUILD.gn
new file mode 100644
index 00000000000..1c7e723c77a
--- /dev/null
+++ b/dolby/services/dolby_voice_client/public/mojom/BUILD.gn
@@ -0,0 +1,27 @@
+# Copyright 2020 Dolby Laboratories and Dolby International AB
+# Use of this source code is governed by the MIT license that can be
+# found in the dolby/LICENSE file.
+
+import("//mojo/public/tools/bindings/mojom.gni")
+
+mojom("mojom") {
+  sources = [
+    "dvc_conference_types.mojom",
+    "dvc_conference.mojom",
+    "dvc_conference_factory.mojom",
+    "dvc_device_manager.mojom",
+    "dolby_voice_client_provider.mojom",
+    "testing_controls.mojom",
+  ]
+
+  public_deps = [
+    ":constants",
+    "//mojo/public/mojom/base",
+  ]
+}
+
+mojom("constants") {
+  sources = [
+    "constants.mojom",
+  ]
+}
diff --git a/dolby/services/dolby_voice_client/public/mojom/constants.mojom b/dolby/services/dolby_voice_client/public/mojom/constants.mojom
new file mode 100644
index 00000000000..8a554d3bbab
--- /dev/null
+++ b/dolby/services/dolby_voice_client/public/mojom/constants.mojom
@@ -0,0 +1,7 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+module dolby_voice_client.mojom;
+
+const string kServiceName = "dolby_voice_client";
diff --git a/dolby/services/dolby_voice_client/public/mojom/dolby_voice_client_provider.mojom b/dolby/services/dolby_voice_client/public/mojom/dolby_voice_client_provider.mojom
new file mode 100644
index 00000000000..1c6acc98acf
--- /dev/null
+++ b/dolby/services/dolby_voice_client/public/mojom/dolby_voice_client_provider.mojom
@@ -0,0 +1,13 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+module dolby_voice_client.mojom;
+
+import "dolby/services/dolby_voice_client/public/mojom/dvc_conference_factory.mojom";
+import "dolby/services/dolby_voice_client/public/mojom/dvc_device_manager.mojom";
+
+interface DolbyVoiceClientProvider {
+  ConnectToConferenceFactory(DvcConferenceFactory& request);
+  ConnectToDeviceManager(DvcDeviceManager& request);
+};
diff --git a/dolby/services/dolby_voice_client/public/mojom/dvc_conference.mojom b/dolby/services/dolby_voice_client/public/mojom/dvc_conference.mojom
new file mode 100644
index 00000000000..d8218751a03
--- /dev/null
+++ b/dolby/services/dolby_voice_client/public/mojom/dvc_conference.mojom
@@ -0,0 +1,21 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+module dolby_voice_client.mojom;
+
+import "dolby/services/dolby_voice_client/public/mojom/dvc_conference_types.mojom";
+
+interface DvcConferenceRtpSink {
+  SendRtp(array<uint8> data, int64 timestamp_us);
+};
+
+interface DvcConference {
+  Update(AudioCodec codec) => (bool status, string error_message);
+  Stop();
+  HandleReceivedRtpPacket(array<uint8> data);
+  GetAudioSessionStats() => (Stats stats);
+  SetMinimumPlayoutDelay(int32 delay_ms);
+  SetMute(bool mute);
+  SetRtpSink(DvcConferenceRtpSink sink);
+};
diff --git a/dolby/services/dolby_voice_client/public/mojom/dvc_conference_factory.mojom b/dolby/services/dolby_voice_client/public/mojom/dvc_conference_factory.mojom
new file mode 100644
index 00000000000..f4925bd21e1
--- /dev/null
+++ b/dolby/services/dolby_voice_client/public/mojom/dvc_conference_factory.mojom
@@ -0,0 +1,13 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+module dolby_voice_client.mojom;
+
+import "dolby/services/dolby_voice_client/public/mojom/dvc_conference_types.mojom";
+import "dolby/services/dolby_voice_client/public/mojom/dvc_conference.mojom";
+
+interface DvcConferenceFactory {
+  GetAudioCodecsList() => (array<AudioCodec> codecs);
+  CreateConference(DvcConference& request);
+};
diff --git a/dolby/services/dolby_voice_client/public/mojom/dvc_conference_types.mojom b/dolby/services/dolby_voice_client/public/mojom/dvc_conference_types.mojom
new file mode 100644
index 00000000000..9f70176830a
--- /dev/null
+++ b/dolby/services/dolby_voice_client/public/mojom/dvc_conference_types.mojom
@@ -0,0 +1,52 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+module dolby_voice_client.mojom;
+
+enum RTPEncoding {
+  DVC2,
+  PCMU,
+  PCMA,
+  G722,
+  TELEPHONE_EVENT
+};
+
+enum DVC2SourceSide {
+  CLIENT,
+  SERVER
+};
+
+struct AudioCodec {
+  RTPEncoding encoding;
+  uint32 clock_rate;
+  uint32 rtp_payload_type;
+
+  bool has_dvc2_params;
+  DVC2SourceSide dvc2_source_side;
+  uint32 dvc2_protocol_version;
+};
+
+struct Stats {
+  string codec_name;
+  int32 in_jitter;
+  int32 in_jitter_buffer_ms;
+  double in_packet_loss_fraction;
+  uint64 in_packets_total;
+  uint64 in_conceals_total;
+  double in_voice_level;
+
+  int32 out_jitter;
+  int32 out_jitter_buffer_ms;
+  double out_packet_loss_fraction;
+  uint64 out_packets_total;
+  uint64 out_fec_action_counter;
+
+  double transmit_level;
+  int32 avg_rtt_to_as;
+
+  int32 echo_delay_ms;
+
+  double total_output_energy;
+  double total_input_energy;
+};
diff --git a/dolby/services/dolby_voice_client/public/mojom/dvc_device_manager.mojom b/dolby/services/dolby_voice_client/public/mojom/dvc_device_manager.mojom
new file mode 100644
index 00000000000..86fb250b944
--- /dev/null
+++ b/dolby/services/dolby_voice_client/public/mojom/dvc_device_manager.mojom
@@ -0,0 +1,10 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+module dolby_voice_client.mojom;
+
+interface DvcDeviceManager {
+  SetPreferredInputDevice(array<int8> native_device_id);
+  SetPreferredOutputDevice(array<int8> native_device_id);
+};
diff --git a/dolby/services/dolby_voice_client/public/mojom/testing_controls.mojom b/dolby/services/dolby_voice_client/public/mojom/testing_controls.mojom
new file mode 100644
index 00000000000..86c265b2580
--- /dev/null
+++ b/dolby/services/dolby_voice_client/public/mojom/testing_controls.mojom
@@ -0,0 +1,11 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+module dolby_voice_client.mojom;
+
+// APIs for allowing tests to control service behavior for the purpose of
+// integration testing.
+interface TestingControls {
+  Crash();
+};
diff --git a/dolby/services/dolby_voice_client/service_impl.cc b/dolby/services/dolby_voice_client/service_impl.cc
new file mode 100644
index 00000000000..d371966767f
--- /dev/null
+++ b/dolby/services/dolby_voice_client/service_impl.cc
@@ -0,0 +1,111 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/services/dolby_voice_client/service_impl.h"
+
+#include "mojo/public/cpp/bindings/strong_binding.h"
+#include "dolby/services/dolby_voice_client/dolby_voice_client_provider_impl.h"
+#include "dolby/services/dolby_voice_client/public/mojom/constants.mojom.h"
+#include "dolby/services/dolby_voice_client/testing_controls_impl.h"
+
+namespace dolby_voice_client {
+
+ServiceImpl::ServiceImpl(
+    mojo::PendingReceiver<service_manager::mojom::Service> receiver)
+    : service_binding_(this, std::move(receiver)),
+      keepalive_(&service_binding_, base::TimeDelta::FromSeconds(5)),
+      weak_factory_(this) {
+}
+
+ServiceImpl::~ServiceImpl() {
+  DCHECK(thread_checker_.CalledOnValidThread());
+}
+
+// static
+std::unique_ptr<service_manager::Service> ServiceImpl::Create(
+    mojo::PendingReceiver<service_manager::mojom::Service> receiver) {
+  return std::make_unique<ServiceImpl>(std::move(receiver));
+}
+
+void ServiceImpl::OnStart() {
+  DCHECK(thread_checker_.CalledOnValidThread());
+
+  keepalive_.AddObserver(this);
+
+  registry_.AddInterface<mojom::DolbyVoiceClientProvider>(
+      // Unretained |this| is safe because |registry_| is owned by |this|.
+      base::Bind(&ServiceImpl::OnDolbyVoiceClientProviderRequest,
+                 base::Unretained(this)));
+  registry_.AddInterface<mojom::TestingControls>(
+      // Unretained |this| is safe because |registry_| is owned by |this|.
+      base::Bind(&ServiceImpl::OnTestingControlsRequest,
+                 base::Unretained(this)));
+
+  dvc_provider_bindings_.set_connection_error_handler(base::BindRepeating(
+      &ServiceImpl::OnProviderClientDisconnected, base::Unretained(this)));
+}
+
+void ServiceImpl::OnBindInterface(
+    const service_manager::BindSourceInfo& source_info,
+    const std::string& interface_name,
+    mojo::ScopedMessagePipeHandle interface_pipe) {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  registry_.BindInterface(interface_name, std::move(interface_pipe));
+}
+
+bool ServiceImpl::OnServiceManagerConnectionLost() {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  return true;
+}
+
+void ServiceImpl::SetDolbyVoiceClientProviderClientDisconnectedObserver(
+    const base::RepeatingClosure& observer_cb) {
+  dvc_provider_client_disconnected_cb_ = observer_cb;
+}
+
+void ServiceImpl::OnDolbyVoiceClientProviderRequest(
+    mojom::DolbyVoiceClientProviderRequest request) {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  LazyInitializeDolbyVoiceClientProvider();
+  dvc_provider_bindings_.AddBinding(dvc_provider_.get(), std::move(request));
+}
+
+void ServiceImpl::OnTestingControlsRequest(
+    mojom::TestingControlsRequest request) {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  mojo::MakeStrongBinding(
+      std::make_unique<TestingControlsImpl>(keepalive_.CreateRef()),
+      std::move(request));
+}
+
+void ServiceImpl::OnIdleTimeout() {
+  MaybeRequestQuit();
+}
+
+void ServiceImpl::MaybeRequestQuit() {
+  DCHECK(thread_checker_.CalledOnValidThread());
+  if (keepalive_.HasNoRefs()) {
+    service_binding_.RequestClose();
+  }
+}
+
+void ServiceImpl::LazyInitializeDolbyVoiceClientProvider() {
+  if (dvc_provider_)
+    return;
+  dvc_provider_ =
+      std::make_unique<DolbyVoiceClientProviderImpl>(keepalive_.CreateRef());
+}
+
+void ServiceImpl::OnProviderClientDisconnected() {
+  // Reset factory provider if no client is connected.
+  if (dvc_provider_bindings_.empty()) {
+    dvc_provider_.reset();
+  }
+
+  if (!dvc_provider_client_disconnected_cb_.is_null()) {
+    dvc_provider_client_disconnected_cb_.Run();
+  }
+}
+
+}  // namespace dolby_voice_client
diff --git a/dolby/services/dolby_voice_client/service_impl.h b/dolby/services/dolby_voice_client/service_impl.h
new file mode 100644
index 00000000000..88d717f3e39
--- /dev/null
+++ b/dolby/services/dolby_voice_client/service_impl.h
@@ -0,0 +1,68 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef SERVICES_DOLBY_VOICE_CLIENT_SERVICE_IMPL_H_
+#define SERVICES_DOLBY_VOICE_CLIENT_SERVICE_IMPL_H_
+
+#include <memory>
+
+#include "base/threading/thread_checker.h"
+#include "mojo/public/cpp/bindings/binding_set.h"
+#include "services/service_manager/public/cpp/binder_registry.h"
+#include "services/service_manager/public/cpp/service.h"
+#include "services/service_manager/public/cpp/service_binding.h"
+#include "services/service_manager/public/cpp/service_keepalive.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dolby_voice_client_provider.mojom.h"
+#include "dolby/services/dolby_voice_client/public/mojom/testing_controls.mojom.h"
+#include "dolby/services/dolby_voice_client/public/mojom/constants.mojom.h"
+
+namespace dolby_voice_client {
+
+class ServiceImpl : public service_manager::Service,
+                    public service_manager::ServiceKeepalive::Observer {
+ public:
+  ServiceImpl(mojo::PendingReceiver<service_manager::mojom::Service> receiver);
+  ~ServiceImpl() override;
+
+  static std::unique_ptr<service_manager::Service> Create(
+      mojo::PendingReceiver<service_manager::mojom::Service> receiver);
+
+  // service_manager::Service implementation.
+  void OnStart() override;
+  void OnBindInterface(const service_manager::BindSourceInfo& source_info,
+                       const std::string& interface_name,
+                       mojo::ScopedMessagePipeHandle interface_pipe) override;
+  bool OnServiceManagerConnectionLost() override;
+
+  void SetDolbyVoiceClientProviderClientDisconnectedObserver(
+      const base::RepeatingClosure& observer_cb);
+
+ private:
+  void OnDolbyVoiceClientProviderRequest(
+      mojom::DolbyVoiceClientProviderRequest request);
+  void OnTestingControlsRequest(mojom::TestingControlsRequest request);
+  void OnIdleTimeout() override;
+  void MaybeRequestQuit();
+  void LazyInitializeDolbyVoiceClientProvider();
+  void OnProviderClientDisconnected();
+
+  service_manager::ServiceBinding service_binding_;
+  service_manager::ServiceKeepalive keepalive_;
+
+  service_manager::BinderRegistry registry_;
+  mojo::BindingSet<mojom::DolbyVoiceClientProvider> dvc_provider_bindings_;
+  std::unique_ptr<mojom::DolbyVoiceClientProvider> dvc_provider_;
+
+  // Callback to be invoked when a provider client is disconnected. Mainly used
+  // for testing.
+  base::RepeatingClosure dvc_provider_client_disconnected_cb_;
+  base::ThreadChecker thread_checker_;
+  base::WeakPtrFactory<ServiceImpl> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(ServiceImpl);
+};
+
+}  // namespace dolby_voice_client
+
+#endif  // SERVICES_DOLBY_VOICE_CLIENT_SERVICE_IMPL_H_
diff --git a/dolby/services/dolby_voice_client/switches.cc b/dolby/services/dolby_voice_client/switches.cc
new file mode 100644
index 00000000000..30174378a20
--- /dev/null
+++ b/dolby/services/dolby_voice_client/switches.cc
@@ -0,0 +1,23 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/services/dolby_voice_client/switches.h"
+#include "base/command_line.h"
+#include "base/stl_util.h"
+
+using namespace base;
+using namespace switches;
+
+void copyDvcSwitches(const CommandLine& src, CommandLine& dest)
+{
+    decltype(kDvcCodecName) dvc_switches[] =
+    {
+        kDvcCodecName,
+        kDvcPayloadType,
+        kDvcAudioLoggingLength,
+        kDvcStateDumpPath,
+        kDvcLogToFile
+    };
+    dest.CopySwitchesFrom(src, dvc_switches, size(dvc_switches));
+}
diff --git a/dolby/services/dolby_voice_client/switches.h b/dolby/services/dolby_voice_client/switches.h
new file mode 100644
index 00000000000..26f0f84e611
--- /dev/null
+++ b/dolby/services/dolby_voice_client/switches.h
@@ -0,0 +1,21 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#pragma once
+
+namespace base
+{
+    class CommandLine;
+}
+
+namespace switches
+{
+    constexpr auto* kDvcCodecName = "dvc_codec_name";
+    constexpr auto* kDvcPayloadType = "dvc_payload_type";
+    constexpr auto* kDvcAudioLoggingLength = "dvc_audio_logging_length";
+    constexpr auto* kDvcStateDumpPath = "dvc_state_dump_path";
+    constexpr auto* kDvcLogToFile = "dvc_log_to_file";
+}
+
+void copyDvcSwitches(const base::CommandLine& src, base::CommandLine& dest);
diff --git a/dolby/services/dolby_voice_client/test/dolby_voice_client_provider_connectortest.cc b/dolby/services/dolby_voice_client/test/dolby_voice_client_provider_connectortest.cc
new file mode 100644
index 00000000000..d7612238429
--- /dev/null
+++ b/dolby/services/dolby_voice_client/test/dolby_voice_client_provider_connectortest.cc
@@ -0,0 +1,91 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "base/run_loop.h"
+#include "base/test/mock_callback.h"
+#include "base/test/scoped_task_environment.h"
+#include "dolby/services/dolby_voice_client/public/mojom/constants.mojom.h"
+#include "dolby/services/dolby_voice_client/public/mojom/dolby_voice_client_provider.mojom.h"
+#include "dolby/services/dolby_voice_client/service_impl.h"
+#include "services/service_manager/public/cpp/test/test_connector_factory.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace dolby_voice_client {
+
+class MockRtpSink : public mojom::DvcConferenceRtpSink {
+ public:
+  ~MockRtpSink() override {}
+
+  void SendRtp(mojo::ScopedSharedBufferHandle data,
+               uint64_t offset,
+               uint64_t size,
+               int64_t system_time_us) override {}
+};
+
+using testing::Exactly;
+using testing::_;
+using testing::Invoke;
+using testing::InvokeWithoutArgs;
+
+// Test fixture that creates a dolby_voice_client::ServiceImpl and sets up a
+// local service_manager::Connector through which client code can connect to
+// it.
+class DolbyVoiceClientProviderConnectorTest : public ::testing::Test {
+ public:
+  DolbyVoiceClientProviderConnectorTest() {}
+  ~DolbyVoiceClientProviderConnectorTest() override {}
+
+  void SetUp() override {
+    std::unique_ptr<ServiceImpl> service_impl = std::make_unique<ServiceImpl>();
+    service_impl_ = service_impl.get();
+    connector_factory_ =
+        service_manager::TestConnectorFactory::CreateForUniqueService(
+            std::move(service_impl));
+    connector_ = connector_factory_->CreateConnector();
+    connector_->BindInterface(mojom::kServiceName,
+                              &dolby_voice_client_provider_);
+    dolby_voice_client_provider_->ConnectToConferenceFactory(
+        mojo::MakeRequest(&conference_factory_));
+    dolby_voice_client_provider_->ConnectToDeviceManager(
+        mojo::MakeRequest(&devide_manager_));
+  }
+
+ protected:
+  ServiceImpl* service_impl_;
+  mojom::DolbyVoiceClientProviderPtr dolby_voice_client_provider_;
+  mojom::DvcConferenceFactoryPtr conference_factory_;
+  mojom::DvcDeviceManagerPtr devide_manager_;
+  std::unique_ptr<service_manager::Connector> connector_;
+
+ private:
+  base::test::ScopedTaskEnvironment scoped_task_environment_;
+  std::unique_ptr<service_manager::TestConnectorFactory> connector_factory_;
+};
+
+TEST_F(DolbyVoiceClientProviderConnectorTest,
+       ServiceNotQuitWhenClientConnected) {
+  base::RunLoop wait_loop;
+
+  mojom::DolbyVoiceClientProviderPtr leftover_provider_;
+  connector_->BindInterface(mojom::kServiceName, &leftover_provider_);
+  service_impl_->SetDolbyVoiceClientProviderClientDisconnectedObserver(
+      wait_loop.QuitClosure());
+
+  mojom::DvcConferencePtr conference;
+  conference_factory_->CreateConference(mojo::MakeRequest(&conference));
+
+  conference.reset();
+  devide_manager_.reset();
+  conference_factory_.reset();
+  dolby_voice_client_provider_.reset();
+
+  wait_loop.Run();
+
+  // Verify that the original provider is not bound while the
+  // |leftover_provider| is still bound.
+  EXPECT_FALSE(dolby_voice_client_provider_.is_bound());
+  EXPECT_TRUE(leftover_provider_.is_bound());
+}
+
+}  // namespace dolby_voice_client
diff --git a/dolby/services/dolby_voice_client/test/service_unittest_manifest.json b/dolby/services/dolby_voice_client/test/service_unittest_manifest.json
new file mode 100644
index 00000000000..3c5cce76300
--- /dev/null
+++ b/dolby/services/dolby_voice_client/test/service_unittest_manifest.json
@@ -0,0 +1,12 @@
+{
+  "name": "dolby_voice_client_unittests",
+  "display_name": "Dolby Voice Client Unittests",
+  "interface_provider_specs": {
+    "service_manager:connector": {
+      "requires": {
+        "dolby_voice_client": [ "tests" ],
+        "service_manager": [ "service_manager:service_manager" ]
+      }
+    }
+  }
+}
diff --git a/dolby/services/dolby_voice_client/testing_controls_impl.cc b/dolby/services/dolby_voice_client/testing_controls_impl.cc
new file mode 100644
index 00000000000..222fed18374
--- /dev/null
+++ b/dolby/services/dolby_voice_client/testing_controls_impl.cc
@@ -0,0 +1,19 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/services/dolby_voice_client/testing_controls_impl.h"
+
+namespace dolby_voice_client {
+
+TestingControlsImpl::TestingControlsImpl(
+    std::unique_ptr<service_manager::ServiceContextRef> service_ref)
+    : service_ref_(std::move(service_ref)) {}
+
+TestingControlsImpl::~TestingControlsImpl() = default;
+
+void TestingControlsImpl::Crash() {
+  CHECK(false) << "This is an intentional crash for the purpose of testing";
+}
+
+}  // namespace dolby_voice_client
diff --git a/dolby/services/dolby_voice_client/testing_controls_impl.h b/dolby/services/dolby_voice_client/testing_controls_impl.h
new file mode 100644
index 00000000000..891b55ec583
--- /dev/null
+++ b/dolby/services/dolby_voice_client/testing_controls_impl.h
@@ -0,0 +1,30 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef SERVICES_DOLBY_VOICE_CLIENT_TESTING_CONTROLS_IMPL_H_
+#define SERVICES_DOLBY_VOICE_CLIENT_TESTING_CONTROLS_IMPL_H_
+
+#include "dolby/services/dolby_voice_client/public/mojom/testing_controls.mojom.h"
+#include "services/service_manager/public/cpp/service_context_ref.h"
+
+namespace dolby_voice_client {
+
+class TestingControlsImpl : public mojom::TestingControls {
+ public:
+  TestingControlsImpl(
+      std::unique_ptr<service_manager::ServiceContextRef> service_ref);
+  ~TestingControlsImpl() override;
+
+  // mojom::TestingControls implementation.
+  void Crash() override;
+
+ private:
+  const std::unique_ptr<service_manager::ServiceContextRef> service_ref_;
+
+  DISALLOW_COPY_AND_ASSIGN(TestingControlsImpl);
+};
+
+}  // namespace dolby_voice_client
+
+#endif  // SERVICES_DOLBY_VOICE_CLIENT_TESTING_CONTROLS_IMPL_H_
diff --git a/dolby/services/dolby_voice_client/vars.cc b/dolby/services/dolby_voice_client/vars.cc
new file mode 100644
index 00000000000..99f902f9764
--- /dev/null
+++ b/dolby/services/dolby_voice_client/vars.cc
@@ -0,0 +1,68 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dolby/services/dolby_voice_client/vars.h"
+#include <cstdlib>
+#include <mutex>
+#include <unordered_map>
+#include "base/command_line.h"
+#include "base/optional.h"
+#include "base/strings/string_util.h"
+#include "dolby/services/dolby_voice_client/logging.h"
+
+using namespace base;
+using namespace std;
+
+namespace
+{
+[[maybe_unused]] void printSwitches(const CommandLine& cl)
+{
+    for (const auto& s : cl.GetSwitches())
+        DVEF_LOG << s.first << "=" << s.second;
+}
+
+[[maybe_unused]] void printSwitchesOnce(const CommandLine& cl)
+{
+    static once_flag flag;
+    call_once(flag, printSwitches, cl);
+}
+
+Optional<string> getDolbyVar(const string& var)
+{
+    static unordered_map<string, Optional<string>> vars;
+
+    if (vars.count(var))
+        return vars[var];
+
+    if (const auto* cl = CommandLine::ForCurrentProcess())
+    {
+        const auto val = cl->GetSwitchValueASCII(var);
+        if (not val.empty())
+        {
+            DVEF_LOG << var << " has value \"" << val << "\" based on command line switch";
+            return vars[var] = val;
+        }
+    }
+
+    if (const auto* val = getenv(ToUpperASCII(var).c_str()))
+    {
+        DVEF_LOG << var << " has value \"" << val << "\" based on environment variable";
+        return vars[var] = string{val};
+    }
+
+    DVEF_LOG << var << " is not set";
+    return vars[var] = {};
+}
+}
+
+string getDolbyValueOr(const string& var, const string& def)
+{
+    return getDolbyVar(var).value_or(def);
+}
+
+int getDolbyValueOr(const string& var, int def)
+{
+    const auto val = getDolbyVar(var);
+    return val ? atoi(val->c_str()) : def;
+}
diff --git a/dolby/services/dolby_voice_client/vars.h b/dolby/services/dolby_voice_client/vars.h
new file mode 100644
index 00000000000..2ebfe418b23
--- /dev/null
+++ b/dolby/services/dolby_voice_client/vars.h
@@ -0,0 +1,11 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#pragma once
+
+#include <string>
+#include "dolby/services/dolby_voice_client/switches.h"
+
+std::string getDolbyValueOr(const std::string& var, const std::string& def);
+int getDolbyValueOr(const std::string& var, int def);
diff --git a/dvef_version b/dvef_version
new file mode 100644
index 00000000000..464d0a65d0a
--- /dev/null
+++ b/dvef_version
@@ -0,0 +1 @@
+8.3.4_3.0.1_RTS1
diff --git a/electron/build/args/all.gn b/electron/build/args/all.gn
index 996930c2093..42f04accce4 100644
--- a/electron/build/args/all.gn
+++ b/electron/build/args/all.gn
@@ -20,6 +20,8 @@ v8_enable_snapshot_native_code_counters = false
 enable_cdm_host_verification = false
 proprietary_codecs = true
 ffmpeg_branding = "Chrome"
+enable_av1_decoder = false
+enable_dav1d_decoder = false
 
 enable_basic_printing = true
 angle_enable_vulkan_validation_layers = false
diff --git a/electron/shell/app/electron_main_delegate.cc b/electron/shell/app/electron_main_delegate.cc
index e1182c8fa69..ce7308fb0f0 100644
--- a/electron/shell/app/electron_main_delegate.cc
+++ b/electron/shell/app/electron_main_delegate.cc
@@ -49,6 +49,8 @@
 #endif
 #endif
 
+#include "dolby/services/dolby_voice_client/logging.h"
+
 namespace electron {
 
 namespace {
@@ -170,10 +172,12 @@ bool ElectronMainDelegate::BasicStartupComplete(int* exit_code) {
     logging::SetMinLogLevel(logging::LOG_NUM_SEVERITIES);
   }
 
+  logToFileIfRequested();
+
   logging::InitLogging(settings);
 
-  // Logging with pid and timestamp.
-  logging::SetLogItems(true, false, true, false);
+  // Logging with pid, thread ID and timestamp.
+  logging::SetLogItems(true, true, true, false);
 
   // Enable convient stack printing. This is enabled by default in non-official
   // builds.
diff --git a/media/audio/BUILD.gn b/media/audio/BUILD.gn
index ce01f4cd7c4..47a2bb5d99a 100644
--- a/media/audio/BUILD.gn
+++ b/media/audio/BUILD.gn
@@ -150,6 +150,7 @@ source_set("audio") {
   deps = [
     "//base",
     "//media/base",
+    "//dolby/content/browser:dvc_content_browser",
     "//url",
   ]
   libs = []
diff --git a/media/audio/alsa/audio_manager_alsa.cc b/media/audio/alsa/audio_manager_alsa.cc
index 3f0c60ecee9..24f2185d780 100644
--- a/media/audio/alsa/audio_manager_alsa.cc
+++ b/media/audio/alsa/audio_manager_alsa.cc
@@ -45,7 +45,7 @@ static const char* const kInvalidAudioInputDevices[] = {
 
 AudioManagerAlsa::AudioManagerAlsa(std::unique_ptr<AudioThread> audio_thread,
                                    AudioLogFactory* audio_log_factory)
-    : AudioManagerBase(std::move(audio_thread), audio_log_factory),
+    : AudioManagerBase(std::move(audio_thread), audio_log_factory, nullptr),
       wrapper_(new AlsaWrapper()) {
   SetMaxOutputStreamsAllowed(kMaxOutputStreams);
 }
diff --git a/media/audio/audio_manager.cc b/media/audio/audio_manager.cc
index 97871cd9e30..4d4d30eccf5 100644
--- a/media/audio/audio_manager.cc
+++ b/media/audio/audio_manager.cc
@@ -76,7 +76,8 @@ AudioManagerHelper* GetHelper() {
 // Forward declaration of the platform specific AudioManager factory function.
 std::unique_ptr<AudioManager> CreateAudioManager(
     std::unique_ptr<AudioThread> audio_thread,
-    AudioLogFactory* audio_log_factory);
+    AudioLogFactory* audio_log_factory,
+    dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn);
 
 void AudioManager::SetMaxStreamCountForTesting(int max_input, int max_output) {
   NOTREACHED();
@@ -112,9 +113,10 @@ AudioManager::~AudioManager() {
 // static
 std::unique_ptr<AudioManager> AudioManager::Create(
     std::unique_ptr<AudioThread> audio_thread,
-    AudioLogFactory* audio_log_factory) {
+    AudioLogFactory* audio_log_factory,
+    dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn) {
   std::unique_ptr<AudioManager> manager =
-      CreateAudioManager(std::move(audio_thread), audio_log_factory);
+      CreateAudioManager(std::move(audio_thread), audio_log_factory, dvc_dm_conn);
   manager->InitializeDebugRecording();
   return manager;
 }
@@ -125,7 +127,7 @@ std::unique_ptr<AudioManager> AudioManager::CreateForTesting(
 #if defined(OS_WIN)
   GetHelper()->InitializeCOMForTesting();
 #endif
-  return Create(std::move(audio_thread), GetHelper()->fake_log_factory());
+  return Create(std::move(audio_thread), GetHelper()->fake_log_factory(), nullptr);
 }
 
 #if defined(OS_LINUX)
diff --git a/media/audio/audio_manager.h b/media/audio/audio_manager.h
index 45e48d253bc..8d524bc8440 100644
--- a/media/audio/audio_manager.h
+++ b/media/audio/audio_manager.h
@@ -19,6 +19,8 @@
 #include "media/audio/audio_thread.h"
 #include "media/base/audio_parameters.h"
 
+#include "dolby/content/browser/dvc_device_manager_connection.h"
+
 namespace base {
 class SingleThreadTaskRunner;
 class UnguessableToken;
@@ -54,7 +56,8 @@ class MEDIA_EXPORT AudioManager {
   // |audio_thread->GetTaskRunner()|.
   static std::unique_ptr<AudioManager> Create(
       std::unique_ptr<AudioThread> audio_thread,
-      AudioLogFactory* audio_log_factory);
+      AudioLogFactory* audio_log_factory,
+      dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn);
 
   // A convenience wrapper of AudioManager::Create for testing.
   static std::unique_ptr<AudioManager> CreateForTesting(
diff --git a/media/audio/audio_manager_base.cc b/media/audio/audio_manager_base.cc
index 50c8a873516..03f0a991929 100644
--- a/media/audio/audio_manager_base.cc
+++ b/media/audio/audio_manager_base.cc
@@ -103,15 +103,18 @@ class AudioManagerBase::CompareByParams {
   const DispatcherParams* dispatcher_;
 };
 
-AudioManagerBase::AudioManagerBase(std::unique_ptr<AudioThread> audio_thread,
-                                   AudioLogFactory* audio_log_factory)
+AudioManagerBase::AudioManagerBase(
+    std::unique_ptr<AudioThread> audio_thread,
+    AudioLogFactory* audio_log_factory,
+    dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn)
     : AudioManager(std::move(audio_thread)),
       max_num_output_streams_(kDefaultMaxOutputStreams),
       num_output_streams_(0),
       // TODO(dalecurtis): Switch this to an base::ObserverListThreadSafe, so we
       // don't block the UI thread when swapping devices.
       output_listeners_(base::ObserverListPolicy::EXISTING_ONLY),
-      audio_log_factory_(audio_log_factory) {}
+      audio_log_factory_(audio_log_factory),
+      dvc_device_manager_connection_(dvc_dm_conn) {}
 
 AudioManagerBase::~AudioManagerBase() {
   // All the output streams should have been deleted.
@@ -551,6 +554,11 @@ void AudioManagerBase::CloseAllInputStreams() {
   CHECK(input_streams_.empty());
 }
 
+dolby_voice_client::browser::DvcDeviceManagerConnection*
+AudioManagerBase::GetDvcDeviceManagerConnection() {
+  return dvc_device_manager_connection_;
+}
+
 std::string AudioManagerBase::GetDefaultInputDeviceID() {
   return std::string();
 }
diff --git a/media/audio/audio_manager_base.h b/media/audio/audio_manager_base.h
index 32546d29182..8504def561b 100644
--- a/media/audio/audio_manager_base.h
+++ b/media/audio/audio_manager_base.h
@@ -100,9 +100,14 @@ class MEDIA_EXPORT AudioManagerBase : public AudioManager {
   }
   int output_stream_count() const { return num_output_streams_; }
 
+  dolby_voice_client::browser::DvcDeviceManagerConnection*
+  GetDvcDeviceManagerConnection();
+
  protected:
-  AudioManagerBase(std::unique_ptr<AudioThread> audio_thread,
-                   AudioLogFactory* audio_log_factory);
+  AudioManagerBase(
+      std::unique_ptr<AudioThread> audio_thread,
+      AudioLogFactory* audio_log_factory,
+      dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn);
 
   // AudioManager:
   void ShutdownOnAudioThread() override;
@@ -209,6 +214,9 @@ class MEDIA_EXPORT AudioManagerBase : public AudioManager {
   // Proxy for creating AudioLog objects.
   AudioLogFactory* const audio_log_factory_;
 
+  dolby_voice_client::browser::DvcDeviceManagerConnection*
+      dvc_device_manager_connection_;
+
   // Debug recording manager.
   std::unique_ptr<AudioDebugRecordingManager> debug_recording_manager_;
 
diff --git a/media/audio/fake_audio_manager.cc b/media/audio/fake_audio_manager.cc
index cc6ea938ca0..c8ec03b1159 100644
--- a/media/audio/fake_audio_manager.cc
+++ b/media/audio/fake_audio_manager.cc
@@ -18,7 +18,7 @@ const int kDefaultSampleRate = 48000;
 
 FakeAudioManager::FakeAudioManager(std::unique_ptr<AudioThread> audio_thread,
                                    AudioLogFactory* audio_log_factory)
-    : AudioManagerBase(std::move(audio_thread), audio_log_factory) {}
+    : AudioManagerBase(std::move(audio_thread), audio_log_factory, nullptr) {}
 
 FakeAudioManager::~FakeAudioManager() = default;
 
diff --git a/media/audio/linux/audio_manager_linux.cc b/media/audio/linux/audio_manager_linux.cc
index d112bebbc38..d99ad8a68e7 100644
--- a/media/audio/linux/audio_manager_linux.cc
+++ b/media/audio/linux/audio_manager_linux.cc
@@ -32,7 +32,8 @@ enum LinuxAudioIO {
 
 std::unique_ptr<media::AudioManager> CreateAudioManager(
     std::unique_ptr<AudioThread> audio_thread,
-    AudioLogFactory* audio_log_factory) {
+    AudioLogFactory* audio_log_factory,
+    dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn) {
 #if defined(USE_CRAS)
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kUseCras)) {
     UMA_HISTOGRAM_ENUMERATION("Media.LinuxAudioIO", kCras, kAudioIOMax + 1);
@@ -46,8 +47,9 @@ std::unique_ptr<media::AudioManager> CreateAudioManager(
   pa_context* pa_context = nullptr;
   if (pulse::InitPulse(&pa_mainloop, &pa_context)) {
     UMA_HISTOGRAM_ENUMERATION("Media.LinuxAudioIO", kPulse, kAudioIOMax + 1);
-    return std::make_unique<AudioManagerPulse>(
-        std::move(audio_thread), audio_log_factory, pa_mainloop, pa_context);
+    return std::make_unique<AudioManagerPulse>(std::move(audio_thread),
+                                               audio_log_factory, dvc_dm_conn,
+                                               pa_mainloop, pa_context);
   }
   LOG(WARNING) << "Falling back to ALSA for audio output. PulseAudio is not "
                   "available or could not be initialized.";
diff --git a/media/audio/mac/audio_auhal_mac.cc b/media/audio/mac/audio_auhal_mac.cc
index ba7cdb63d04..20cb7c374f0 100644
--- a/media/audio/mac/audio_auhal_mac.cc
+++ b/media/audio/mac/audio_auhal_mac.cc
@@ -247,8 +247,16 @@ void AUHALStream::Start(AudioSourceCallback* callback) {
   source_ = callback;
 
   OSStatus result = AudioOutputUnitStart(audio_unit_->audio_unit());
-  if (result == noErr)
+  if (result == noErr) {
+    auto* dvc_dm_connection = manager_->GetDvcDeviceManagerConnection();
+    if (dvc_dm_connection != nullptr) {
+      std::vector<int8_t> id;
+      id.resize(sizeof(device_));
+      memcpy(id.data(), &device_, sizeof(device_));
+      dvc_dm_connection->SetPreferredOutputDevice(id);
+    }
     return;
+  }
 
   Stop();
   OSSTATUS_DLOG(ERROR, result) << "AudioOutputUnitStart() failed.";
diff --git a/media/audio/mac/audio_low_latency_input_mac.cc b/media/audio/mac/audio_low_latency_input_mac.cc
index 031aa47edb4..f558c8bab24 100644
--- a/media/audio/mac/audio_low_latency_input_mac.cc
+++ b/media/audio/mac/audio_low_latency_input_mac.cc
@@ -725,6 +725,14 @@ void AUAudioInputStream::Start(AudioInputCallback* callback) {
       base::TimeDelta::FromSeconds(kInputCallbackStartTimeoutInSeconds), this,
       &AUAudioInputStream::CheckInputStartupSuccess);
   DCHECK(input_callback_timer_->IsRunning());
+
+  auto* dvc_dm_connection = manager_->GetDvcDeviceManagerConnection();
+  if (dvc_dm_connection != nullptr) {
+    std::vector<int8_t> id;
+    id.resize(sizeof(input_device_id_));
+    memcpy(id.data(), &input_device_id_, sizeof(input_device_id_));
+    dvc_dm_connection->SetPreferredInputDevice(id);
+  }
 }
 
 void AUAudioInputStream::Stop() {
diff --git a/media/audio/mac/audio_manager_mac.cc b/media/audio/mac/audio_manager_mac.cc
index 3e26c9dd0a2..ff3c7ea3db7 100644
--- a/media/audio/mac/audio_manager_mac.cc
+++ b/media/audio/mac/audio_manager_mac.cc
@@ -503,9 +503,11 @@ class AudioManagerMac::AudioPowerObserver : public base::PowerObserver {
   DISALLOW_COPY_AND_ASSIGN(AudioPowerObserver);
 };
 
-AudioManagerMac::AudioManagerMac(std::unique_ptr<AudioThread> audio_thread,
-                                 AudioLogFactory* audio_log_factory)
-    : AudioManagerBase(std::move(audio_thread), audio_log_factory),
+AudioManagerMac::AudioManagerMac(
+    std::unique_ptr<AudioThread> audio_thread,
+    AudioLogFactory* audio_log_factory,
+    dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn)
+    : AudioManagerBase(std::move(audio_thread), audio_log_factory, dvc_dm_conn),
       current_sample_rate_(0),
       current_output_device_(kAudioDeviceUnknown),
       in_shutdown_(false),
@@ -786,6 +788,7 @@ AudioInputStream* AudioManagerMac::MakeLinearInputStream(
     const LogCallback& log_callback) {
   DCHECK(GetTaskRunner()->BelongsToCurrentThread());
   DCHECK_EQ(AudioParameters::AUDIO_PCM_LINEAR, params.format());
+
   AudioInputStream* stream = new PCMQueueInAudioInputStream(this, params);
   basic_input_streams_.push_back(stream);
   return stream;
@@ -1335,9 +1338,11 @@ void AudioManagerMac::ReleaseInputStream(AudioInputStream* stream) {
 
 std::unique_ptr<AudioManager> CreateAudioManager(
     std::unique_ptr<AudioThread> audio_thread,
-    AudioLogFactory* audio_log_factory) {
+    AudioLogFactory* audio_log_factory,
+    dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn) {
   return std::make_unique<AudioManagerMac>(std::move(audio_thread),
-                                           audio_log_factory);
+                                           audio_log_factory,
+                                           dvc_dm_conn);
 }
 
 }  // namespace media
diff --git a/media/audio/mac/audio_manager_mac.h b/media/audio/mac/audio_manager_mac.h
index c2fb8dec46c..258adaf5f0b 100644
--- a/media/audio/mac/audio_manager_mac.h
+++ b/media/audio/mac/audio_manager_mac.h
@@ -31,7 +31,8 @@ class AUHALStream;
 class MEDIA_EXPORT AudioManagerMac : public AudioManagerBase {
  public:
   AudioManagerMac(std::unique_ptr<AudioThread> audio_thread,
-                  AudioLogFactory* audio_log_factory);
+                  AudioLogFactory* audio_log_factory,
+                  dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn);
   ~AudioManagerMac() override;
 
   // Implementation of AudioManager.
diff --git a/media/audio/pulse/audio_manager_pulse.cc b/media/audio/pulse/audio_manager_pulse.cc
index f449e9ac8d6..b822214c423 100644
--- a/media/audio/pulse/audio_manager_pulse.cc
+++ b/media/audio/pulse/audio_manager_pulse.cc
@@ -33,11 +33,13 @@ constexpr int kDefaultInputBufferSize = 1024;
 constexpr int kDefaultSampleRate = 48000;
 constexpr int kDefaultChannelCount = 2;
 
-AudioManagerPulse::AudioManagerPulse(std::unique_ptr<AudioThread> audio_thread,
-                                     AudioLogFactory* audio_log_factory,
-                                     pa_threaded_mainloop* pa_mainloop,
-                                     pa_context* pa_context)
-    : AudioManagerBase(std::move(audio_thread), audio_log_factory),
+AudioManagerPulse::AudioManagerPulse(
+    std::unique_ptr<AudioThread> audio_thread,
+    AudioLogFactory* audio_log_factory,
+    dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn,
+    pa_threaded_mainloop* pa_mainloop,
+    pa_context* pa_context)
+    : AudioManagerBase(std::move(audio_thread), audio_log_factory, dvc_dm_conn),
       input_mainloop_(pa_mainloop),
       input_context_(pa_context),
       devices_(nullptr),
@@ -77,6 +79,7 @@ void AudioManagerPulse::GetAudioDeviceNames(
   DCHECK(input_context_);
   AutoPulseLock auto_lock(input_mainloop_);
   devices_ = device_names;
+  device_names_tmp_ = {};
   pa_operation* operation = NULL;
   if (input) {
     operation = pa_context_get_source_info_list(
@@ -87,6 +90,11 @@ void AudioManagerPulse::GetAudioDeviceNames(
   }
   WaitForOperationCompletion(input_mainloop_, operation, input_context_);
 
+  if (input)
+      input_device_names_ = std::move(device_names_tmp_);
+  else
+      output_device_names_ = std::move(device_names_tmp_);
+
   // Prepend the default device if the list is not empty.
   if (!device_names->empty())
     device_names->push_front(AudioDeviceName::CreateDefault());
@@ -135,7 +143,7 @@ AudioOutputStream* AudioManagerPulse::MakeLinearOutputStream(
     const AudioParameters& params,
     const LogCallback& log_callback) {
   DCHECK_EQ(AudioParameters::AUDIO_PCM_LINEAR, params.format());
-  return MakeOutputStream(params, AudioDeviceDescription::kDefaultDeviceId);
+  return MakeOutputStream(params, AudioDeviceDescription::kDefaultDeviceId, static_cast<uint32_t>(-1));
 }
 
 AudioOutputStream* AudioManagerPulse::MakeLowLatencyOutputStream(
@@ -143,9 +151,11 @@ AudioOutputStream* AudioManagerPulse::MakeLowLatencyOutputStream(
     const std::string& device_id,
     const LogCallback& log_callback) {
   DCHECK_EQ(AudioParameters::AUDIO_PCM_LOW_LATENCY, params.format());
+  auto it = output_device_names_.find(device_id);
+  uint32_t id = (it != output_device_names_.end()) ? it->second : static_cast<uint32_t>(-1);
   return MakeOutputStream(params, device_id.empty()
                                       ? AudioDeviceDescription::kDefaultDeviceId
-                                      : device_id);
+                                      : device_id, id);
 }
 
 AudioInputStream* AudioManagerPulse::MakeLinearInputStream(
@@ -153,7 +163,9 @@ AudioInputStream* AudioManagerPulse::MakeLinearInputStream(
     const std::string& device_id,
     const LogCallback& log_callback) {
   DCHECK_EQ(AudioParameters::AUDIO_PCM_LINEAR, params.format());
-  return MakeInputStream(params, device_id);
+  auto it = input_device_names_.find(device_id);
+  uint32_t id = (it != input_device_names_.end()) ? it->second : static_cast<uint32_t>(-1);
+  return MakeInputStream(params, device_id, id);
 }
 
 AudioInputStream* AudioManagerPulse::MakeLowLatencyInputStream(
@@ -161,7 +173,9 @@ AudioInputStream* AudioManagerPulse::MakeLowLatencyInputStream(
     const std::string& device_id,
     const LogCallback& log_callback) {
   DCHECK_EQ(AudioParameters::AUDIO_PCM_LOW_LATENCY, params.format());
-  return MakeInputStream(params, device_id);
+  auto it = input_device_names_.find(device_id);
+  uint32_t id = (it != input_device_names_.end()) ? it->second : static_cast<uint32_t>(-1);
+  return MakeInputStream(params, device_id, id);
 }
 
 std::string AudioManagerPulse::GetDefaultInputDeviceID() {
@@ -238,14 +252,15 @@ AudioParameters AudioManagerPulse::GetPreferredOutputStreamParameters(
 
 AudioOutputStream* AudioManagerPulse::MakeOutputStream(
     const AudioParameters& params,
-    const std::string& device_id) {
+    const std::string& device_id,
+    uint32_t id) {
   DCHECK(!device_id.empty());
-  return new PulseAudioOutputStream(params, device_id, this);
+  return new PulseAudioOutputStream(params, device_id, id, this);
 }
 
 AudioInputStream* AudioManagerPulse::MakeInputStream(
-    const AudioParameters& params, const std::string& device_id) {
-  return new PulseAudioInputStream(this, device_id, params,
+    const AudioParameters& params, const std::string& device_id, uint32_t id) {
+  return new PulseAudioInputStream(this, device_id, id, params,
                                    input_mainloop_, input_context_);
 }
 
@@ -290,6 +305,7 @@ void AudioManagerPulse::InputDevicesInfoCallback(pa_context* context,
   }
 
   manager->devices_->push_back(AudioDeviceName(info->description, info->name));
+  manager->device_names_tmp_.insert(std::make_pair(std::string(info->name), info->index));
 }
 
 void AudioManagerPulse::OutputDevicesInfoCallback(pa_context* context,
@@ -305,6 +321,7 @@ void AudioManagerPulse::OutputDevicesInfoCallback(pa_context* context,
   }
 
   manager->devices_->push_back(AudioDeviceName(info->description, info->name));
+  manager->device_names_tmp_.insert(std::make_pair(std::string(info->name), info->index));
 }
 
 void AudioManagerPulse::AudioHardwareInfoCallback(pa_context* context,
diff --git a/media/audio/pulse/audio_manager_pulse.h b/media/audio/pulse/audio_manager_pulse.h
index 11df0c61f10..9172038aa98 100644
--- a/media/audio/pulse/audio_manager_pulse.h
+++ b/media/audio/pulse/audio_manager_pulse.h
@@ -9,6 +9,7 @@
 
 #include <memory>
 #include <string>
+#include <unordered_map>
 
 #include "base/compiler_specific.h"
 #include "base/macros.h"
@@ -19,10 +20,12 @@ namespace media {
 
 class MEDIA_EXPORT AudioManagerPulse : public AudioManagerBase {
  public:
-  AudioManagerPulse(std::unique_ptr<AudioThread> audio_thread,
-                    AudioLogFactory* audio_log_factory,
-                    pa_threaded_mainloop* pa_mainloop,
-                    pa_context* pa_context);
+  AudioManagerPulse(
+      std::unique_ptr<AudioThread> audio_thread,
+      AudioLogFactory* audio_log_factory,
+      dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn,
+      pa_threaded_mainloop* pa_mainloop,
+      pa_context* pa_context);
   ~AudioManagerPulse() override;
 
   // Implementation of AudioManager.
@@ -89,11 +92,13 @@ class MEDIA_EXPORT AudioManagerPulse : public AudioManagerBase {
 
   // Called by MakeLinearOutputStream and MakeLowLatencyOutputStream.
   AudioOutputStream* MakeOutputStream(const AudioParameters& params,
-                                      const std::string& device_id);
+                                      const std::string& device_id,
+                                      uint32_t id);
 
   // Called by MakeLinearInputStream and MakeLowLatencyInputStream.
   AudioInputStream* MakeInputStream(const AudioParameters& params,
-                                    const std::string& device_id);
+                                    const std::string& device_id,
+                                    uint32_t id);
 
   // Updates |native_input_sample_rate_| and |native_channel_count_|.
   void UpdateNativeAudioHardwareInfo();
@@ -106,6 +111,10 @@ class MEDIA_EXPORT AudioManagerPulse : public AudioManagerBase {
   std::string default_source_name_;
   bool default_source_is_monitor_;
 
+  std::unordered_map<std::string, uint32_t> device_names_tmp_;
+  std::unordered_map<std::string, uint32_t> input_device_names_;
+  std::unordered_map<std::string, uint32_t> output_device_names_;
+
   DISALLOW_COPY_AND_ASSIGN(AudioManagerPulse);
 };
 
diff --git a/media/audio/pulse/pulse_input.cc b/media/audio/pulse/pulse_input.cc
index 8afeadc87a9..74ce59cc615 100644
--- a/media/audio/pulse/pulse_input.cc
+++ b/media/audio/pulse/pulse_input.cc
@@ -22,12 +22,14 @@ const int kNumberOfBlocksBufferInFifo = 2;
 
 PulseAudioInputStream::PulseAudioInputStream(AudioManagerPulse* audio_manager,
                                              const std::string& device_name,
+                                             uint32_t id,
                                              const AudioParameters& params,
                                              pa_threaded_mainloop* mainloop,
                                              pa_context* context)
     : audio_manager_(audio_manager),
       callback_(NULL),
       device_name_(device_name),
+      id_(id),
       params_(params),
       channels_(0),
       volume_(0.0),
@@ -89,6 +91,14 @@ void PulseAudioInputStream::Start(AudioInputCallback* callback) {
   pa_operation* operation =
       pa_stream_cork(handle_, 0, &pulse::StreamSuccessCallback, pa_mainloop_);
 
+  auto* dvc_dm_connection = audio_manager_->GetDvcDeviceManagerConnection();
+  if (dvc_dm_connection != nullptr) {
+    std::vector<int8_t> id;
+    id.resize(sizeof(id_));
+    memcpy(id.data(), &id_, sizeof(id_));
+    dvc_dm_connection->SetPreferredInputDevice(id);
+  }
+
   if (!WaitForOperationCompletion(pa_mainloop_, operation, pa_context_,
                                   handle_)) {
     callback_->OnError();
diff --git a/media/audio/pulse/pulse_input.h b/media/audio/pulse/pulse_input.h
index 56b39069681..095429b3edd 100644
--- a/media/audio/pulse/pulse_input.h
+++ b/media/audio/pulse/pulse_input.h
@@ -25,6 +25,7 @@ class PulseAudioInputStream : public AgcAudioStream<AudioInputStream> {
  public:
   PulseAudioInputStream(AudioManagerPulse* audio_manager,
                         const std::string& device_name,
+                        uint32_t id,
                         const AudioParameters& params,
                         pa_threaded_mainloop* mainloop,
                         pa_context* context);
@@ -62,6 +63,7 @@ class PulseAudioInputStream : public AgcAudioStream<AudioInputStream> {
   AudioManagerPulse* audio_manager_;
   AudioInputCallback* callback_;
   std::string device_name_;
+  const uint32_t id_;
   AudioParameters params_;
   int channels_;
   double volume_;
diff --git a/media/audio/pulse/pulse_output.cc b/media/audio/pulse/pulse_output.cc
index c0813ab36fe..59ac6556b8d 100644
--- a/media/audio/pulse/pulse_output.cc
+++ b/media/audio/pulse/pulse_output.cc
@@ -43,12 +43,14 @@ void PulseAudioOutputStream::StreamRequestCallback(pa_stream* s, size_t len,
 
 PulseAudioOutputStream::PulseAudioOutputStream(const AudioParameters& params,
                                                const std::string& device_id,
+                                               uint32_t id,
                                                AudioManagerBase* manager)
     : params_(AudioParameters(params.format(),
                               params.channel_layout(),
                               params.sample_rate(),
                               params.frames_per_buffer())),
       device_id_(device_id),
+      id_(id),
       manager_(manager),
       pa_context_(NULL),
       pa_mainloop_(NULL),
@@ -215,6 +217,15 @@ void PulseAudioOutputStream::Start(AudioSourceCallback* callback) {
   // Uncork (resume) the stream.
   pa_operation* operation = pa_stream_cork(
       pa_stream_, 0, &pulse::StreamSuccessCallback, pa_mainloop_);
+
+  auto* dvc_dm_connection = manager_->GetDvcDeviceManagerConnection();
+  if (dvc_dm_connection != nullptr) {
+    std::vector<int8_t> id;
+    id.resize(sizeof(id_));
+    memcpy(id.data(), &id_, sizeof(id_));
+    dvc_dm_connection->SetPreferredOutputDevice(id);
+  }
+
   if (!WaitForOperationCompletion(pa_mainloop_, operation, pa_context_,
                                   pa_stream_)) {
     callback->OnError(AudioSourceCallback::ErrorType::kUnknown);
diff --git a/media/audio/pulse/pulse_output.h b/media/audio/pulse/pulse_output.h
index 638459a0b4b..7077ee7e2ad 100644
--- a/media/audio/pulse/pulse_output.h
+++ b/media/audio/pulse/pulse_output.h
@@ -41,6 +41,7 @@ class PulseAudioOutputStream : public AudioOutputStream {
  public:
   PulseAudioOutputStream(const AudioParameters& params,
                          const std::string& device_id,
+                         uint32_t id,
                          AudioManagerBase* manager);
 
   ~PulseAudioOutputStream() override;
@@ -75,6 +76,7 @@ class PulseAudioOutputStream : public AudioOutputStream {
 
   // The device ID for the device to open.
   const std::string device_id_;
+  const uint32_t id_;
 
   // Audio manager that created us.  Used to report that we've closed.
   AudioManagerBase* manager_;
diff --git a/media/audio/win/audio_low_latency_input_win.cc b/media/audio/win/audio_low_latency_input_win.cc
index 9c20b24fa5a..3d8790a2557 100644
--- a/media/audio/win/audio_low_latency_input_win.cc
+++ b/media/audio/win/audio_low_latency_input_win.cc
@@ -294,6 +294,15 @@ void WASAPIAudioInputStream::Start(AudioInputCallback* callback) {
   }
 
   started_ = SUCCEEDED(hr);
+
+  auto* dvc_dm_connection = manager_->GetDvcDeviceManagerConnection();
+  if (dvc_dm_connection != nullptr) {
+    std::vector<int8_t> id;
+    id.resize(device_id_.size() + 1);
+    memcpy(id.data(), device_id_.c_str(), device_id_.size());
+    id[device_id_.size()] = 0;
+    dvc_dm_connection->SetPreferredInputDevice(id);
+  }
 }
 
 void WASAPIAudioInputStream::Stop() {
diff --git a/media/audio/win/audio_low_latency_output_win.cc b/media/audio/win/audio_low_latency_output_win.cc
index 490c843212f..929a92ba45b 100644
--- a/media/audio/win/audio_low_latency_output_win.cc
+++ b/media/audio/win/audio_low_latency_output_win.cc
@@ -329,6 +329,15 @@ void WASAPIAudioOutputStream::Start(AudioSourceCallback* callback) {
     PLOG(ERROR) << "Failed to start output streaming: " << std::hex << hr;
     StopThread();
     callback->OnError(AudioSourceCallback::ErrorType::kUnknown);
+  } else {
+    auto* dvc_dm_connection = manager_->GetDvcDeviceManagerConnection();
+    if (dvc_dm_connection != nullptr) {
+      std::vector<int8_t> id;
+      id.resize(device_id_.size() + 1);
+      memcpy(id.data(), device_id_.c_str(), device_id_.size());
+      id[device_id_.size()] = 0;
+      dvc_dm_connection->SetPreferredOutputDevice(id);
+    }
   }
 }
 
diff --git a/media/audio/win/audio_manager_win.cc b/media/audio/win/audio_manager_win.cc
index 92989314256..bf7f2b4002b 100644
--- a/media/audio/win/audio_manager_win.cc
+++ b/media/audio/win/audio_manager_win.cc
@@ -79,9 +79,13 @@ static int NumberOfWaveOutBuffers() {
   return 3;
 }
 
-AudioManagerWin::AudioManagerWin(std::unique_ptr<AudioThread> audio_thread,
-                                 AudioLogFactory* audio_log_factory)
-    : AudioManagerBase(std::move(audio_thread), audio_log_factory) {
+AudioManagerWin::AudioManagerWin(
+    std::unique_ptr<AudioThread> audio_thread,
+    AudioLogFactory* audio_log_factory,
+    dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn)
+    : AudioManagerBase(std::move(audio_thread),
+                       audio_log_factory,
+                       dvc_dm_conn) {
   // |CoreAudioUtil::IsSupported()| uses static variables to avoid doing
   // multiple initializations.  This is however not thread safe.
   // So, here we call it explicitly before we kick off the audio thread
@@ -394,9 +398,11 @@ AudioParameters AudioManagerWin::GetPreferredOutputStreamParameters(
 // static
 std::unique_ptr<AudioManager> CreateAudioManager(
     std::unique_ptr<AudioThread> audio_thread,
-    AudioLogFactory* audio_log_factory) {
+    AudioLogFactory* audio_log_factory,
+    dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn) {
   return std::make_unique<AudioManagerWin>(std::move(audio_thread),
-                                           audio_log_factory);
+                                           audio_log_factory,
+                                           dvc_dm_conn);
 }
 
 }  // namespace media
diff --git a/media/audio/win/audio_manager_win.h b/media/audio/win/audio_manager_win.h
index 1b4b3e62f41..21840bcf20e 100644
--- a/media/audio/win/audio_manager_win.h
+++ b/media/audio/win/audio_manager_win.h
@@ -21,7 +21,8 @@ class AudioDeviceListenerWin;
 class MEDIA_EXPORT AudioManagerWin : public AudioManagerBase {
  public:
   AudioManagerWin(std::unique_ptr<AudioThread> audio_thread,
-                  AudioLogFactory* audio_log_factory);
+                  AudioLogFactory* audio_log_factory,
+                  dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn);
   ~AudioManagerWin() override;
 
   // Implementation of AudioManager.
diff --git a/media/capture/video/video_capture_device_client.cc b/media/capture/video/video_capture_device_client.cc
index d9f0ce7f2cf..08aef54efe3 100644
--- a/media/capture/video/video_capture_device_client.cc
+++ b/media/capture/video/video_capture_device_client.cc
@@ -356,8 +356,8 @@ void VideoCaptureDeviceClient::OnIncomingCapturedData(
           format.frame_size.width(),
           (flip ? -1 : 1) * format.frame_size.height(), new_unrotated_width,
           new_unrotated_height, rotation_mode, fourcc_format) != 0) {
-    DLOG(WARNING) << "Failed to convert buffer's pixel format to I420 from "
-                  << VideoPixelFormatToString(format.pixel_format);
+    //DLOG(WARNING) << "Failed to convert buffer's pixel format to I420 from "
+                  //<< VideoPixelFormatToString(format.pixel_format); //jaudy
     receiver_->OnFrameDropped(
         VideoCaptureFrameDropReason::kDeviceClientLibyuvConvertToI420Failed);
     return;
diff --git a/services/BUILD.gn b/services/BUILD.gn
index 6976492ac00..aafe478bf27 100644
--- a/services/BUILD.gn
+++ b/services/BUILD.gn
@@ -80,6 +80,7 @@ test("services_unittests") {
     # or iOS, so any tests which use the ServiceTest framework to connect to
     # standalone services must be added here.
     deps += [ "//services/video_capture:tests" ]
+    #deps += [ "//dolby/services/dolby_voice_client:tests" ]
   }
 
   if (is_fuchsia) {
diff --git a/services/audio/BUILD.gn b/services/audio/BUILD.gn
index 2ba73b51dc3..74b447fc860 100644
--- a/services/audio/BUILD.gn
+++ b/services/audio/BUILD.gn
@@ -84,6 +84,7 @@ source_set("lib") {
 
   deps = [
     "//components/crash/core/common:crash_key",  # Temporary: crbug.com/888478
+    "//dolby/content/browser:dvc_content_browser",
   ]
 
   if (audio_processing_in_audio_service_supported) {
diff --git a/services/audio/in_process_audio_manager_accessor.cc b/services/audio/in_process_audio_manager_accessor.cc
index 4f889fe02ab..dd5a2f3e91d 100644
--- a/services/audio/in_process_audio_manager_accessor.cc
+++ b/services/audio/in_process_audio_manager_accessor.cc
@@ -32,4 +32,9 @@ void InProcessAudioManagerAccessor::SetAudioLogFactory(
   NOTREACHED();
 }
 
+void InProcessAudioManagerAccessor::SetDvcDeviceManagerConnection(
+    dolby_voice_client::browser::DvcDeviceManagerConnection* connection) {
+  NOTREACHED();
+}
+
 }  // namespace audio
diff --git a/services/audio/in_process_audio_manager_accessor.h b/services/audio/in_process_audio_manager_accessor.h
index 4ef021a676a..65aac538472 100644
--- a/services/audio/in_process_audio_manager_accessor.h
+++ b/services/audio/in_process_audio_manager_accessor.h
@@ -28,6 +28,8 @@ class InProcessAudioManagerAccessor : public Service::AudioManagerAccessor {
 
   // Should not be called on this implementation.
   void SetAudioLogFactory(media::AudioLogFactory* factory) final;
+  void SetDvcDeviceManagerConnection(
+    dolby_voice_client::browser::DvcDeviceManagerConnection* connection) final;
 
  private:
   media::AudioManager* const audio_manager_;
diff --git a/services/audio/owning_audio_manager_accessor.cc b/services/audio/owning_audio_manager_accessor.cc
index 9ecffa3590f..a11f593e5e3 100644
--- a/services/audio/owning_audio_manager_accessor.cc
+++ b/services/audio/owning_audio_manager_accessor.cc
@@ -20,6 +20,7 @@
 #include "media/audio/audio_manager.h"
 #include "media/audio/audio_thread.h"
 #include "media/audio/audio_thread_hang_monitor.h"
+#include "dolby/content/browser/dvc_device_manager_connection.h"
 
 using HangAction = media::AudioThreadHangMonitor::HangAction;
 
@@ -140,8 +141,10 @@ media::AudioManager* OwningAudioManagerAccessor::GetAudioManager() {
     DCHECK(audio_manager_factory_cb_);
     DCHECK(log_factory_);
     base::TimeTicks creation_start_time = base::TimeTicks::Now();
+
     audio_manager_ = std::move(audio_manager_factory_cb_)
-                         .Run(std::make_unique<MainThread>(), log_factory_);
+                         .Run(std::make_unique<MainThread>(), log_factory_,
+                              dvc_device_manager_connection_);
     DCHECK(audio_manager_);
     UMA_HISTOGRAM_TIMES("Media.AudioService.AudioManagerStartupTime",
                         base::TimeTicks::Now() - creation_start_time);
@@ -155,6 +158,11 @@ void OwningAudioManagerAccessor::SetAudioLogFactory(
   log_factory_ = log_factory;
 }
 
+void OwningAudioManagerAccessor::SetDvcDeviceManagerConnection(
+    dolby_voice_client::browser::DvcDeviceManagerConnection* connection) {
+  dvc_device_manager_connection_ = connection;
+}
+
 void OwningAudioManagerAccessor::Shutdown() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (audio_manager_)
diff --git a/services/audio/owning_audio_manager_accessor.h b/services/audio/owning_audio_manager_accessor.h
index 03f2c94cbc6..312cc930ee2 100644
--- a/services/audio/owning_audio_manager_accessor.h
+++ b/services/audio/owning_audio_manager_accessor.h
@@ -32,7 +32,8 @@ class OwningAudioManagerAccessor : public Service::AudioManagerAccessor {
   using AudioManagerFactoryCallback =
       base::OnceCallback<std::unique_ptr<media::AudioManager>(
           std::unique_ptr<media::AudioThread>,
-          media::AudioLogFactory* audio_log_factory)>;
+          media::AudioLogFactory* audio_log_factory,
+          dolby_voice_client::browser::DvcDeviceManagerConnection* dvc_dm_conn)>;
 
   explicit OwningAudioManagerAccessor(
       AudioManagerFactoryCallback audio_manager_factory_cb);
@@ -40,6 +41,8 @@ class OwningAudioManagerAccessor : public Service::AudioManagerAccessor {
 
   media::AudioManager* GetAudioManager() final;
   void SetAudioLogFactory(media::AudioLogFactory* factory) final;
+  void SetDvcDeviceManagerConnection(
+    dolby_voice_client::browser::DvcDeviceManagerConnection* connection) final;
   void Shutdown() final;
 
  private:
@@ -51,6 +54,8 @@ class OwningAudioManagerAccessor : public Service::AudioManagerAccessor {
   AudioManagerFactoryCallback audio_manager_factory_cb_;
   std::unique_ptr<media::AudioManager> audio_manager_;
   media::AudioLogFactory* log_factory_ = nullptr;  // not owned.
+  dolby_voice_client::browser::DvcDeviceManagerConnection*
+    dvc_device_manager_connection_ = nullptr; // not owned.
 
   THREAD_CHECKER(thread_checker_);
   DISALLOW_COPY_AND_ASSIGN(OwningAudioManagerAccessor);
diff --git a/services/audio/public/cpp/manifest.cc b/services/audio/public/cpp/manifest.cc
index c6ce7bbaec6..3cd90661adf 100644
--- a/services/audio/public/cpp/manifest.cc
+++ b/services/audio/public/cpp/manifest.cc
@@ -28,6 +28,7 @@ service_manager::Manifest GetManifest(
                                service_manager::Manifest::
                                    InstanceSharingPolicy::kSharedAcrossGroups)
                            .Build())
+          .RequireCapability("dolby_voice_client", "dolby_voice_client")
           .ExposeCapability(
               "debug_recording",
               service_manager::Manifest::InterfaceList<mojom::DebugRecording>())
diff --git a/services/audio/service.cc b/services/audio/service.cc
index 246dd45a3bc..c0c56c76157 100644
--- a/services/audio/service.cc
+++ b/services/audio/service.cc
@@ -58,6 +58,12 @@ Service::Service(
     log_factory_manager_ = std::make_unique<LogFactoryManager>();
     audio_manager_accessor_->SetAudioLogFactory(
         log_factory_manager_->GetLogFactory());
+
+    dvc_device_manager_connection_ =
+      std::make_unique<dolby_voice_client::browser::DvcDeviceManagerConnection>(
+        service_binding_.GetConnector()->Clone());
+    audio_manager_accessor_->SetDvcDeviceManagerConnection(
+      dvc_device_manager_connection_.get());
   } else {
     // Start device monitoring explicitly if no mojo device notifier will be
     // created. This is required for in-process device notifications.
diff --git a/services/audio/service.h b/services/audio/service.h
index b37b5393755..0057ef6ae8b 100644
--- a/services/audio/service.h
+++ b/services/audio/service.h
@@ -26,6 +26,12 @@
 #include "services/service_manager/public/cpp/service_keepalive.h"
 #include "services/service_manager/public/mojom/service.mojom.h"
 
+namespace dolby_voice_client {
+namespace browser {
+class DvcDeviceManagerConnection;
+}  // namespace browser
+}  // namespace dolby_voice_client
+
 namespace base {
 class DeferredSequencedTaskRunner;
 class SystemMonitor;
@@ -63,6 +69,9 @@ class Service : public service_manager::Service {
     // |factory| must outlive the audio manager.
     // It only makes sense to call this method before GetAudioManager().
     virtual void SetAudioLogFactory(media::AudioLogFactory* factory) = 0;
+
+    virtual void SetDvcDeviceManagerConnection(
+      dolby_voice_client::browser::DvcDeviceManagerConnection* connection) = 0;
   };
 
   // Service will attempt to quit if there are no connections to it within
@@ -128,6 +137,8 @@ class Service : public service_manager::Service {
   base::Optional<StreamFactory> stream_factory_;
   std::unique_ptr<DeviceNotifier> device_notifier_;
   std::unique_ptr<LogFactoryManager> log_factory_manager_;
+  std::unique_ptr<dolby_voice_client::browser::DvcDeviceManagerConnection>
+    dvc_device_manager_connection_;
   std::unique_ptr<ServiceMetrics> metrics_;
 
   std::unique_ptr<service_manager::BinderMap> binders_;
diff --git a/third_party/webrtc/api/call/transport.cc b/third_party/webrtc/api/call/transport.cc
index bcadc762de4..3ffe4dce437 100644
--- a/third_party/webrtc/api/call/transport.cc
+++ b/third_party/webrtc/api/call/transport.cc
@@ -20,4 +20,8 @@ PacketOptions::PacketOptions(const PacketOptions&) = default;
 
 PacketOptions::~PacketOptions() = default;
 
+dolby_voice_client::webrtc_integration::DvcVoiceMediaChannel* Transport::GetDvcVoiceMediaChannel() const {
+  return nullptr;
+}
+
 }  // namespace webrtc
diff --git a/third_party/webrtc/api/call/transport.h b/third_party/webrtc/api/call/transport.h
index 2a2a87a5f66..6c6e641c335 100644
--- a/third_party/webrtc/api/call/transport.h
+++ b/third_party/webrtc/api/call/transport.h
@@ -16,6 +16,12 @@
 
 #include <vector>
 
+namespace dolby_voice_client {
+namespace webrtc_integration {
+class DvcVoiceMediaChannel;
+}
+}
+
 namespace webrtc {
 
 // TODO(holmer): Look into unifying this with the PacketOptions in
@@ -44,6 +50,8 @@ class Transport {
                        const PacketOptions& options) = 0;
   virtual bool SendRtcp(const uint8_t* packet, size_t length) = 0;
 
+  virtual dolby_voice_client::webrtc_integration::DvcVoiceMediaChannel* GetDvcVoiceMediaChannel() const;
+
  protected:
   virtual ~Transport() {}
 };
diff --git a/third_party/webrtc/audio/channel_receive.cc b/third_party/webrtc/audio/channel_receive.cc
index 2ecc3cf7b3e..392e45c1b1f 100644
--- a/third_party/webrtc/audio/channel_receive.cc
+++ b/third_party/webrtc/audio/channel_receive.cc
@@ -47,6 +47,8 @@
 #include "rtc_base/time_utils.h"
 #include "system_wrappers/include/metrics.h"
 
+#include "dvc/media/engine/dvcvoicemediachannel.h"
+
 namespace webrtc {
 namespace voe {
 
@@ -256,6 +258,9 @@ class ChannelReceive : public ChannelReceiveInterface {
 
   rtc::ThreadChecker construction_thread_;
 
+  dolby_voice_client::webrtc_integration::DvcVoiceMediaChannel* _dvc_channel;
+  int32_t _last_minimum_playout_delay_ms;
+
   // E2EE Audio Frame Decryption
   rtc::scoped_refptr<FrameDecryptorInterface> frame_decryptor_;
   webrtc::CryptoOptions crypto_options_;
@@ -439,6 +444,8 @@ ChannelReceive::ChannelReceive(
       _audioDeviceModulePtr(audio_device_module),
       _outputGain(1.0f),
       associated_send_channel_(nullptr),
+      _dvc_channel(NULL),
+      _last_minimum_playout_delay_ms(-1),
       frame_decryptor_(frame_decryptor),
       crypto_options_(crypto_options) {
   // TODO(nisse): Use _moduleProcessThreadPtr instead?
@@ -452,6 +459,10 @@ ChannelReceive::ChannelReceive(
   acm_receiver_.SetMaximumDelay(0);
   acm_receiver_.FlushBuffers();
 
+  if (rtcp_send_transport) {
+    _dvc_channel = rtcp_send_transport->GetDvcVoiceMediaChannel();
+  }
+
   _outputAudioLevel.ResetLevelFullRange();
 
   rtp_receive_statistics_->EnableRetransmitDetection(remote_ssrc_, true);
@@ -747,7 +758,11 @@ uint32_t ChannelReceive::GetDelayEstimate() const {
   RTC_DCHECK(worker_thread_checker_.IsCurrent() ||
              module_process_thread_checker_.IsCurrent());
   rtc::CritScope lock(&video_sync_lock_);
-  return acm_receiver_.FilteredCurrentDelayMs() + playout_delay_ms_;
+  rtc::CritScope cs(&_callbackCritSect);
+  if (_dvc_channel != nullptr && _dvc_channel->IsUsingDvcCodec())
+    return _last_minimum_playout_delay_ms + playout_delay_ms_;
+  else
+    return acm_receiver_.FilteredCurrentDelayMs() + playout_delay_ms_;
 }
 
 void ChannelReceive::SetMinimumPlayoutDelay(int delay_ms) {
@@ -756,6 +771,17 @@ void ChannelReceive::SetMinimumPlayoutDelay(int delay_ms) {
   // close as possible, instead of failing.
   delay_ms = rtc::SafeClamp(delay_ms, kVoiceEngineMinMinPlayoutDelayMs,
                             kVoiceEngineMaxMinPlayoutDelayMs);
+
+  {
+    rtc::CritScope cs(&_callbackCritSect);
+    if (_dvc_channel != nullptr)
+        _dvc_channel->SetMinimumPlayoutDelay(delay_ms);
+  }
+  {
+    rtc::CritScope lock(&video_sync_lock_);
+    _last_minimum_playout_delay_ms = delay_ms;
+  }
+
   if (acm_receiver_.SetMinimumDelay(delay_ms) != 0) {
     RTC_DLOG(LS_ERROR)
         << "SetMinimumPlayoutDelay() failed to set min playout delay";
diff --git a/third_party/webrtc/audio/channel_send.cc b/third_party/webrtc/audio/channel_send.cc
index 5541d75c107..db93451c2e7 100644
--- a/third_party/webrtc/audio/channel_send.cc
+++ b/third_party/webrtc/audio/channel_send.cc
@@ -44,6 +44,8 @@
 #include "system_wrappers/include/field_trial.h"
 #include "system_wrappers/include/metrics.h"
 
+#include "dvc/media/engine/dvcvoicemediachannel.h"
+
 namespace webrtc {
 namespace voe {
 
@@ -195,6 +197,7 @@ class ChannelSend : public ChannelSendInterface,
 
   // uses
   ProcessThread* const _moduleProcessThreadPtr;
+  dolby_voice_client::webrtc_integration::DvcVoiceMediaChannel* _dvc_channel;
   RmsLevel rms_level_ RTC_GUARDED_BY(encoder_queue_);
   bool input_mute_ RTC_GUARDED_BY(volume_settings_critsect_);
   bool previous_frame_muted_ RTC_GUARDED_BY(encoder_queue_);
@@ -425,6 +428,33 @@ int32_t ChannelSend::SendRtpAudio(AudioFrameType frameType,
     }
   }
 
+  if (_dvc_channel != nullptr && _dvc_channel->IsUsingDvcCodec()) {
+    // Get audio payload received from the DVC and and push everything to the
+    // rtp/rtcp module
+    std::vector<dolby_voice_client::webrtc_integration::AudioBuffer>
+        packets_to_send;
+
+    if (!_dvc_channel->GetPacketsToSend(packets_to_send))
+      return 0;
+
+    for (auto& packet_to_send : packets_to_send) {
+      if (!_rtpRtcpModule->OnSendingRtpFrame(packet_to_send.rtp_header_.timestamp,
+                                        packet_to_send.receive_time_ms_, payloadType,
+                                        /*force_sender_report=*/false)) {
+        return -1;
+      }
+      if (!rtp_sender_audio_->SendAudio(AudioFrameType::kAudioFrameSpeech, payloadType,
+                                        packet_to_send.rtp_header_.timestamp,
+                                        packet_to_send.payload.data(),
+                                        packet_to_send.payload.size())) {
+        RTC_DLOG(LS_ERROR)
+            << "ChannelSend::SendData() failed to send data to RTP/RTCP module";
+        return -1;
+      }
+    }
+    return 0;
+  }
+
   // Push data from ACM to RTP/RTCP-module to deliver audio frame for
   // packetization.
   if (!_rtpRtcpModule->OnSendingRtpFrame(timeStamp,
@@ -469,6 +499,7 @@ ChannelSend::ChannelSend(Clock* clock,
       _timeStamp(0),  // This is just an offset, RTP module will add it's own
                       // random offset
       _moduleProcessThreadPtr(module_process_thread),
+      _dvc_channel(NULL),
       input_mute_(false),
       previous_frame_muted_(false),
       _includeAudioLevelIndication(false),
@@ -487,6 +518,10 @@ ChannelSend::ChannelSend(Clock* clock,
 
   audio_coding_.reset(AudioCodingModule::Create(AudioCodingModule::Config()));
 
+  if (rtp_transport) {
+    _dvc_channel = rtp_transport->GetDvcVoiceMediaChannel();
+  }
+
   RtpRtcp::Configuration configuration;
   configuration.overhead_observer = overhead_observer;
   configuration.bandwidth_callback = rtcp_observer_.get();
@@ -584,6 +619,11 @@ void ChannelSend::SetEncoder(int payload_type,
                                           encoder->RtpTimestampRateHz(),
                                           encoder->NumChannels(), 0);
 
+  // If we're using DTX, the RTCP sender must know the real clock frequency,
+  // otherwise it will calculate invalid RTP timestamps during silence, causing
+  // A/V sync problems on the receiver side.
+  _rtpRtcpModule->SetAudioClockRate(encoder->RtpTimestampRateHz());
+
   audio_coding_->SetEncoder(std::move(encoder));
 }
 
@@ -657,6 +697,9 @@ void ChannelSend::SetInputMute(bool enable) {
   RTC_DCHECK_RUN_ON(&worker_thread_checker_);
   rtc::CritScope cs(&volume_settings_critsect_);
   input_mute_ = enable;
+
+  if (_dvc_channel)
+    _dvc_channel->SetInputMute(enable);
 }
 
 bool ChannelSend::InputMute() const {
diff --git a/third_party/webrtc/dvc/BUILD.gn b/third_party/webrtc/dvc/BUILD.gn
new file mode 100644
index 00000000000..38160ce28e6
--- /dev/null
+++ b/third_party/webrtc/dvc/BUILD.gn
@@ -0,0 +1,135 @@
+# Copyright 2020 Dolby Laboratories and Dolby International AB
+# Use of this source code is governed by the MIT license that can be
+# found in the dolby/LICENSE file.
+
+# rmors@dolby.com
+
+import("../webrtc.gni")
+
+group("dvc") {
+  public_deps = [
+    ":dvc_pc",
+    ":dvc_media",
+    ":dvc_api",
+  ]
+}
+
+rtc_source_set("dvc_api") {
+  sources = [
+    "api/audio_codecs/dvc/audio_decoder_dvc.cc",
+    "api/audio_codecs/dvc/audio_decoder_dvc.h",
+    "api/audio_codecs/dvc/audio_encoder_dvc.cc",
+    "api/audio_codecs/dvc/audio_encoder_dvc.h",
+    "api/audio_codecs/dvc/dvcaudiodecoderimpl.cc",
+    "api/audio_codecs/dvc/dvcaudiodecoderimpl.h",
+    "api/audio_codecs/dvc/dvcaudioencoderimpl.cc",
+    "api/audio_codecs/dvc/dvcaudioencoderimpl.h",
+    "api/audio_codecs/dvcaudiocodecfactories.cc",
+    "api/audio_codecs/dvcaudiocodecfactories.h",
+    "api/audio_codecs/donothingaudioencoderadapter.cc",
+    "api/audio_codecs/donothingaudioencoderadapter.h",
+    "api/audio_codecs/donothingaudiodecoderadapter.cc",
+    "api/audio_codecs/donothingaudiodecoderadapter.h",
+  ]
+
+  if (!build_with_chromium && is_clang) {
+    # Suppress warnings from the Chromium Clang plugin (bugs.webrtc.org/163).
+    suppressed_configs += [ "//build/config/clang:find_bad_constructs" ]
+  }
+
+  deps = [
+    "../api/audio_codecs:builtin_audio_decoder_factory",
+    "../api/audio_codecs:builtin_audio_encoder_factory",
+  ]
+
+  defines = ["WEBRTC_USE_BUILTIN_OPUS=1"]
+
+  if (current_cpu == "arm") {
+    defines += [
+      "WEBRTC_USE_BUILTIN_ISAC_FIX=1",
+      "WEBRTC_USE_BUILTIN_ISAC_FLOAT=0",
+    ]
+  } else {
+    defines += [
+      "WEBRTC_USE_BUILTIN_ISAC_FIX=0",
+      "WEBRTC_USE_BUILTIN_ISAC_FLOAT=1",
+    ]
+  }
+
+  if (rtc_include_ilbc) {
+    deps += [ "../api/audio_codecs/ilbc:audio_encoder_ilbc",
+              "../api/audio_codecs/ilbc:audio_decoder_ilbc" ]
+    defines += [ "WEBRTC_USE_BUILTIN_ILBC=1" ]
+  } else {
+    defines += [ "WEBRTC_USE_BUILTIN_ILBC=0" ]
+  }
+}
+
+rtc_source_set("dvc_pc") {
+  sources = [
+    "pc/dvcpeerconnection.cc",
+    "pc/dvcpeerconnection.h",
+  ]
+
+  if (!build_with_chromium && is_clang) {
+    # Suppress warnings from the Chromium Clang plugin (bugs.webrtc.org/163).
+    suppressed_configs += [ "//build/config/clang:find_bad_constructs" ]
+  }
+
+  deps = [
+    ":dvc_audio_session",
+  ]
+}
+
+rtc_source_set("dvc_media") {
+  sources = [
+    "media/engine/dvcvoiceengine.cc",
+    "media/engine/dvcvoiceengine.h",
+    "media/engine/dvcvoicemediachannel.cc",
+    "media/engine/dvcvoicemediachannel.h",
+  ]
+
+  if (!build_with_chromium && is_clang) {
+    # Suppress warnings from the Chromium Clang plugin (bugs.webrtc.org/163).
+    suppressed_configs += [ "//build/config/clang:find_bad_constructs" ]
+  }
+
+  deps = [
+    ":dvc_api",
+    ":dvc_conference_factory",
+  ]
+}
+
+rtc_source_set("dvc_audio_session") {
+  sources = [
+    "audiosession.cc",
+    "audiosession.h",
+    "audiobufferqueue.cc",
+    "audiobufferqueue.h",
+    "audiopackethandler.cc",
+    "audiopackethandler.h",
+    "common.h",
+  ]
+
+  deps = [
+    "../pc",
+    "../rtc_base",
+    "../modules/rtp_rtcp",
+    ":dvc_conference_factory",
+    "../../../dolby/services/dolby_voice_client:dvc_utils"
+  ]
+
+  if (!build_with_chromium && is_clang) {
+    # Suppress warnings from the Chromium Clang plugin (bugs.webrtc.org/163).
+    suppressed_configs += [ "//build/config/clang:find_bad_constructs" ]
+  }
+}
+
+rtc_source_set("dvc_conference_factory") {
+  sources = [
+    "dvc_conference_factory.h",
+    "dvc_conference_factory.cc",
+    "dvc_constants.h",
+  ]
+}
+
diff --git a/third_party/webrtc/dvc/api/audio_codecs/donothingaudiodecoderadapter.cc b/third_party/webrtc/dvc/api/audio_codecs/donothingaudiodecoderadapter.cc
new file mode 100644
index 00000000000..9a74ae81d68
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/donothingaudiodecoderadapter.cc
@@ -0,0 +1,71 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/api/audio_codecs/donothingaudiodecoderadapter.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+DoNothingDecoderAdapter::DoNothingDecoderAdapter(
+    std::unique_ptr<webrtc::AudioDecoder> decoder)
+    : _decoder(std::move(decoder)) {}
+
+bool DoNothingDecoderAdapter::HasDecodePlc() const {
+  return _decoder->HasDecodePlc();
+}
+
+size_t DoNothingDecoderAdapter::DecodePlc(size_t num_frames, int16_t* decoded) {
+  return _decoder->DecodePlc(num_frames, decoded);
+}
+
+void DoNothingDecoderAdapter::Reset() {
+  _decoder->Reset();
+}
+
+int DoNothingDecoderAdapter::ErrorCode() {
+  return _decoder->ErrorCode();
+}
+
+int DoNothingDecoderAdapter::PacketDuration(const uint8_t* encoded,
+                                            size_t encoded_len) const {
+  return _decoder->PacketDuration(encoded, encoded_len);
+}
+
+int DoNothingDecoderAdapter::PacketDurationRedundant(const uint8_t* encoded,
+                                                     size_t encoded_len) const {
+  return _decoder->PacketDurationRedundant(encoded, encoded_len);
+}
+
+bool DoNothingDecoderAdapter::PacketHasFec(const uint8_t* encoded,
+                                           size_t encoded_len) const {
+  return _decoder->PacketHasFec(encoded, encoded_len);
+}
+
+int DoNothingDecoderAdapter::SampleRateHz() const {
+  return _decoder->SampleRateHz();
+}
+
+size_t DoNothingDecoderAdapter::Channels() const {
+  return _decoder->Channels();
+}
+
+int DoNothingDecoderAdapter::DecodeInternal(const uint8_t* encoded,
+                                            size_t encoded_len,
+                                            int /* sample_rate_hz */,
+                                            int16_t* decoded,
+                                            SpeechType* speech_type) {
+  // Audio is offloaded to the DVC, so only pretend to decode.
+  // Decoded buffer size in ensured by value returned in PacketDuration()
+  // function.
+  int decoded_samples = static_cast<int>(
+      _decoder->PacketDuration(encoded, encoded_len) * _decoder->Channels());
+  size_t decoded_buffer_size =
+      static_cast<size_t>(decoded_samples) * sizeof(int16_t);
+  std::memset(decoded, 0, decoded_buffer_size);
+  *speech_type = kSpeech;
+  return decoded_samples;
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
diff --git a/third_party/webrtc/dvc/api/audio_codecs/donothingaudiodecoderadapter.h b/third_party/webrtc/dvc/api/audio_codecs/donothingaudiodecoderadapter.h
new file mode 100644
index 00000000000..12411b28c42
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/donothingaudiodecoderadapter.h
@@ -0,0 +1,44 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef DVC_API_AUDIO_CODECS_DONOTHING_AUDIO_DECODER_ADAPTER_H_
+#define DVC_API_AUDIO_CODECS_DONOTHING_AUDIO_DECODER_ADAPTER_H_
+
+#include "api/audio_codecs/audio_decoder.h"
+#include "api/audio_codecs/audio_format.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+class DoNothingDecoderAdapter : public webrtc::AudioDecoder {
+ public:
+  DoNothingDecoderAdapter(std::unique_ptr<webrtc::AudioDecoder> decoder);
+  virtual ~DoNothingDecoderAdapter() = default;
+
+  bool HasDecodePlc() const override;
+  size_t DecodePlc(size_t num_frames, int16_t* decoded) override;
+  void Reset() override;
+  int ErrorCode() override;
+  int PacketDuration(const uint8_t* encoded, size_t encoded_len) const override;
+  int PacketDurationRedundant(const uint8_t* encoded,
+                              size_t encoded_len) const override;
+  bool PacketHasFec(const uint8_t* encoded, size_t encoded_len) const override;
+  int SampleRateHz() const override;
+  size_t Channels() const override;
+
+ protected:
+  int DecodeInternal(const uint8_t* encoded,
+                     size_t encoded_len,
+                     int sample_rate_hz,
+                     int16_t* decoded,
+                     SpeechType* speech_type) override;
+
+ private:
+  std::unique_ptr<webrtc::AudioDecoder> _decoder;
+};
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif /* DVC_API_AUDIO_CODECS_DONOTHING_AUDIO_DECODER_ADAPTER_H_ */
diff --git a/third_party/webrtc/dvc/api/audio_codecs/donothingaudioencoderadapter.cc b/third_party/webrtc/dvc/api/audio_codecs/donothingaudioencoderadapter.cc
new file mode 100644
index 00000000000..03a653b5b97
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/donothingaudioencoderadapter.cc
@@ -0,0 +1,146 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/api/audio_codecs/donothingaudioencoderadapter.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+DoNothingEncoderAdapter::DoNothingEncoderAdapter(
+    std::unique_ptr<AudioEncoder> encoder,
+    CodecType codec_type,
+    int payload_type)
+    : _encoder(std::move(encoder)),
+      _codec_type(codec_type),
+      _payload_type(payload_type) {}
+
+int DoNothingEncoderAdapter::SampleRateHz() const {
+  return _encoder->SampleRateHz();
+}
+
+size_t DoNothingEncoderAdapter::NumChannels() const {
+  return _encoder->NumChannels();
+}
+
+int DoNothingEncoderAdapter::RtpTimestampRateHz() const {
+  return _encoder->RtpTimestampRateHz();
+}
+
+size_t DoNothingEncoderAdapter::Num10MsFramesInNextPacket() const {
+  return _encoder->Num10MsFramesInNextPacket();
+}
+
+size_t DoNothingEncoderAdapter::Max10MsFramesInAPacket() const {
+  return _encoder->Max10MsFramesInAPacket();
+}
+
+int DoNothingEncoderAdapter::GetTargetBitrate() const {
+  return _encoder->GetTargetBitrate();
+}
+
+void DoNothingEncoderAdapter::Reset() {
+  return _encoder->Reset();
+}
+
+bool DoNothingEncoderAdapter::SetFec(bool enable) {
+  return _encoder->SetFec(enable);
+}
+
+bool DoNothingEncoderAdapter::SetDtx(bool enable) {
+  return _encoder->SetDtx(enable);
+}
+
+bool DoNothingEncoderAdapter::GetDtx() const {
+  return _encoder->GetDtx();
+}
+
+bool DoNothingEncoderAdapter::SetApplication(Application application) {
+  return _encoder->SetApplication(application);
+}
+
+void DoNothingEncoderAdapter::SetMaxPlaybackRate(int frequency_hz) {
+  _encoder->SetMaxPlaybackRate(frequency_hz);
+}
+
+void DoNothingEncoderAdapter::SetTargetBitrate(int target_bps) {
+  // DEPRECATED
+}
+
+rtc::ArrayView<std::unique_ptr<webrtc::AudioEncoder>>
+DoNothingEncoderAdapter::ReclaimContainedEncoders() {
+  return _encoder->ReclaimContainedEncoders();
+}
+
+bool DoNothingEncoderAdapter::EnableAudioNetworkAdaptor(
+    const std::string& config_string,
+    webrtc::RtcEventLog* event_log) {
+  return _encoder->EnableAudioNetworkAdaptor(config_string, event_log);
+}
+
+void DoNothingEncoderAdapter::DisableAudioNetworkAdaptor() {
+  _encoder->DisableAudioNetworkAdaptor();
+}
+
+void DoNothingEncoderAdapter::OnReceivedUplinkPacketLossFraction(
+    float uplink_packet_loss_fraction) {
+  _encoder->OnReceivedUplinkPacketLossFraction(uplink_packet_loss_fraction);
+}
+
+void DoNothingEncoderAdapter::OnReceivedUplinkRecoverablePacketLossFraction(
+    float uplink_recoverable_packet_loss_fraction) {
+  _encoder->OnReceivedUplinkRecoverablePacketLossFraction(
+      uplink_recoverable_packet_loss_fraction);
+}
+
+void DoNothingEncoderAdapter::OnReceivedTargetAudioBitrate(int target_bps) {
+  _encoder->OnReceivedTargetAudioBitrate(target_bps);
+}
+
+void DoNothingEncoderAdapter::OnReceivedUplinkBandwidth(
+    int target_audio_bitrate_bps,
+    absl::optional<int64_t> bwe_period_ms) {
+  _encoder->OnReceivedUplinkBandwidth(target_audio_bitrate_bps, bwe_period_ms);
+}
+
+void DoNothingEncoderAdapter::OnReceivedRtt(int rtt_ms) {
+  _encoder->OnReceivedRtt(rtt_ms);
+}
+
+void DoNothingEncoderAdapter::OnReceivedOverhead(
+    size_t overhead_bytes_per_packet) {
+  _encoder->OnReceivedOverhead(overhead_bytes_per_packet);
+}
+
+void DoNothingEncoderAdapter::SetReceiverFrameLengthRange(
+    int min_frame_length_ms,
+    int max_frame_length_ms) {
+  _encoder->SetReceiverFrameLengthRange(min_frame_length_ms,
+                                        max_frame_length_ms);
+}
+
+webrtc::ANAStats DoNothingEncoderAdapter::GetANAStats() const {
+  return _encoder->GetANAStats();
+}
+
+webrtc::AudioEncoder::EncodedInfo DoNothingEncoderAdapter::EncodeImpl(
+    uint32_t rtp_timestamp,
+    rtc::ArrayView<const int16_t> audio,
+    rtc::Buffer* encoded) {
+  // Audio is offloaded to the DCP, so only pretend to encode
+  EncodedInfo info;
+  info.payload_type = _payload_type;
+  info.send_even_if_empty = false;
+  info.speech = true;
+  info.encoder_type = _codec_type;
+  info.encoded_timestamp = rtp_timestamp;
+
+  size_t encoded_len = audio.size();
+  std::vector<uint8_t> fake_encoded_data(encoded_len);
+  encoded->AppendData(fake_encoded_data.data(), encoded_len);
+  info.encoded_bytes = encoded_len;
+  return info;
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
diff --git a/third_party/webrtc/dvc/api/audio_codecs/donothingaudioencoderadapter.h b/third_party/webrtc/dvc/api/audio_codecs/donothingaudioencoderadapter.h
new file mode 100644
index 00000000000..0a0c21c2d47
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/donothingaudioencoderadapter.h
@@ -0,0 +1,66 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef DVC_API_AUDIO_CODECS_DONOTHING_AUDIO_ENCODER_ADAPTER_H_
+#define DVC_API_AUDIO_CODECS_DONOTHING_AUDIO_ENCODER_ADAPTER_H_
+
+#include "api/audio_codecs/audio_encoder.h"
+#include "api/audio_codecs/audio_format.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+class DoNothingEncoderAdapter : public webrtc::AudioEncoder {
+ public:
+  DoNothingEncoderAdapter(std::unique_ptr<webrtc::AudioEncoder> encoder,
+                          CodecType codec_type,
+                          int payload_type);
+  virtual ~DoNothingEncoderAdapter() = default;
+
+  int SampleRateHz() const override;
+  size_t NumChannels() const override;
+  int RtpTimestampRateHz() const override;
+  size_t Num10MsFramesInNextPacket() const override;
+  size_t Max10MsFramesInAPacket() const override;
+  int GetTargetBitrate() const override;
+  void Reset() override;
+  bool SetFec(bool enable) override;
+  bool SetDtx(bool enable) override;
+  bool GetDtx() const override;
+  bool SetApplication(Application application) override;
+  void SetMaxPlaybackRate(int frequency_hz) override;
+  void SetTargetBitrate(int target_bps) override;
+  rtc::ArrayView<std::unique_ptr<AudioEncoder>> ReclaimContainedEncoders()
+      override;
+  bool EnableAudioNetworkAdaptor(const std::string& config_string,
+                                 webrtc::RtcEventLog* event_log) override;
+  void DisableAudioNetworkAdaptor() override;
+  void OnReceivedUplinkPacketLossFraction(
+      float uplink_packet_loss_fraction) override;
+  RTC_DEPRECATED void OnReceivedUplinkRecoverablePacketLossFraction(
+      float uplink_recoverable_packet_loss_fraction) override;
+  void OnReceivedTargetAudioBitrate(int target_bps) override;
+  void OnReceivedUplinkBandwidth(int target_audio_bitrate_bps,
+                                 absl::optional<int64_t> bwe_period_ms) override;
+  void OnReceivedRtt(int rtt_ms) override;
+  void OnReceivedOverhead(size_t overhead_bytes_per_packet) override;
+  void SetReceiverFrameLengthRange(int min_frame_length_ms,
+                                   int max_frame_length_ms) override;
+  webrtc::ANAStats GetANAStats() const override;
+
+ protected:
+  EncodedInfo EncodeImpl(uint32_t rtp_timestamp,
+                         rtc::ArrayView<const int16_t> audio,
+                         rtc::Buffer* encoded) override;
+
+ private:
+  std::unique_ptr<webrtc::AudioEncoder> _encoder;
+  CodecType _codec_type = CodecType::kOther;
+  int _payload_type = 0;
+};
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif /* DVC_API_AUDIO_CODECS_DONOTHING_AUDIO_ENCODER_ADAPTER_H_ */
diff --git a/third_party/webrtc/dvc/api/audio_codecs/dvc/audio_decoder_dvc.cc b/third_party/webrtc/dvc/api/audio_codecs/dvc/audio_decoder_dvc.cc
new file mode 100644
index 00000000000..c62a74138a5
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/dvc/audio_decoder_dvc.cc
@@ -0,0 +1,48 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/api/audio_codecs/dvc/audio_decoder_dvc.h"
+
+#include <memory>
+#include <vector>
+
+#include "absl/types/optional.h"
+#include "absl/memory/memory.h"
+#include "common_types.h"
+#include "rtc_base/numerics/safe_conversions.h"
+
+#include "dolby/services/dolby_voice_client/vars.h"
+#include "dvc/api/audio_codecs/dvc/dvcaudiodecoderimpl.h"
+#include "dvc/dvc_constants.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+absl::optional<AudioDecoderDVC::Config> AudioDecoderDVC::SdpToConfig(
+    const webrtc::SdpAudioFormat& format) {
+  return absl::optional<AudioDecoderDVC::Config>(format);
+}
+
+void AudioDecoderDVC::AppendSupportedDecoders(
+    std::vector<webrtc::AudioCodecSpec>* specs) {
+  for (auto rate : DVC_SAMPLING_RATES) {
+    specs->push_back(webrtc::AudioCodecSpec{
+        webrtc::SdpAudioFormat{getDolbyValueOr(
+                                switches::kDvcCodecName, 
+                                webrtc_integration::DVC_CODEC_NAME),
+                               rate,
+                               static_cast<size_t>(DVC_CHANNELS)},
+        webrtc::AudioCodecInfo{rate, static_cast<size_t>(DVC_CHANNELS),
+                               DVC_BITRATE}});
+  }
+}
+
+std::unique_ptr<webrtc::AudioDecoder> AudioDecoderDVC::MakeAudioDecoder(
+    Config config,
+    absl::optional<webrtc::AudioCodecPairId> codec_pair_id) {
+  return absl::make_unique<AudioDecoderDVCImpl>(config);
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
diff --git a/third_party/webrtc/dvc/api/audio_codecs/dvc/audio_decoder_dvc.h b/third_party/webrtc/dvc/api/audio_codecs/dvc/audio_decoder_dvc.h
new file mode 100644
index 00000000000..47107bf5d75
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/dvc/audio_decoder_dvc.h
@@ -0,0 +1,33 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef DVC_API_AUDIO_CODECS_DVC_AUDIO_DECODER_DVC_H_
+#define DVC_API_AUDIO_CODECS_DVC_AUDIO_DECODER_DVC_H_
+
+#include <memory>
+#include <vector>
+
+#include "api/audio_codecs/audio_decoder.h"
+#include "api/audio_codecs/audio_format.h"
+#include "api/audio_codecs/audio_codec_pair_id.h"
+#include "absl/types/optional.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+struct AudioDecoderDVC {
+  using Config = webrtc::SdpAudioFormat;
+  static absl::optional<Config> SdpToConfig(
+      const webrtc::SdpAudioFormat& audio_format);
+  static void AppendSupportedDecoders(
+      std::vector<webrtc::AudioCodecSpec>* specs);
+  static std::unique_ptr<webrtc::AudioDecoder> MakeAudioDecoder(
+      Config config,
+      absl::optional<webrtc::AudioCodecPairId> codec_pair_id = absl::nullopt);
+};
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif  // DVC_API_AUDIO_CODECS_DVC_AUDIO_DECODER_DVC_H_
diff --git a/third_party/webrtc/dvc/api/audio_codecs/dvc/audio_encoder_dvc.cc b/third_party/webrtc/dvc/api/audio_codecs/dvc/audio_encoder_dvc.cc
new file mode 100644
index 00000000000..1dab78e7887
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/dvc/audio_encoder_dvc.cc
@@ -0,0 +1,48 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/api/audio_codecs/dvc/audio_encoder_dvc.h"
+
+#include "common_types.h"
+#include "absl/memory/memory.h"
+#include "rtc_base/string_to_number.h"
+
+#include "dolby/services/dolby_voice_client/vars.h"
+#include "dvc/api/audio_codecs/dvc/dvcaudioencoderimpl.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+absl::optional<AudioEncoderDVC::Config> AudioEncoderDVC::SdpToConfig(
+    const webrtc::SdpAudioFormat& format) {
+  return absl::optional<webrtc::SdpAudioFormat>(format);
+}
+
+void AudioEncoderDVC::AppendSupportedEncoders(
+    std::vector<webrtc::AudioCodecSpec>* specs) {
+  for (auto rate : DVC_SAMPLING_RATES) {
+    const webrtc::SdpAudioFormat fmt = {getDolbyValueOr(
+                                          switches::kDvcCodecName,
+                                          webrtc_integration::DVC_CODEC_NAME),
+                                        rate,
+                                        static_cast<size_t>(DVC_CHANNELS)};
+    const webrtc::AudioCodecInfo info = QueryAudioEncoder(*SdpToConfig(fmt));
+    specs->push_back({fmt, info});
+  }
+}
+
+webrtc::AudioCodecInfo AudioEncoderDVC::QueryAudioEncoder(
+    const AudioEncoderDVC::Config& config) {
+  return {config.clockrate_hz, static_cast<size_t>(DVC_CHANNELS), DVC_BITRATE};
+}
+
+std::unique_ptr<webrtc::AudioEncoder> AudioEncoderDVC::MakeAudioEncoder(
+    const AudioEncoderDVC::Config& config,
+    int payload_type,
+    absl::optional<webrtc::AudioCodecPairId> codec_pair_id) {
+  return absl::make_unique<AudioEncoderDVCImpl>(payload_type, config);
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
diff --git a/third_party/webrtc/dvc/api/audio_codecs/dvc/audio_encoder_dvc.h b/third_party/webrtc/dvc/api/audio_codecs/dvc/audio_encoder_dvc.h
new file mode 100644
index 00000000000..a298fd356ae
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/dvc/audio_encoder_dvc.h
@@ -0,0 +1,35 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef DVC_API_AUDIO_CODECS_DVC_AUDIO_ENCODER_DVC_H_
+#define DVC_API_AUDIO_CODECS_DVC_AUDIO_ENCODER_DVC_H_
+
+#include <memory>
+#include <vector>
+
+#include "api/audio_codecs/audio_encoder.h"
+#include "api/audio_codecs/audio_format.h"
+#include "api/audio_codecs/audio_codec_pair_id.h"
+#include "absl/types/optional.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+struct AudioEncoderDVC {
+  using Config = webrtc::SdpAudioFormat;
+  static absl::optional<Config> SdpToConfig(
+      const webrtc::SdpAudioFormat& audio_format);
+  static void AppendSupportedEncoders(
+      std::vector<webrtc::AudioCodecSpec>* specs);
+  static webrtc::AudioCodecInfo QueryAudioEncoder(const Config& config);
+  static std::unique_ptr<webrtc::AudioEncoder> MakeAudioEncoder(
+      const Config& config,
+      int payload_type,
+      absl::optional<webrtc::AudioCodecPairId> codec_pair_id = absl::nullopt);
+};
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif  // DVC_API_AUDIO_CODECS_DVC_AUDIO_ENCODER_DVC_H_
diff --git a/third_party/webrtc/dvc/api/audio_codecs/dvc/dvcaudiodecoderimpl.cc b/third_party/webrtc/dvc/api/audio_codecs/dvc/dvcaudiodecoderimpl.cc
new file mode 100644
index 00000000000..22591ced4fe
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/dvc/dvcaudiodecoderimpl.cc
@@ -0,0 +1,39 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/api/audio_codecs/dvc/dvcaudiodecoderimpl.h"
+
+#include "dvc/dvc_constants.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+AudioDecoderDVCImpl::AudioDecoderDVCImpl(const webrtc::SdpAudioFormat& format)
+    : clock_rate_hz_(format.clockrate_hz) {}
+
+void AudioDecoderDVCImpl::Reset() {}
+
+int AudioDecoderDVCImpl::SampleRateHz() const {
+  return clock_rate_hz_;
+}
+
+size_t AudioDecoderDVCImpl::Channels() const {
+  return DVC_CHANNELS;
+}
+
+int AudioDecoderDVCImpl::PacketDuration(const uint8_t*, size_t) const {
+  return DVC_NUMBER_10MS_FRAMES_IN_PACKET * clock_rate_hz_ / 100;
+}
+
+int AudioDecoderDVCImpl::DecodeInternal(const uint8_t* encoded,
+                                        size_t encoded_len,
+                                        int sample_rate_hz,
+                                        int16_t* decoded,
+                                        SpeechType* speech_type) {
+  RTC_NOTREACHED();
+  return 0;
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
diff --git a/third_party/webrtc/dvc/api/audio_codecs/dvc/dvcaudiodecoderimpl.h b/third_party/webrtc/dvc/api/audio_codecs/dvc/dvcaudiodecoderimpl.h
new file mode 100644
index 00000000000..a9b1eb3ac5b
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/dvc/dvcaudiodecoderimpl.h
@@ -0,0 +1,34 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef DVC_API_AUDIO_CODECS_DVC_AUDIO_DECODER_DVC_IMPL_H_
+#define DVC_API_AUDIO_CODECS_DVC_AUDIO_DECODER_DVC_IMPL_H_
+
+#include "api/audio_codecs/audio_format.h"
+#include "modules/audio_coding/codecs/audio_decoder.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+class AudioDecoderDVCImpl final : public webrtc::AudioDecoder {
+ public:
+  AudioDecoderDVCImpl(const webrtc::SdpAudioFormat& format);
+  void Reset() override;
+  int SampleRateHz() const override;
+  size_t Channels() const override;
+  int PacketDuration(const uint8_t* encoded, size_t encoded_len) const override;
+
+ protected:
+  int DecodeInternal(const uint8_t* encoded,
+                     size_t encoded_len,
+                     int sample_rate_hz,
+                     int16_t* decoded,
+                     SpeechType* speech_type) override;
+  int clock_rate_hz_;
+};
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif  // DVC_API_AUDIO_CODECS_DVC_AUDIO_DECODER_DVC_IMPL_H_
diff --git a/third_party/webrtc/dvc/api/audio_codecs/dvc/dvcaudioencoderimpl.cc b/third_party/webrtc/dvc/api/audio_codecs/dvc/dvcaudioencoderimpl.cc
new file mode 100644
index 00000000000..67149f94a13
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/dvc/dvcaudioencoderimpl.cc
@@ -0,0 +1,77 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/api/audio_codecs/dvc/dvcaudioencoderimpl.h"
+
+#include "absl/strings/match.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+absl::optional<webrtc::AudioCodecInfo> AudioEncoderDVCImpl::QueryAudioEncoder(
+    const webrtc::SdpAudioFormat& format) {
+  if (absl::EqualsIgnoreCase(format.name.c_str(), GetPayloadName())) {
+    for (auto rate : DVC_SAMPLING_RATES) {
+      if (format.clockrate_hz == rate)
+        return absl::optional<webrtc::AudioCodecInfo>(
+            {rate, static_cast<size_t>(DVC_CHANNELS), DVC_BITRATE});
+    }
+  }
+  return absl::optional<webrtc::AudioCodecInfo>();
+}
+
+AudioEncoderDVCImpl::AudioEncoderDVCImpl(int payload_type,
+                                         const webrtc::SdpAudioFormat& format)
+    : clock_rate_hz_(format.clockrate_hz) {}
+
+AudioEncoderDVCImpl::~AudioEncoderDVCImpl() = default;
+
+int AudioEncoderDVCImpl::SampleRateHz() const {
+  return clock_rate_hz_;
+}
+
+size_t AudioEncoderDVCImpl::NumChannels() const {
+  return DVC_CHANNELS;
+}
+
+int AudioEncoderDVCImpl::RtpTimestampRateHz() const {
+  return clock_rate_hz_;
+}
+
+size_t AudioEncoderDVCImpl::Num10MsFramesInNextPacket() const {
+  return DVC_NUMBER_10MS_FRAMES_IN_PACKET;
+}
+
+size_t AudioEncoderDVCImpl::Max10MsFramesInAPacket() const {
+  return DVC_NUMBER_10MS_FRAMES_IN_PACKET;
+}
+
+int AudioEncoderDVCImpl::GetTargetBitrate() const {
+  return DVC_BITRATE;
+}
+
+void AudioEncoderDVCImpl::Reset() {}
+
+bool AudioEncoderDVCImpl::SetFec(bool enable) {
+  return true;
+}
+
+bool AudioEncoderDVCImpl::SetDtx(bool enable) {
+  return true;
+}
+
+bool AudioEncoderDVCImpl::SetApplication(Application application) {
+  return true;
+}
+
+webrtc::AudioEncoder::EncodedInfo AudioEncoderDVCImpl::EncodeImpl(
+    uint32_t rtp_timestamp,
+    rtc::ArrayView<const int16_t> audio,
+    rtc::Buffer* encoded) {
+  RTC_NOTREACHED();
+  return EncodedInfo();
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
diff --git a/third_party/webrtc/dvc/api/audio_codecs/dvc/dvcaudioencoderimpl.h b/third_party/webrtc/dvc/api/audio_codecs/dvc/dvcaudioencoderimpl.h
new file mode 100644
index 00000000000..baa01e3dec9
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/dvc/dvcaudioencoderimpl.h
@@ -0,0 +1,52 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef DVC_API_AUDIO_CODECS_DVC_AUDIO_ENCODER_DVC_IMPL_H_
+#define DVC_API_AUDIO_CODECS_DVC_AUDIO_ENCODER_DVC_IMPL_H_
+
+#include "api/audio_codecs/audio_format.h"
+#include "common_types.h"
+#include "modules/audio_coding/codecs/audio_encoder.h"
+
+#include "dolby/services/dolby_voice_client/vars.h"
+#include "dvc/dvc_constants.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+class AudioEncoderDVCImpl : public webrtc::AudioEncoder {
+ public:
+  AudioEncoderDVCImpl(int payload_type, const webrtc::SdpAudioFormat& format);
+
+  ~AudioEncoderDVCImpl() override;
+
+  static std::string GetPayloadName() {
+    return getDolbyValueOr(switches::kDvcCodecName,
+                           webrtc_integration::DVC_CODEC_NAME);
+  }
+  static absl::optional<webrtc::AudioCodecInfo> QueryAudioEncoder(
+      const webrtc::SdpAudioFormat& format);
+
+  int SampleRateHz() const override;
+  size_t NumChannels() const override;
+  int RtpTimestampRateHz() const override;
+  size_t Num10MsFramesInNextPacket() const override;
+  size_t Max10MsFramesInAPacket() const override;
+  int GetTargetBitrate() const override;
+  void Reset() override;
+  bool SetFec(bool enable) override;
+  bool SetDtx(bool enable) override;
+  bool SetApplication(Application application) override;
+
+ protected:
+  EncodedInfo EncodeImpl(uint32_t rtp_timestamp,
+                         rtc::ArrayView<const int16_t> audio,
+                         rtc::Buffer* encoded) override;
+  int clock_rate_hz_;
+};
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif  // DVC_API_AUDIO_CODECS_DVC_AUDIO_ENCODER_DVC_IMPL_H_
diff --git a/third_party/webrtc/dvc/api/audio_codecs/dvcaudiocodecfactories.cc b/third_party/webrtc/dvc/api/audio_codecs/dvcaudiocodecfactories.cc
new file mode 100644
index 00000000000..dad5e7e0f31
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/dvcaudiocodecfactories.cc
@@ -0,0 +1,148 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/api/audio_codecs/dvcaudiocodecfactories.h"
+
+#include <memory>
+#include <vector>
+
+#include "absl/memory/memory.h"
+
+#include "api/audio_codecs/L16/audio_decoder_L16.h"
+#include "api/audio_codecs/audio_decoder_factory_template.h"
+#include "api/audio_codecs/g711/audio_decoder_g711.h"
+#include "api/audio_codecs/g722/audio_decoder_g722.h"  // nogncheck
+#include "api/audio_codecs/isac/audio_decoder_isac.h"
+#include "api/audio_codecs/opus/audio_decoder_opus.h"
+#include "api/audio_codecs/L16/audio_encoder_L16.h"
+#include "api/audio_codecs/audio_encoder_factory_template.h"
+#include "api/audio_codecs/g711/audio_encoder_g711.h"
+#include "api/audio_codecs/g722/audio_encoder_g722.h"  // nogncheck
+#include "api/audio_codecs/isac/audio_encoder_isac.h"
+#include "api/audio_codecs/opus/audio_encoder_opus.h"
+
+#if WEBRTC_USE_BUILTIN_ILBC
+#include "api/audio_codecs/ilbc/audio_decoder_ilbc.h"  // nogncheck
+#include "api/audio_codecs/ilbc/audio_encoder_ilbc.h"  // nogncheck
+#endif
+
+#include "dvc/api/audio_codecs/donothingaudiodecoderadapter.h"
+#include "dvc/api/audio_codecs/donothingaudioencoderadapter.h"
+
+#include "dvc/api/audio_codecs/dvc/audio_decoder_dvc.h"
+#include "dvc/api/audio_codecs/dvc/audio_encoder_dvc.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+namespace {
+
+template <typename T>
+struct DoNothingDecoder {
+  using Config = typename T::Config;
+  static absl::optional<Config> SdpToConfig(
+      const webrtc::SdpAudioFormat& audio_format) {
+    return T::SdpToConfig(audio_format);
+  }
+  static void AppendSupportedDecoders(
+      std::vector<webrtc::AudioCodecSpec>* specs) {
+    T::AppendSupportedDecoders(specs);
+  }
+  static std::unique_ptr<webrtc::AudioDecoder> MakeAudioDecoder(
+      const Config& config,
+      absl::optional<webrtc::AudioCodecPairId> codec_pair_id = absl::nullopt) {
+    std::unique_ptr<webrtc::AudioDecoder> decoder = T::MakeAudioDecoder(config, codec_pair_id);
+    if (!decoder)
+      return nullptr;
+    return absl::make_unique<DoNothingDecoderAdapter>(std::move(decoder));
+  }
+};
+
+template <typename T>
+struct DoNothingEncoder {
+  using Config = typename T::Config;
+  static absl::optional<Config> SdpToConfig(
+      const webrtc::SdpAudioFormat& audio_format) {
+    return T::SdpToConfig(audio_format);
+  }
+  static void AppendSupportedEncoders(
+      std::vector<webrtc::AudioCodecSpec>* specs) {
+    T::AppendSupportedEncoders(specs);
+  }
+  static webrtc::AudioCodecInfo QueryAudioEncoder(const Config& config) {
+    return T::QueryAudioEncoder(config);
+  }
+  static std::unique_ptr<webrtc::AudioEncoder> MakeAudioEncoder(
+      const Config& config,
+      int payload_type,
+      absl::optional<webrtc::AudioCodecPairId> codec_pair_id = absl::nullopt) {
+    webrtc::AudioEncoder::CodecType codec_type =
+        webrtc::AudioEncoder::CodecType::kMaxLoggedAudioCodecTypes;
+    if (std::is_same<T, AudioEncoderDVC>::value) {
+      codec_type = webrtc::AudioEncoder::CodecType::kOther;
+    } else if (std::is_same<T, webrtc::AudioEncoderG722>::value) {
+      codec_type = webrtc::AudioEncoder::CodecType::kG722;
+    }
+#if WEBRTC_USE_BUILTIN_ILBC
+    else if (std::is_same<T, webrtc::AudioEncoderIlbc>::value) {
+      codec_type = webrtc::AudioEncoder::CodecType::kIlbc;
+    }
+#endif
+    else if (std::is_same<T, webrtc::AudioEncoderG711>::value) {
+      codec_type = (payload_type == 0 ? webrtc::AudioEncoder::CodecType::kPcmU
+                                      : webrtc::AudioEncoder::CodecType::kPcmA);
+    }
+
+    RTC_DCHECK(codec_type !=
+               webrtc::AudioEncoder::CodecType::
+                   kMaxLoggedAudioCodecTypes);  // Unrecognized codec!
+
+    std::unique_ptr<webrtc::AudioEncoder> encoder =
+        T::MakeAudioEncoder(config, payload_type, codec_pair_id);
+    if (!encoder)
+      return nullptr;
+    return absl::make_unique<DoNothingEncoderAdapter>(std::move(encoder),
+                                                    codec_type, payload_type);
+  }
+};
+
+}  // namespace
+
+rtc::scoped_refptr<webrtc::AudioDecoderFactory> CreateDVCAudioDecoderFactory() {
+  using namespace webrtc;
+
+  return CreateAudioDecoderFactory<
+#if WEBRTC_USE_BUILTIN_OPUS
+      AudioDecoderOpus,
+#endif
+
+      AudioDecoderIsac, AudioDecoderG722,
+
+#if WEBRTC_USE_BUILTIN_ILBC
+      AudioDecoderIlbc,
+#endif
+
+      AudioDecoderG711, DoNothingDecoder<AudioDecoderDVC>>();
+}
+
+rtc::scoped_refptr<webrtc::AudioEncoderFactory> CreateDVCAudioEncoderFactory() {
+  using namespace webrtc;
+
+  return CreateAudioEncoderFactory<
+#if WEBRTC_USE_BUILTIN_OPUS
+      AudioEncoderOpus,
+#endif
+
+      AudioEncoderIsac, AudioEncoderG722,
+
+#if WEBRTC_USE_BUILTIN_ILBC
+      AudioEncoderIlbc,
+#endif
+
+      AudioEncoderG711, DoNothingEncoder<AudioEncoderDVC>>();
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
diff --git a/third_party/webrtc/dvc/api/audio_codecs/dvcaudiocodecfactories.h b/third_party/webrtc/dvc/api/audio_codecs/dvcaudiocodecfactories.h
new file mode 100644
index 00000000000..34b13e5a375
--- /dev/null
+++ b/third_party/webrtc/dvc/api/audio_codecs/dvcaudiocodecfactories.h
@@ -0,0 +1,21 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef DVC_API_AUDIO_CODECS_DVCAUDIOCODECFACTORIES_H_
+#define DVC_API_AUDIO_CODECS_DVCAUDIOCODECFACTORIES_H_
+
+#include "api/audio_codecs/audio_decoder_factory.h"
+#include "api/audio_codecs/audio_encoder_factory.h"
+#include "api/scoped_refptr.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+rtc::scoped_refptr<webrtc::AudioEncoderFactory> CreateDVCAudioEncoderFactory();
+rtc::scoped_refptr<webrtc::AudioDecoderFactory> CreateDVCAudioDecoderFactory();
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif  // DVC_API_AUDIO_CODECS_DVCAUDIOCODECFACTORIES_H_
diff --git a/third_party/webrtc/dvc/audiobufferqueue.cc b/third_party/webrtc/dvc/audiobufferqueue.cc
new file mode 100644
index 00000000000..11e51a3fe13
--- /dev/null
+++ b/third_party/webrtc/dvc/audiobufferqueue.cc
@@ -0,0 +1,105 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/audiobufferqueue.h"
+
+#include <algorithm>
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+AudioBuffer::AudioBuffer(size_t size) : AudioBuffer(size, size) {}
+
+AudioBuffer::AudioBuffer(size_t size, size_t capacity)
+    : payload(size, size), receive_time_ms_(0), profile_timestamp_ms_(0) {}
+
+AudioBuffer::AudioBuffer(const AudioBuffer& rhs) : payload(rhs.payload.size()) {
+  this->payload.SetData(rhs.payload);
+  this->rtp_header_ = rhs.rtp_header_;
+  this->receive_time_ms_ = rhs.receive_time_ms_;
+  this->profile_timestamp_ms_ = rhs.profile_timestamp_ms_;
+}
+
+AudioBufferQueue::AudioBufferQueue(size_t capacity, size_t default_size)
+    : capacity_(capacity), default_size_(default_size) {}
+
+AudioBufferQueue::~AudioBufferQueue() {
+  rtc::CritScope cs(&crit_);
+
+  for (AudioBuffer* buffer : queue_) {
+    delete buffer;
+  }
+  for (AudioBuffer* buffer : free_list_) {
+    delete buffer;
+  }
+}
+
+size_t AudioBufferQueue::size() const {
+  rtc::CritScope cs(&crit_);
+  return queue_.size();
+}
+
+void AudioBufferQueue::Clear() {
+  rtc::CritScope cs(&crit_);
+  while (!queue_.empty()) {
+    free_list_.push_back(queue_.front());
+    queue_.pop_front();
+  }
+}
+
+bool AudioBufferQueue::GetEnqueuedAudioBuffers(
+    std::vector<AudioBuffer>& buffers) {
+  size_t queue_size = 0;
+  {
+    rtc::CritScope cs(&crit_);
+    queue_size = queue_.size();
+  }
+
+  if (queue_size == 0) {
+    return false;
+  }
+
+  while (queue_size > 0) {
+    rtc::CritScope cs(&crit_);
+    AudioBuffer* packet = queue_.front();
+    queue_.pop_front();
+    AudioBuffer audio_buffer(*packet);
+    buffers.push_back(std::move(audio_buffer));
+    free_list_.push_back(packet);
+    queue_size--;
+  }
+  return true;
+}
+
+bool AudioBufferQueue::WriteBack(const webrtc::RTPHeader& rtp_header,
+                                 int64_t receive_time_ms,
+                                 const void* buffer,
+                                 size_t bytes,
+                                 size_t* bytes_written) {
+  rtc::CritScope cs(&crit_);
+  if (queue_.size() == capacity_) {
+    return false;
+  }
+
+  AudioBuffer* packet;
+  if (!free_list_.empty()) {
+    packet = free_list_.back();
+    free_list_.pop_back();
+  } else {
+    packet = new AudioBuffer(bytes, default_size_);
+  }
+
+  packet->rtp_header_ = rtp_header;
+  packet->receive_time_ms_ = receive_time_ms;
+  packet->payload.SetData(static_cast<const uint8_t*>(buffer), bytes);
+  packet->UpdateProfileTimeStamp();
+  if (bytes_written) {
+    *bytes_written = bytes;
+  }
+  queue_.push_back(packet);
+  return true;
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
diff --git a/third_party/webrtc/dvc/audiobufferqueue.h b/third_party/webrtc/dvc/audiobufferqueue.h
new file mode 100644
index 00000000000..b6e5077321f
--- /dev/null
+++ b/third_party/webrtc/dvc/audiobufferqueue.h
@@ -0,0 +1,93 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+/*
+ * This class is inspired by the BufferQueue from WebRTC rtc_base component
+ * and tuned for our needs.
+ */
+
+#ifndef WEBRTC_DVC_AUDIO_BUFFER_QUEUE_H_
+#define WEBRTC_DVC_AUDIO_BUFFER_QUEUE_H_
+
+#include <deque>
+#include <vector>
+
+#include "api/rtp_headers.h"
+#include "rtc_base/buffer.h"
+#include "rtc_base/constructor_magic.h"
+#include "rtc_base/critical_section.h"
+#include "rtc_base/time_utils.h"
+
+#include "common_types.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+class AudioBuffer {
+ public:
+  AudioBuffer(size_t size);
+  AudioBuffer(size_t size, size_t capacity);
+  AudioBuffer(const AudioBuffer& rhs);
+  virtual ~AudioBuffer() = default;
+
+  // Sets a wall-time clock timestamp in milliseconds to be used for profiling
+  // of time between two points in the audio chain.
+  // Example:
+  //   t0: UpdateProfileTimeStamp()
+  //   t1: ElapsedProfileTimeMs() => t1 - t0 [msec]
+  void UpdateProfileTimeStamp();
+  // Returns the time difference between now and when UpdateProfileTimeStamp()
+  // was last called. Returns -1 if UpdateProfileTimeStamp() has not yet been
+  // called.
+  int64_t ElapsedProfileTimeMs() const;
+
+  rtc::Buffer payload;
+  webrtc::RTPHeader rtp_header_;
+  int64_t receive_time_ms_ = 0;
+  int64_t profile_timestamp_ms_ = 0;
+};
+
+inline void AudioBuffer::UpdateProfileTimeStamp() {
+  profile_timestamp_ms_ = rtc::TimeMillis();
+}
+
+inline int64_t AudioBuffer::ElapsedProfileTimeMs() const {
+  if (profile_timestamp_ms_ == 0) {
+    // Profiling has not been activated.
+    return -1;
+  }
+  return rtc::TimeSince(profile_timestamp_ms_);
+}
+
+class AudioBufferQueue {
+ public:
+  // Creates an audio buffer queue with a given capacity and default buffer
+  // size.
+  AudioBufferQueue(size_t capacity, size_t default_size);
+  virtual ~AudioBufferQueue();
+
+  size_t size() const;
+  void Clear();
+
+  bool GetEnqueuedAudioBuffers(std::vector<AudioBuffer>& buffers);
+  bool WriteBack(const webrtc::RTPHeader& rtp_header,
+                 int64_t receive_time_ms,
+                 const void* data,
+                 size_t bytes,
+                 size_t* bytes_written);
+
+ private:
+  size_t capacity_;
+  size_t default_size_;
+  rtc::CriticalSection crit_;
+  std::deque<AudioBuffer*> queue_ RTC_GUARDED_BY(crit_);
+  std::vector<AudioBuffer*> free_list_ RTC_GUARDED_BY(crit_);
+
+  RTC_DISALLOW_COPY_AND_ASSIGN(AudioBufferQueue);
+};
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif  // WEBRTC_DVC_AUDIO_BUFFER_QUEUE_H_
diff --git a/third_party/webrtc/dvc/audiopackethandler.cc b/third_party/webrtc/dvc/audiopackethandler.cc
new file mode 100644
index 00000000000..376fd0e3e00
--- /dev/null
+++ b/third_party/webrtc/dvc/audiopackethandler.cc
@@ -0,0 +1,91 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/audiopackethandler.h"
+#include "dvc/dvc_constants.h"
+
+#include "rtc_base/logging.h"
+#include "modules/rtp_rtcp/source/rtp_utility.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+AudioPacketHandler::AudioPacketHandler(
+    std::unique_ptr<DvcConference> conference)
+    : _packets_to_send(kMaxPendingPackets, kMaxRtpPacketLen),
+      conference_(std::move(conference)) {
+  conference_->SetRtpSink(*this);
+}
+
+AudioPacketHandler::~AudioPacketHandler() = default;
+
+void AudioPacketHandler::SendRtp(const char* data,
+                                 size_t len,
+                                 int64_t system_time_us) {
+  HandleRtpPacketToSend(reinterpret_cast<const uint8_t*>(data), len,
+                        system_time_us);
+}
+
+void AudioPacketHandler::HandleReceivedRtpPacket(const uint8_t* data,
+                                                 size_t len) {
+  conference_->HandleReceivedRtpPacket(reinterpret_cast<const char*>(data),
+                                       static_cast<unsigned int>(len));
+}
+
+bool AudioPacketHandler::GetAudioSessionStats(DvcStats& stats) {
+  return conference_->GetAudioSessionStats(stats);
+}
+
+void AudioPacketHandler::SetMinimumPlayoutDelay(int delay_ms) {
+  conference_->SetMinimumPlayoutDelay(delay_ms);
+}
+
+bool AudioPacketHandler::HandleReceivedRtcpPacket(const uint8_t*, size_t) {
+  // Ignore RTCP
+  return false;
+}
+
+bool AudioPacketHandler::HandleRtpPacketToSend(const uint8_t* data,
+                                               size_t len,
+                                               int64_t system_time_us) {
+  webrtc::RtpUtility::RtpHeaderParser rtp_parser(data, len);
+  webrtc::RTPHeader header;
+  if (data != nullptr && !rtp_parser.Parse(&header, nullptr, false)) {
+    RTC_LOG_F(LS_ERROR) << "Unable to parse RTP header!";
+    return false;
+  }
+  const uint8_t* payload = data + header.headerLength;
+  size_t payload_length = len - header.headerLength;
+
+  int64_t receive_time_ms = system_time_us / 1000;
+
+  size_t bytes_written = 0;
+  if (!_packets_to_send.WriteBack(header, receive_time_ms, payload,
+                                  payload_length, &bytes_written)) {
+    RTC_LOG(LS_WARNING) << "Packet queue full, dropping RTP packet!";
+  }
+  return true;
+}
+
+bool AudioPacketHandler::HandleRtcpPacketToSend(const uint8_t* data,
+                                                size_t len) {
+  // Ignore RTCP
+  return false;
+}
+
+bool AudioPacketHandler::GetPacketsToSend(
+    std::vector<AudioBuffer>& audio_buffers) {
+  return _packets_to_send.GetEnqueuedAudioBuffers(audio_buffers);
+}
+
+AudioBufferQueue& AudioPacketHandler::packets_to_send() {
+  return _packets_to_send;
+}
+
+void AudioPacketHandler::SetMute(bool mute) {
+  conference_->SetMute(mute);
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
diff --git a/third_party/webrtc/dvc/audiopackethandler.h b/third_party/webrtc/dvc/audiopackethandler.h
new file mode 100644
index 00000000000..25a351aff38
--- /dev/null
+++ b/third_party/webrtc/dvc/audiopackethandler.h
@@ -0,0 +1,54 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef WEBRTC_DVC_AUDIO_PACKET_HANDLER_H_
+#define WEBRTC_DVC_AUDIO_PACKET_HANDLER_H_
+
+#include "rtc_base/buffer_queue.h"
+#include "rtc_base/copy_on_write_buffer.h"
+#include "rtc_base/critical_section.h"
+#include "rtc_base/thread.h"
+#include "rtc_base/thread_checker.h"
+
+#include "dvc/audiobufferqueue.h"
+#include "dvc/common.h"
+#include "dvc/dvc_conference_factory.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+class AudioPacketHandler : public DvcConference::RtpSink {
+ public:
+  AudioPacketHandler(std::unique_ptr<DvcConference> conference);
+  ~AudioPacketHandler() override;
+
+  void HandleReceivedRtpPacket(const uint8_t* data, size_t len);
+  bool GetAudioSessionStats(DvcStats& stats);
+  void SetMinimumPlayoutDelay(int delay_ms);
+
+  bool HandleReceivedRtcpPacket(const uint8_t* data, size_t len);
+  bool HandleRtcpPacketToSend(const uint8_t* data, size_t len);
+
+  bool GetPacketsToSend(std::vector<AudioBuffer>& packets);
+  AudioBufferQueue& packets_to_send();
+  void SetMute(bool mute);
+
+  DvcConference* GetConference() { return conference_.get(); }
+
+  // DvcConference::RtpSink
+  void SendRtp(const char* data, size_t len, int64_t system_time_us) override;
+
+ private:
+  bool HandleRtpPacketToSend(const uint8_t* data,
+                             size_t len,
+                             int64_t systime_us);
+
+  AudioBufferQueue _packets_to_send;  // generated by audio session
+  std::unique_ptr<DvcConference> conference_;
+};
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif /* WEBRTC_DVC_AUDIO_PACKET_HANDLER_H_ */
diff --git a/third_party/webrtc/dvc/audiosession.cc b/third_party/webrtc/dvc/audiosession.cc
new file mode 100644
index 00000000000..f56dcb673f7
--- /dev/null
+++ b/third_party/webrtc/dvc/audiosession.cc
@@ -0,0 +1,202 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/audiosession.h"
+
+#include "dolby/services/dolby_voice_client/vars.h"
+#include "dvc/dvc_conference_factory.h"
+#include "dvc/dvc_constants.h"
+
+#include "absl/strings/match.h"
+#include "rtc_base/bind.h"
+#include "rtc_base/string_utils.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+namespace {
+
+std::string CodecName(const DvcAudioCodec& codec) {
+  switch (codec.encoding) {
+    case DvcRTPEncoding::DVC2:
+      return getDolbyValueOr(switches::kDvcCodecName,
+                             webrtc_integration::DVC_CODEC_NAME);
+    case DvcRTPEncoding::PCMU:
+      return "PCMU";
+    case DvcRTPEncoding::PCMA:
+      return "PCMA";
+    case DvcRTPEncoding::G722:
+      return "G722";
+    case DvcRTPEncoding::TELEPHONE_EVENT:
+      return "telephone-event";
+  }
+  RTC_NOTREACHED();
+  return "unknown";
+}
+
+int Bitrate(const DvcAudioCodec& codec) {
+  switch (codec.encoding) {
+    case DvcRTPEncoding::DVC2:
+      return DVC_BITRATE;
+    case DvcRTPEncoding::PCMU:
+    case DvcRTPEncoding::PCMA:
+    case DvcRTPEncoding::G722:
+      return 8000;
+    case DvcRTPEncoding::TELEPHONE_EVENT:
+      return 0;
+  }
+  RTC_NOTREACHED();
+  return -1;
+}
+
+int Channels(const DvcAudioCodec& codec) {
+  switch (codec.encoding) {
+    case DvcRTPEncoding::DVC2:
+      return DVC_CHANNELS;
+    case DvcRTPEncoding::PCMU:
+    case DvcRTPEncoding::PCMA:
+    case DvcRTPEncoding::G722:
+    case DvcRTPEncoding::TELEPHONE_EVENT:
+      return 1;
+  }
+  RTC_NOTREACHED();
+  return -1;
+}
+
+cricket::AudioCodec Convert(const DvcAudioCodec& codec) {
+  cricket::AudioCodec ret(codec.rtp_payload_type, CodecName(codec),
+                          codec.clock_rate, Bitrate(codec), Channels(codec));
+  ret.SetDvc2Params(codec);
+  return ret;
+}
+
+DvcRTPEncoding CodecToRtpEncoding(const cricket::AudioCodec& codec) {
+  if (absl::EqualsIgnoreCase(
+    codec.name,
+    getDolbyValueOr(switches::kDvcCodecName,
+                    webrtc_integration::DVC_CODEC_NAME)))
+    return DvcRTPEncoding::DVC2;
+  if (absl::EqualsIgnoreCase(codec.name, "PCMU"))
+    return DvcRTPEncoding::PCMU;
+  if (absl::EqualsIgnoreCase(codec.name, "PCMA"))
+    return DvcRTPEncoding::PCMA;
+  if (absl::EqualsIgnoreCase(codec.name, "G722"))
+    return DvcRTPEncoding::G722;
+  if (absl::EqualsIgnoreCase(codec.name, "telephone-event"))
+    return DvcRTPEncoding::TELEPHONE_EVENT;
+
+  return static_cast<DvcRTPEncoding>(-1);
+}
+
+DvcAudioCodec Convert(const cricket::AudioCodec& codec) {
+  DvcAudioCodec ret{};
+  ret.encoding = CodecToRtpEncoding(codec);
+  ret.clock_rate = codec.clockrate;
+  ret.rtp_payload_type = codec.id;
+  if (ret.encoding == DvcRTPEncoding::DVC2) {
+    ret.has_dvc2_params = codec.HasDvc2Params();
+  }
+  if (ret.has_dvc2_params) {
+    ret.dvc2_source_side = codec.Dvc2SourceSide();
+    ret.dvc2_protocol_version = codec.Dvc2ProtocolVersion();
+  } else {
+    // need to provide dummy, but valid values:
+    ret.dvc2_source_side = DVC2SourceSide::CLIENT;
+    ret.dvc2_protocol_version = 0;
+  }
+  return ret;
+}
+}  // namespace
+
+AudioSession::AudioSession() : listener_(nullptr), dvc_(nullptr) {}
+
+AudioSession::~AudioSession() {
+  if (IsInitialized()) {
+    if (listener_)
+      listener_->OnAudioSessionSessionDisconnected(*this, "DVC audio session destroyed");
+  }
+}
+
+bool AudioSession::Initialize(Listener* listener, std::string& err_desc) {
+  if (IsInitialized()) {
+    err_desc = "Already initialized";
+    return false;
+  }
+
+  listener_ = listener;
+
+  dvc_ = DvcConferenceFactory::GetGlobalInstance();
+
+  if (dvc_ == nullptr) {
+    err_desc = "Initializing DVC conference factory failed";
+    return false;
+  }
+
+  dvc_codecs_.clear();
+  std::vector<DvcAudioCodec> codecs;
+  if (dvc_->GetAudioCodecsList(codecs)) {
+    for (const auto& codec : codecs) {
+      dvc_codecs_.emplace_back(Convert(codec));
+    }
+  } else {
+    err_desc = "Unable to get any audio codecs from DVC";
+    return false;
+  }
+
+  if (!EnsureConference()) {
+    err_desc = "Can not create conference client";
+    return false;
+  }
+
+  return true;
+}
+
+bool AudioSession::EnsureConference() {
+  if (!packet_handler_) {
+    auto conference = dvc_->CreateConference();
+    if (!conference)
+      return false;
+
+    conference->SetConnectionBrokenListener(this);
+    packet_handler_.reset(new AudioPacketHandler(std::move(conference)));
+  }
+  return true;
+}
+
+void AudioSession::Shutdown() {
+  listener_ = nullptr;
+  dvc_ = nullptr;
+  packet_handler_.reset();
+}
+
+bool AudioSession::Update(const cricket::AudioCodec& codec,
+                          std::string& err_desc) {
+  return packet_handler_->GetConference()->Update(Convert(codec), err_desc);
+}
+
+void AudioSession::Stop() {
+  if (packet_handler_)
+    packet_handler_->GetConference()->Stop();
+}
+
+AudioPacketHandler* AudioSession::GetAudioPacketHandler() {
+  return packet_handler_.get();
+}
+
+const std::vector<cricket::AudioCodec>& AudioSession::GetAudioCodecsList()
+    const {
+  return dvc_codecs_;
+}
+
+bool AudioSession::IsInitialized() const {
+  return (dvc_ != nullptr);
+}
+
+void AudioSession::OnConnectionBroken() {
+  if (listener_)
+    listener_->OnAudioSessionSessionDisconnected(*this, "IPC connection to DVC conference broken");
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
diff --git a/third_party/webrtc/dvc/audiosession.h b/third_party/webrtc/dvc/audiosession.h
new file mode 100644
index 00000000000..57e69d0f6a0
--- /dev/null
+++ b/third_party/webrtc/dvc/audiosession.h
@@ -0,0 +1,53 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef WEBRTC_DVC_AUDIO_SESSION_H_
+#define WEBRTC_DVC_AUDIO_SESSION_H_
+
+#include "rtc_base/critical_section.h"
+#include "rtc_base/thread.h"
+#include "rtc_base/thread_checker.h"
+
+#include "dvc/audiopackethandler.h"
+#include "dvc/common.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+class AudioSession : public DvcConference::ConnectionBrokenListener {
+ public:
+  class Listener {
+   public:
+    virtual ~Listener() = default;
+    virtual void OnAudioSessionSessionDisconnected(
+        AudioSession& session,
+        const std::string& error_desc) = 0;
+  };
+
+  AudioSession();
+  ~AudioSession() override;
+
+  bool Initialize(Listener* listener, std::string& err_desc);
+  void Shutdown();
+  bool Update(const cricket::AudioCodec& codec, std::string& err_desc);
+  void Stop();
+  AudioPacketHandler* GetAudioPacketHandler();
+
+  const std::vector<cricket::AudioCodec>& GetAudioCodecsList() const;
+  bool IsInitialized() const;
+  void OnConnectionBroken() override;
+
+ private:
+  bool EnsureConference();
+
+  Listener* listener_;
+  DvcConferenceFactory* dvc_;
+  std::vector<cricket::AudioCodec> dvc_codecs_;
+  std::unique_ptr<AudioPacketHandler> packet_handler_;
+};
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif /* WEBRTC_DVC_AUDIO_SESSION_H_ */
diff --git a/third_party/webrtc/dvc/common.h b/third_party/webrtc/dvc/common.h
new file mode 100644
index 00000000000..b17a9bafcbf
--- /dev/null
+++ b/third_party/webrtc/dvc/common.h
@@ -0,0 +1,21 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef WEBRTC_DVC_COMMON_H_
+#define WEBRTC_DVC_COMMON_H_
+
+#include "media/base/codec.h"
+
+#include <string>
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+static const size_t kMaxRtpPacketLen = 2048;
+static const size_t kMaxPendingPackets = 512;
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif /* WEBRTC_DVC_COMMON_H_ */
diff --git a/third_party/webrtc/dvc/dvc_conference_factory.cc b/third_party/webrtc/dvc/dvc_conference_factory.cc
new file mode 100644
index 00000000000..9e26fa150b7
--- /dev/null
+++ b/third_party/webrtc/dvc/dvc_conference_factory.cc
@@ -0,0 +1,29 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/dvc_conference_factory.h"
+
+#include "base/logging.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+DvcStats::DvcStats() = default;
+DvcStats::~DvcStats() = default;
+
+namespace {
+DvcConferenceFactory* g_instance = nullptr;
+}
+
+void DvcConferenceFactory::SetGlobalInstance(
+    DvcConferenceFactory* dvc_factory) {
+  g_instance = dvc_factory;
+}
+
+DvcConferenceFactory* DvcConferenceFactory::GetGlobalInstance() {
+  return g_instance;
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
diff --git a/third_party/webrtc/dvc/dvc_conference_factory.h b/third_party/webrtc/dvc/dvc_conference_factory.h
new file mode 100644
index 00000000000..6d161031ac2
--- /dev/null
+++ b/third_party/webrtc/dvc/dvc_conference_factory.h
@@ -0,0 +1,103 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef WEBRTC_DVC_CONFERENCE_FACTORY_H_
+#define WEBRTC_DVC_CONFERENCE_FACTORY_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+enum class DvcRTPEncoding : int32_t {
+  DVC2,
+  PCMU,
+  PCMA,
+  G722,
+  TELEPHONE_EVENT,
+};
+
+enum class DVC2SourceSide : int32_t {
+  CLIENT,
+  SERVER,
+};
+
+struct DvcAudioCodec {
+  DvcRTPEncoding encoding;
+  uint32_t clock_rate;
+  uint32_t rtp_payload_type;
+  bool has_dvc2_params;
+  DVC2SourceSide dvc2_source_side;
+  uint32_t dvc2_protocol_version;
+};
+
+struct DvcStats {
+  DvcStats();
+  ~DvcStats();
+
+  std::string codec_name = "";
+  int32_t in_jitter = 0;
+  int32_t in_jitter_buffer_ms = 0;
+  double in_packet_loss_fraction = 0;
+  uint64_t in_packets_total = 0;
+  uint64_t in_conceals_total = 0;
+  double in_voice_level = 0;
+  int32_t out_jitter = 0;
+  int32_t out_jitter_buffer_ms = 0;
+  double out_packet_loss_fraction = 0;
+  uint64_t out_packets_total = 0;
+  uint64_t out_fec_action_counter = 0;
+  double transmit_level = 0;
+  int32_t avg_rtt_to_as = 0;
+  int32_t echo_delay_ms = -1;
+  double total_output_energy = 0;
+  double total_input_energy = 0;
+};
+
+class DvcConference {
+ public:
+  class RtpSink {
+   public:
+    virtual ~RtpSink() {}
+    virtual void SendRtp(const char* data,
+                         size_t size,
+                         int64_t system_time_us) = 0;
+  };
+
+  class ConnectionBrokenListener {
+   public:
+    virtual ~ConnectionBrokenListener() = default;
+    virtual void OnConnectionBroken() = 0;
+  };
+
+  virtual ~DvcConference() {}
+  virtual bool Update(const DvcAudioCodec& codec,
+                      std::string& error_message) = 0;
+  virtual void Stop() = 0;
+  virtual void HandleReceivedRtpPacket(const char* data, size_t size) = 0;
+  virtual bool GetAudioSessionStats(DvcStats& stats) = 0;
+  virtual void SetMinimumPlayoutDelay(int32_t delay_ms) = 0;
+  virtual void SetMute(bool mute) = 0;
+  virtual void SetRtpSink(RtpSink& sink) = 0;
+  virtual void SetConnectionBrokenListener(
+      ConnectionBrokenListener* listener) = 0;
+};
+
+class DvcConferenceFactory {
+ public:
+  virtual ~DvcConferenceFactory() {}
+
+  static void SetGlobalInstance(DvcConferenceFactory* dvc_factory);
+  static DvcConferenceFactory* GetGlobalInstance();
+
+  virtual std::unique_ptr<DvcConference> CreateConference() = 0;
+  virtual bool GetAudioCodecsList(std::vector<DvcAudioCodec>& out_codecs) = 0;
+};
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif /* WEBRTC_DVC_CONFERENCE_FACTORY_H_ */
diff --git a/third_party/webrtc/dvc/dvc_constants.h b/third_party/webrtc/dvc/dvc_constants.h
new file mode 100644
index 00000000000..6a1e55a56ae
--- /dev/null
+++ b/third_party/webrtc/dvc/dvc_constants.h
@@ -0,0 +1,22 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef WEBRTC_DVC_CONSTANTS_H_
+#define WEBRTC_DVC_CONSTANTS_H_
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+static constexpr const char DVC_CODEC_NAME[] = "DVC-2";
+static const int DVC_PAYLOAD_TYPE = 96;
+static const int DVC_SAMPLING_RATES[] = {8000};
+static const int DVC_CHANNELS = 1;
+static const int DVC_BITRATE = 0;
+static const int DVC_MAX_DELTA_DELAY_MS = 900;
+static const int DVC_NUMBER_10MS_FRAMES_IN_PACKET = 2;
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif /* WEBRTC_DVC_CONSTANTS_H_ */
diff --git a/third_party/webrtc/dvc/media/engine/dvcvoiceengine.cc b/third_party/webrtc/dvc/media/engine/dvcvoiceengine.cc
new file mode 100644
index 00000000000..67908b88a66
--- /dev/null
+++ b/third_party/webrtc/dvc/media/engine/dvcvoiceengine.cc
@@ -0,0 +1,39 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/media/engine/dvcvoiceengine.h"
+#include "dvc/media/engine/dvcvoicemediachannel.h"
+
+#include "dvc/api/audio_codecs/dvcaudiocodecfactories.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+DvcVoiceEngine::DvcVoiceEngine(
+    webrtc::TaskQueueFactory* task_queue_factory,
+    webrtc::AudioDeviceModule* adm,
+    const rtc::scoped_refptr<webrtc::AudioEncoderFactory>& encoder_factory,
+    const rtc::scoped_refptr<webrtc::AudioDecoderFactory>& decoder_factory,
+    rtc::scoped_refptr<webrtc::AudioMixer> audio_mixer,
+    rtc::scoped_refptr<webrtc::AudioProcessing> audio_processing)
+    : WebRtcVoiceEngine(task_queue_factory,
+                        adm,
+                        CreateDVCAudioEncoderFactory(),
+                        CreateDVCAudioDecoderFactory(),
+                        audio_mixer,
+                        audio_processing) {
+  send_codecs_.clear();
+  recv_codecs_.clear();
+}
+
+cricket::VoiceMediaChannel* DvcVoiceEngine::CreateMediaChannel(
+    webrtc::Call* call,
+    const cricket::MediaConfig& config,
+    const cricket::AudioOptions& options,
+    const webrtc::CryptoOptions& crypto_options) {
+  return new DvcVoiceMediaChannel(this, config, options, crypto_options, call);
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
diff --git a/third_party/webrtc/dvc/media/engine/dvcvoiceengine.h b/third_party/webrtc/dvc/media/engine/dvcvoiceengine.h
new file mode 100644
index 00000000000..df11a3deb1c
--- /dev/null
+++ b/third_party/webrtc/dvc/media/engine/dvcvoiceengine.h
@@ -0,0 +1,33 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef WEBRTC_DVC_VOICEMEDIAENGINE_H_
+#define WEBRTC_DVC_VOICEMEDIAENGINE_H_
+
+#include "media/engine/webrtc_voice_engine.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+class DvcVoiceEngine : public cricket::WebRtcVoiceEngine {
+ public:
+  DvcVoiceEngine(
+      webrtc::TaskQueueFactory* task_queue_factory,
+      webrtc::AudioDeviceModule* adm,
+      const rtc::scoped_refptr<webrtc::AudioEncoderFactory>& encoder_factory,
+      const rtc::scoped_refptr<webrtc::AudioDecoderFactory>& decoder_factory,
+      rtc::scoped_refptr<webrtc::AudioMixer> audio_mixer,
+      rtc::scoped_refptr<webrtc::AudioProcessing> audio_processing);
+
+  cricket::VoiceMediaChannel* CreateMediaChannel(
+      webrtc::Call* call,
+      const cricket::MediaConfig& config,
+      const cricket::AudioOptions& options,
+      const webrtc::CryptoOptions& crypto_options) override;
+};
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif /* WEBRTC_DVC_DVCVOICEMEDIAENGINE_H_ */
diff --git a/third_party/webrtc/dvc/media/engine/dvcvoicemediachannel.cc b/third_party/webrtc/dvc/media/engine/dvcvoicemediachannel.cc
new file mode 100644
index 00000000000..74cfe05efed
--- /dev/null
+++ b/third_party/webrtc/dvc/media/engine/dvcvoicemediachannel.cc
@@ -0,0 +1,411 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/media/engine/dvcvoicemediachannel.h"
+
+#include "dvc/dvc_conference_factory.h"
+#include "rtc_base/logging.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+const int kMinLogIntervalMs = 1000;
+
+namespace {
+template <typename T>
+std::string GetOptionalValue(absl::optional<T> optional) {
+  std::stringstream out_ss;
+  if (optional) {
+    out_ss << *optional;
+  }
+  return out_ss.str();
+}
+
+void LogCodec(int id, const webrtc::RtpCodecParameters& params) {
+  std::stringstream out_ss;
+  out_ss << "VoiceMediaInfo: codec:";
+  out_ss << " id: " << id;
+  out_ss << " mime_type: " << params.mime_type();
+  out_ss << " name: " << params.name;
+  out_ss << " kind: " << params.kind;
+  out_ss << " payload_type: " << params.payload_type;
+  out_ss << " clock_rate: " << GetOptionalValue(params.clock_rate);
+  out_ss << " num_channels: " << GetOptionalValue(params.num_channels);
+  out_ss << " max_ptime: " << GetOptionalValue(params.max_ptime);
+  out_ss << " ptime: " << GetOptionalValue(params.ptime);
+  out_ss << " num_channels: " << GetOptionalValue(params.num_channels);
+
+  out_ss << " rtcp_feedback [";
+  for (size_t i = 0; i < params.rtcp_feedback.size(); ++i) {
+    if (i > 0)
+      out_ss << ", ";
+    if (params.rtcp_feedback[i].type == webrtc::RtcpFeedbackType::CCM)
+      out_ss << "CCM";
+    else if (params.rtcp_feedback[i].type == webrtc::RtcpFeedbackType::NACK)
+      out_ss << "NACK";
+    else if (params.rtcp_feedback[i].type == webrtc::RtcpFeedbackType::REMB)
+      out_ss << "REMB";
+    else if (params.rtcp_feedback[i].type ==
+             webrtc::RtcpFeedbackType::TRANSPORT_CC)
+      out_ss << "TRANSPORT_CC";
+  }
+  out_ss << "]";
+  out_ss << " parameters: [";
+  int i = 0;
+  for (auto& param : params.parameters) {
+    if (i > 0)
+      out_ss << ", ";
+    out_ss << param.first << "=" << param.second;
+  }
+  out_ss << "]";
+  RTC_LOG(LS_VERBOSE) << out_ss.str();
+}
+
+void LogVoiceMediaInfo(cricket::VoiceMediaInfo* info) {
+  RTC_LOG(LS_VERBOSE) << "VoiceMediaInfo: ";
+  for (cricket::VoiceSenderInfo& sender : info->senders) {
+    std::stringstream out_ss;
+    out_ss << "VoiceMediaInfo: VoiceSenderInfo:";
+
+    out_ss << " bytes_sent: " << sender.payload_bytes_sent;
+    out_ss << " packets_sent: " << sender.packets_sent;
+    out_ss << " packets_lost: " << sender.packets_lost;
+    out_ss << " fraction_lost: " << sender.fraction_lost;
+    out_ss << " rtt_ms: " << sender.rtt_ms;
+    out_ss << " codec_name: " << sender.codec_name;
+    out_ss << " codec_payload_type: "
+           << GetOptionalValue(sender.codec_payload_type);
+
+    RTC_LOG(LS_VERBOSE) << out_ss.str();
+    out_ss.str("");
+    out_ss << "VoiceMediaInfo: VoiceSenderInfo:";
+
+    out_ss << " local_stats: [";
+
+    for (cricket::SsrcSenderInfo& info : sender.local_stats) {
+      out_ss << " SsrcSenderInfo: {ssrc: " << info.ssrc
+             << ", timestamp: " << info.timestamp << "}";
+    }
+    out_ss << "]";
+    out_ss << " remote_stats: [";
+    for (cricket::SsrcReceiverInfo& info : sender.remote_stats) {
+      out_ss << " SsrcReceiverInfo: {ssrc: " << info.ssrc
+             << ", timestamp: " << info.timestamp << "}";
+    }
+    out_ss << "]";
+
+    RTC_LOG(LS_VERBOSE) << out_ss.str();
+    out_ss.str("");
+    out_ss << "VoiceMediaInfo: VoiceSenderInfo:";
+
+    // out_ss << " ext_seqnum: " << sender.ext_seqnum;
+    out_ss << " jitter_ms: " << sender.jitter_ms;
+    out_ss << " audio_level: " << sender.audio_level;
+    // out_ss << " echo_delay_median_ms: " << sender.echo_delay_median_ms;
+    // out_ss << " echo_delay_std_ms: " << sender.echo_delay_std_ms;
+    // out_ss << " echo_return_loss: " << sender.echo_return_loss;
+    // out_ss << " echo_return_loss_enhancement: "
+    //       << sender.echo_return_loss_enhancement;
+    // out_ss << " residual_echo_likelihood: " << sender.residual_echo_likelihood;
+    // out_ss << " residual_echo_likelihood_recent_max: "
+    //        << sender.residual_echo_likelihood_recent_max;
+    out_ss << " typing_noise_detected: " << sender.typing_noise_detected;
+    RTC_LOG(LS_VERBOSE) << out_ss.str();
+  }
+  for (cricket::VoiceReceiverInfo& receiver : info->receivers) {
+    std::stringstream out_ss;
+    out_ss << "VoiceMediaInfo: VoiceReceiverInfo:";
+
+    out_ss << " bytes_rcvd: " << receiver.payload_bytes_rcvd;
+    out_ss << " packets_rcvd: " << receiver.packets_rcvd;
+    out_ss << " packets_lost: " << receiver.packets_lost;
+    //out_ss << " fraction_lost: " << receiver.fraction_lost;
+    out_ss << " codec_name: " << receiver.codec_name;
+    out_ss << " codec_payload_type: "
+           << GetOptionalValue(receiver.codec_payload_type);
+
+    RTC_LOG(LS_VERBOSE) << out_ss.str();
+    out_ss.str("");
+    out_ss << "VoiceMediaInfo: VoiceReceiverInfo:";
+
+    out_ss << " local_stats: [";
+    for (cricket::SsrcReceiverInfo& info : receiver.local_stats) {
+      out_ss << "SsrcReceiverInfo: {ssrc: " << info.ssrc
+             << ", timestamp: " << info.timestamp << "}";
+    }
+    out_ss << "]";
+    out_ss << "  remote_stats: [";
+    for (cricket::SsrcSenderInfo& info : receiver.remote_stats) {
+      out_ss << "SsrcSenderInfo: {ssrc: " << info.ssrc
+             << ", timestamp: " << info.timestamp << "}";
+    }
+    out_ss << "]";
+
+    RTC_LOG(LS_VERBOSE) << out_ss.str();
+    out_ss.str("");
+    out_ss << "VoiceMediaInfo: VoiceReceiverInfo:";
+
+    // out_ss << " ext_seqnum: " << receiver.ext_seqnum;
+    out_ss << " jitter_ms: " << receiver.jitter_ms;
+    out_ss << " jitter_buffer_ms: " << receiver.jitter_buffer_ms;
+    out_ss << " jitter_buffer_preferred_ms: "
+           << receiver.jitter_buffer_preferred_ms;
+    out_ss << " delay_estimate_ms: " << receiver.delay_estimate_ms;
+    out_ss << " audio_level: " << receiver.audio_level;
+
+    RTC_LOG(LS_VERBOSE) << out_ss.str();
+    out_ss.str("");
+    out_ss << "VoiceMediaInfo: VoiceReceiverInfo:";
+
+    out_ss << " expand_rate: " << receiver.expand_rate;
+    out_ss << " speech_expand_rate: " << receiver.speech_expand_rate;
+    out_ss << " secondary_decoded_rate: " << receiver.secondary_decoded_rate;
+    out_ss << " accelerate_rate: " << receiver.accelerate_rate;
+    out_ss << " preemptive_expand_rate: " << receiver.preemptive_expand_rate;
+    out_ss << " decoding_calls_to_silence_generator: "
+           << receiver.decoding_calls_to_silence_generator;
+    out_ss << " decoding_calls_to_neteq: " << receiver.decoding_calls_to_neteq;
+    out_ss << " decoding_normal: " << receiver.decoding_normal;
+    out_ss << " decoding_plc: " << receiver.decoding_plc;
+    out_ss << " decoding_cng: " << receiver.decoding_cng;
+    out_ss << " decoding_plc_cng: " << receiver.decoding_plc_cng;
+    out_ss << " decoding_muted_output: " << receiver.decoding_muted_output;
+    out_ss << " capture_start_ntp_time_ms: "
+           << receiver.capture_start_ntp_time_ms;
+    RTC_LOG(LS_VERBOSE) << out_ss.str();
+  }
+
+  RTC_LOG(LS_VERBOSE) << "VoiceMediaInfo: RtpCodecParametersMap send_codecs:";
+  for (auto& send_codec : info->send_codecs) {
+    LogCodec(send_codec.first, send_codec.second);
+  }
+  RTC_LOG(LS_VERBOSE)
+      << "VoiceMediaInfo: RtpCodecParametersMap receive_codecs:";
+  for (auto& receive_codec : info->send_codecs) {
+    LogCodec(receive_codec.first, receive_codec.second);
+  }
+}
+
+void LogAudioSessionStats(const DvcStats& stats) {
+  RTC_LOG(LS_VERBOSE) << "AudioSessionStats:"
+                      << " codec_name: " << stats.codec_name
+
+                      << " in_jitter: " << stats.in_jitter
+                      << " in_packet_loss_fraction: "
+                      << stats.in_packet_loss_fraction
+                      << " in_packets_total: " << stats.in_packets_total
+                      << " in_conceals_total: " << stats.in_conceals_total
+                      << " in_voice_level: " << stats.in_voice_level
+
+                      << " out_jitter: " << stats.out_jitter
+                      << " out_packet_loss_fraction: "
+                      << stats.out_packet_loss_fraction
+                      << " out_packets_total: " << stats.out_packets_total
+                      << " out_fec_action_counter: "
+                      << stats.out_fec_action_counter
+
+                      << " transmit_level: " << stats.transmit_level
+                      << " avg_rtt_to_as: " << stats.avg_rtt_to_as
+                      << " echo_delay_ms: " << stats.echo_delay_ms
+                      << " total_output_energy: " << stats.total_output_energy
+                      << " total_input_energy: " << stats.total_input_energy;
+}
+
+}  // namespace
+
+DvcVoiceMediaChannel::DvcVoiceMediaChannel(cricket::WebRtcVoiceEngine* engine,
+                                           const cricket::MediaConfig& config,
+                                           const cricket::AudioOptions& options,
+                                           const webrtc::CryptoOptions& crypto_options,
+                                           webrtc::Call* call)
+    : WebRtcVoiceMediaChannel(engine, config, options, crypto_options, call),
+      _audio_packet_handler(nullptr) {}
+
+DvcVoiceMediaChannel::~DvcVoiceMediaChannel() = default;
+
+bool DvcVoiceMediaChannel::GetStats(cricket::VoiceMediaInfo* info) {
+  if (!is_using_dvc_codec_)
+    return WebRtcVoiceMediaChannel::GetStats(info);
+
+  if (info == nullptr)
+    return false;
+
+  DvcStats stats;
+  {
+    rtc::CritScope lock(&_critSect);
+    if (_audio_packet_handler != nullptr) {
+      _audio_packet_handler->GetAudioSessionStats(stats);
+    } else {
+      info->Clear();
+      return false;
+    }
+  }
+
+  int64_t now_ms = rtc::TimeMillis();
+
+  if (now_ms - _last_audio_session_stats_log_ms > kMinLogIntervalMs) {
+    LogAudioSessionStats(stats);
+    _last_audio_session_stats_log_ms = now_ms;
+  }
+
+  if (WebRtcVoiceMediaChannel::GetStats(info)) {
+    if (now_ms - _last_voice_media_info_log_ms > kMinLogIntervalMs) {
+      LogVoiceMediaInfo(info);
+      _last_voice_media_info_log_ms = now_ms;
+    }
+
+    for (cricket::VoiceSenderInfo& sinfo : info->senders) {
+      sinfo.codec_name = stats.codec_name;
+      sinfo.packets_sent = stats.out_packets_total;
+      sinfo.packets_lost =
+          stats.out_packets_total * stats.out_packet_loss_fraction;
+      sinfo.fraction_lost =
+          255 * stats.out_packet_loss_fraction;  // Scale 0 to 255, where 255 is
+                                                 // 100% loss.
+      // sinfo.ext_seqnum = -1;
+      sinfo.jitter_ms = stats.out_jitter;
+      sinfo.rtt_ms = stats.avg_rtt_to_as;
+      sinfo.audio_level = stats.transmit_level;
+      sinfo.total_input_energy = stats.total_input_energy;
+      // sinfo.echo_delay_median_ms = -1;
+      // sinfo.echo_delay_std_ms = -1;
+      // sinfo.echo_return_loss = -100;
+      // sinfo.echo_return_loss_enhancement = -100;
+      // sinfo.residual_echo_likelihood = 0;
+      // sinfo.residual_echo_likelihood_recent_max = 0;
+      sinfo.typing_noise_detected = false;
+      sinfo.ana_statistics.fec_action_counter.emplace(
+          stats.out_fec_action_counter);
+      sinfo.ana_statistics.uplink_packet_loss_fraction.emplace(
+          stats.out_packet_loss_fraction);
+      if (stats.echo_delay_ms >= 0)
+        sinfo.apm_statistics.delay_ms.emplace(stats.echo_delay_ms);
+    }
+
+    for (cricket::VoiceReceiverInfo& rinfo : info->receivers) {
+      rinfo.codec_name = stats.codec_name;
+      rinfo.packets_rcvd = stats.in_packets_total;
+      rinfo.packets_lost = stats.in_conceals_total;
+      //rinfo.fraction_lost =
+          //255 * stats.in_packet_loss_fraction;  // Scale 0 to 255, where 255 is
+                                                // 100% loss.
+      // rinfo.ext_seqnum = 0;
+      rinfo.jitter_ms = stats.in_jitter;
+      rinfo.jitter_buffer_preferred_ms = 0;
+      rinfo.audio_level = stats.in_voice_level;
+      rinfo.total_output_energy = stats.total_output_energy;
+      rinfo.expand_rate = 0;
+      rinfo.speech_expand_rate = 0;
+      rinfo.secondary_decoded_rate = 0;
+      rinfo.accelerate_rate = 0;
+      rinfo.preemptive_expand_rate = 0;
+      rinfo.decoding_calls_to_silence_generator = 0;
+      rinfo.decoding_calls_to_neteq = 0;
+      rinfo.decoding_normal = 0;
+      rinfo.decoding_plc = 0;
+      rinfo.decoding_cng = 0;
+      rinfo.decoding_plc_cng = 0;
+      rinfo.decoding_muted_output = 0;
+      rinfo.jitter_buffer_ms = stats.in_jitter_buffer_ms;
+    }
+    return true;
+  } else {
+    return false;
+  }
+}
+
+void DvcVoiceMediaChannel::OnPacketReceived(
+    rtc::CopyOnWriteBuffer packet,
+    int64_t packet_time_us) {
+  if (!is_using_dvc_codec_) {
+    WebRtcVoiceMediaChannel::OnPacketReceived(packet, packet_time_us);
+    return;
+  }
+  {
+    rtc::CritScope lock(&_critSect);
+    if (_audio_packet_handler != nullptr) {
+      _audio_packet_handler->HandleReceivedRtpPacket(packet.data(),
+                                                     packet.size());
+    } else {
+      RTC_LOG(LS_WARNING)
+          << "AudioPacketHandler is not available in DvcVoiceMediaChannel";
+    }
+  }
+  // Pass RTP packets to WebRTC to feed receiver side statistics to support
+  // lip-sync feature
+  WebRtcVoiceMediaChannel::OnPacketReceived(packet, packet_time_us);
+}
+
+bool DvcVoiceMediaChannel::SetMinimumPlayoutDelay(int delay_ms) {
+  constexpr int kVoiceEngineDvcMinMinPlayoutDelayMs = 0;
+  constexpr int kVoiceEngineDvcMaxMinPlayoutDelayMs = 900;
+
+  if (!is_using_dvc_codec_)
+    return true;
+
+  if ((delay_ms < kVoiceEngineDvcMinMinPlayoutDelayMs) ||
+      (delay_ms > kVoiceEngineDvcMaxMinPlayoutDelayMs)) {
+    RTC_DLOG(LS_ERROR) << "SetMinimumPlayoutDelay() invalid min or max delay";
+    return false;
+  }
+
+  RTC_LOG_F(LS_VERBOSE) << "delay_ms: " << delay_ms;
+  rtc::CritScope lock(&_critSect);
+  min_playout_delay_ = static_cast<uint32_t>(delay_ms);
+  if (_audio_packet_handler != nullptr) {
+    _audio_packet_handler->SetMinimumPlayoutDelay(delay_ms);
+  }
+
+  return true;
+}
+
+uint32_t DvcVoiceMediaChannel::GetPlayoutDelay() const {
+  return min_playout_delay_;
+}
+
+void DvcVoiceMediaChannel::SetAudioPacketHandler(AudioPacketHandler* client) {
+  if (!is_using_dvc_codec_) {
+    if (client != nullptr) {
+      // We should never be here, but just in case, let's set NULL packet
+      // handler:
+      RTC_NOTREACHED();
+      client = nullptr;
+    }
+  }
+  rtc::CritScope lock(&_critSect);
+  _audio_packet_handler = client;
+  if (_audio_packet_handler != nullptr && is_muted_)
+    _audio_packet_handler->SetMute(is_muted_);
+}
+
+bool DvcVoiceMediaChannel::GetPacketsToSend(std::vector<AudioBuffer>& packets) {
+  if (!is_using_dvc_codec_) {
+    RTC_NOTREACHED();
+    return false;
+  }
+
+  rtc::CritScope lock(&_critSect);
+  if (_audio_packet_handler != nullptr) {
+    return _audio_packet_handler->GetPacketsToSend(packets);
+  } else
+    return false;
+}
+
+void DvcVoiceMediaChannel::SetInputMute(bool mute) {
+  rtc::CritScope lock(&_critSect);
+  is_muted_ = mute;
+  if (is_using_dvc_codec_ && _audio_packet_handler != nullptr) {
+    _audio_packet_handler->SetMute(is_muted_);
+  }
+}
+
+void DvcVoiceMediaChannel::OnReadyToSend(bool ready) {
+  WebRtcVoiceMediaChannel::OnReadyToSend(ready);
+  if (is_using_dvc_codec_) {
+    SignalReadyToSend(this, ready);
+  }
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
diff --git a/third_party/webrtc/dvc/media/engine/dvcvoicemediachannel.h b/third_party/webrtc/dvc/media/engine/dvcvoicemediachannel.h
new file mode 100644
index 00000000000..0e329891160
--- /dev/null
+++ b/third_party/webrtc/dvc/media/engine/dvcvoicemediachannel.h
@@ -0,0 +1,59 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef WEBRTC_DVC_VOICEMEDIACHANNEL_H_
+#define WEBRTC_DVC_VOICEMEDIACHANNEL_H_
+
+#include "dvc/audiopackethandler.h"
+#include "media/engine/webrtc_voice_engine.h"
+
+#include "rtc_base/critical_section.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+class DvcVoiceMediaChannel : public cricket::WebRtcVoiceMediaChannel {
+ public:
+  DvcVoiceMediaChannel(cricket::WebRtcVoiceEngine* engine,
+                       const cricket::MediaConfig& config,
+                       const cricket::AudioOptions& options,
+                       const webrtc::CryptoOptions& crypto_options,
+                       webrtc::Call* call);
+  virtual ~DvcVoiceMediaChannel();
+
+  bool GetStats(cricket::VoiceMediaInfo* info) override;
+  void OnPacketReceived(rtc::CopyOnWriteBuffer packet,
+                        int64_t packet_time_us) override;
+
+  bool SetMinimumPlayoutDelay(int delay_ms);
+  uint32_t GetPlayoutDelay() const;
+  void SetAudioPacketHandler(AudioPacketHandler* client);
+  bool GetPacketsToSend(std::vector<AudioBuffer>& packets);
+  void SetInputMute(bool mute);
+
+  void OnReadyToSend(bool ready) override;
+
+  void SetUsingDvcCodec(bool using_dvc) { is_using_dvc_codec_ = using_dvc; }
+  bool IsUsingDvcCodec() const { return is_using_dvc_codec_; }
+
+  DvcVoiceMediaChannel* GetDvcVoiceMediaChannel() const override {
+    return const_cast<DvcVoiceMediaChannel*>(this);
+  }
+
+  sigslot::signal2<DvcVoiceMediaChannel*, bool> SignalReadyToSend;
+
+ protected:
+  rtc::CriticalSection _critSect;
+  AudioPacketHandler* _audio_packet_handler;
+  int64_t _last_audio_session_stats_log_ms = -1;
+  int64_t _last_voice_media_info_log_ms = -1;
+  bool is_using_dvc_codec_ = true;
+  bool is_muted_ = false;
+  uint32_t min_playout_delay_ = 0;
+};
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif /* WEBRTC_DVC_VOICEMEDIACHANNEL_H_ */
diff --git a/third_party/webrtc/dvc/pc/dvcpeerconnection.cc b/third_party/webrtc/dvc/pc/dvcpeerconnection.cc
new file mode 100644
index 00000000000..5a736e68112
--- /dev/null
+++ b/third_party/webrtc/dvc/pc/dvcpeerconnection.cc
@@ -0,0 +1,380 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#include "dvc/pc/dvcpeerconnection.h"
+
+#include "dolby/services/dolby_voice_client/vars.h"
+#include "dvc/dvc_constants.h"
+
+#include "absl/strings/match.h"
+#include "rtc_base/string_utils.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+DvcPeerConnection::DvcPeerConnection(
+    webrtc::PeerConnectionFactory* factory,
+    std::unique_ptr<webrtc::RtcEventLog> event_log,
+    std::unique_ptr<webrtc::Call> call)
+    : PeerConnection(factory, std::move(event_log), std::move(call)),
+      dvc_audio_session_(new AudioSession),
+      pending_update_action_(false),
+      is_using_dvc_codec_(true) {}
+
+void DvcPeerConnection::Close() {
+  RTC_DCHECK(signaling_thread()->IsCurrent());
+  PeerConnection::Close();
+  ShutdownAudioSession();
+}
+
+void DvcPeerConnection::CreateOffer(
+    webrtc::CreateSessionDescriptionObserver* observer,
+    const RTCOfferAnswerOptions& options) {
+  RTC_DCHECK(signaling_thread()->IsCurrent());
+  if (EnsureAudioSessionInitialized(observer))
+    PeerConnection::CreateOffer(observer, options);
+}
+
+void DvcPeerConnection::CreateAnswer(
+    webrtc::CreateSessionDescriptionObserver* observer,
+    const RTCOfferAnswerOptions& options) {
+  RTC_DCHECK(signaling_thread()->IsCurrent());
+  if (EnsureAudioSessionInitialized(observer))
+    PeerConnection::CreateAnswer(observer, options);
+}
+
+cricket::VoiceChannel* DvcPeerConnection::CreateVoiceChannel(const std::string& mid) {
+  RTC_DCHECK(signaling_thread()->IsCurrent());
+  auto voice_channel = PeerConnection::CreateVoiceChannel(mid);
+  if (is_using_dvc_codec_ && voice_channel) {
+    if (!AttachVoiceChannelToAudioPacketHandler(voice_channel)) {
+      RTC_LOG_F(LS_ERROR) << "Failed to attach DVC packet handler";
+      return nullptr;
+    }
+  } else {
+    RTC_LOG(LS_WARNING) << "CreateVoiceChannel failed.";
+  }
+  return voice_channel;
+}
+
+void DvcPeerConnection::SetLocalDescription(
+    webrtc::SetSessionDescriptionObserver* observer,
+    webrtc::SessionDescriptionInterface* desc) {
+  RTC_DCHECK(signaling_thread()->IsCurrent());
+  std::string sdp("null");
+  if (desc != nullptr) {
+    desc->ToString(&sdp);
+  }
+  RTC_LOG_F(LS_INFO) << std::endl << sdp;
+  if (EnsureAudioSessionInitialized(observer))
+    PeerConnection::SetLocalDescription(observer, desc);
+}
+
+void DvcPeerConnection::SetRemoteDescription(
+    std::unique_ptr<webrtc::SessionDescriptionInterface> desc,
+    rtc::scoped_refptr<webrtc::SetRemoteDescriptionObserverInterface>
+        observer) {
+  RTC_DCHECK(signaling_thread()->IsCurrent());
+  std::string sdp("null");
+  if (desc != nullptr) {
+    desc->ToString(&sdp);
+  }
+  RTC_LOG_F(LS_INFO) << std::endl << sdp;
+  if (EnsureAudioSessionInitialized(observer.get()))
+    PeerConnection::SetRemoteDescription(std::move(desc), observer);
+}
+
+void DvcPeerConnection::DestroyChannelInterface(cricket::ChannelInterface* channel) {
+  RTC_DCHECK(signaling_thread()->IsCurrent());
+  if (channel->media_type() == cricket::MEDIA_TYPE_AUDIO) {
+    DettachVoiceChannelFromAudioPacketHandler(
+        static_cast<cricket::VoiceChannel*>(channel));
+  }
+  PeerConnection::DestroyChannelInterface(channel);
+}
+
+webrtc::RTCError DvcPeerConnection::UpdateSessionState(
+    webrtc::SdpType type,
+    cricket::ContentSource source,
+    const cricket::SessionDescription* description) {
+  RTC_DCHECK(signaling_thread()->IsCurrent());
+  auto ret = PeerConnection::UpdateSessionState(type, source, description);
+  if (ret.ok())
+    UpdateAudioSession(type, source);
+  return ret;
+}
+
+webrtc::RTCError DvcPeerConnection::UpdateAudioSession(
+    webrtc::SdpType type,
+    cricket::ContentSource source) {
+  RTC_DCHECK(signaling_thread()->IsCurrent());
+  if (type == webrtc::SdpType::kPrAnswer || type == webrtc::SdpType::kAnswer) {
+    const cricket::SessionDescription* local_desc =
+        local_description()->description();
+    const cricket::SessionDescription* remote_desc =
+        remote_description()->description();
+
+    const cricket::MediaContentDescription* local_audio_content_desc =
+        cricket::GetFirstAudioContentDescription(local_desc);
+    const cricket::MediaContentDescription* remote_audio_content_desc =
+        cricket::GetFirstAudioContentDescription(remote_desc);
+
+    // We should have local and remote audio content descriptions
+    if (local_audio_content_desc != nullptr &&
+        remote_audio_content_desc != nullptr) {
+
+      // Start only when audio stream is able to send and receive
+      if (local_audio_content_desc->direction() ==
+              webrtc::RtpTransceiverDirection::kSendRecv &&
+          remote_audio_content_desc->direction() ==
+              webrtc::RtpTransceiverDirection::kSendRecv) {
+        // We need to wait for the next connection monitor status update,
+        // to check if the voice channel is actually writable, only then the
+        // session will be updated
+        last_negotiated_audio_codecs_ = GetNegotiatedCodecs();
+        pending_update_action_ = true;
+
+        auto* voice_channel = static_cast<cricket::VoiceChannel*>(
+            GetAudioTransceiver()->internal()->channel());
+        if (voice_channel && voice_channel->writable()) {
+          DoUpdate(static_cast<DvcVoiceMediaChannel*>(
+              voice_channel->media_channel()));
+        }
+      }
+    }
+  }
+  return webrtc::RTCError::OK();
+}
+
+std::vector<cricket::AudioCodec> DvcPeerConnection::GetNegotiatedCodecs() {
+  std::vector<cricket::AudioCodec> negotiated_codecs;
+  auto* voice_channel = static_cast<cricket::VoiceChannel*>(
+      GetAudioTransceiver()->internal()->channel());
+  if (voice_channel) {
+    for (cricket::AudioCodec send_codec :
+         voice_channel->last_send_params_.codecs) {
+      for (cricket::AudioCodec recv_codec :
+           voice_channel->last_recv_params_.codecs) {
+        if (recv_codec.Matches(send_codec)) {
+          negotiated_codecs.push_back(send_codec);
+        }
+      }
+    }
+  }
+  return negotiated_codecs;
+}
+
+void DvcPeerConnection::ShutdownAudioSession() {
+  RTC_DCHECK(signaling_thread()->IsCurrent());
+  if (dvc_audio_session_->IsInitialized())
+    dvc_audio_session_->Shutdown();
+  signaling_thread()->Clear(this, MSG_PROCESS_DISCONNECTED_AUDIO_SESSION);
+  signaling_thread()->Clear(this, MSG_UPDATE_SESSION);
+}
+
+void DvcPeerConnection::DoUpdate(DvcVoiceMediaChannel* voice_channel) {
+  if (pending_update_action_) {
+    pending_update_action_ = false;
+    std::string err_desc;
+    if (!last_negotiated_audio_codecs_.empty() &&
+        !absl::EqualsIgnoreCase(
+          last_negotiated_audio_codecs_[0].name.c_str(),
+          getDolbyValueOr(switches::kDvcCodecName, webrtc_integration::DVC_CODEC_NAME))) {
+      is_using_dvc_codec_ = false;
+      voice_channel->SetUsingDvcCodec(is_using_dvc_codec_);
+    } else {
+      is_using_dvc_codec_ = true;
+      voice_channel->SetUsingDvcCodec(is_using_dvc_codec_);
+      if (!dvc_audio_session_->Update(last_negotiated_audio_codecs_[0],
+                                      err_desc)) {
+        OnAudioSessionSessionDisconnected(*dvc_audio_session_, err_desc);
+      }
+    }
+  }
+}
+
+void DvcPeerConnection::OnSignalReadyToSend(DvcVoiceMediaChannel* dvc_channel,
+                                            bool ready) {
+  if (ready) {
+    signaling_thread()->Post(
+        RTC_FROM_HERE, this, MSG_UPDATE_SESSION,
+        new rtc::TypedMessageData<DvcVoiceMediaChannel*>(dvc_channel));
+  }
+}
+
+bool DvcPeerConnection::AttachVoiceChannelToAudioPacketHandler(
+    cricket::VoiceChannel* voice_channel) {
+  if (voice_channel == nullptr) {
+    RTC_LOG(LS_WARNING) << "Failed to attach voice channel to audio packet "
+                           "handler - voice channel is not available.";
+    return false;
+  }
+  DvcVoiceMediaChannel* _dvc_channel =
+      static_cast<DvcVoiceMediaChannel*>(voice_channel->media_channel());
+  if (_dvc_channel != nullptr) {
+    _dvc_channel->SetAudioPacketHandler(
+        dvc_audio_session_->GetAudioPacketHandler());
+    _dvc_channel->SignalReadyToSend.connect(
+        this, &DvcPeerConnection::OnSignalReadyToSend);
+    return true;
+  } else {
+    RTC_LOG(LS_WARNING) << "Failed to attach voice channel to audio packet "
+                           "handler - dvc channel is not available.";
+    return false;
+  }
+}
+
+void DvcPeerConnection::DettachVoiceChannelFromAudioPacketHandler(
+    cricket::VoiceChannel* voice_channel) {
+  DvcVoiceMediaChannel* dvc_channel =
+      static_cast<DvcVoiceMediaChannel*>(voice_channel->media_channel());
+  if (dvc_channel != nullptr) {
+    dvc_channel->SetAudioPacketHandler(nullptr);
+
+    rtc::MessageList cleared_messages;
+    signaling_thread()->Clear(this, MSG_UPDATE_SESSION, &cleared_messages);
+
+    for (auto message : cleared_messages) {
+      rtc::TypedMessageData<DvcVoiceMediaChannel*>* data =
+          static_cast<rtc::TypedMessageData<DvcVoiceMediaChannel*>*>(
+              message.pdata);
+      if (data->data() == dvc_channel)
+        delete data;
+      else
+        signaling_thread()->Post(
+            message.posted_from, this, MSG_UPDATE_SESSION,
+            message.pdata);  // return update messages for other channels
+    }
+  }
+}
+
+bool DvcPeerConnection::EnsureAudioSessionInitialized(
+    webrtc::SetRemoteDescriptionObserverInterface* observer) {
+  RTC_DCHECK(signaling_thread()->IsCurrent());
+  if (dvc_audio_session_->IsInitialized()) {
+    return true;
+  } else {
+    bool ret = false;
+    if (signaling_state() != kClosed)
+      ret = InitializeAudioSession();
+    return ret;
+  }
+}
+
+template <typename ObserverT>
+bool DvcPeerConnection::EnsureAudioSessionInitialized(ObserverT* observer) {
+  RTC_DCHECK(signaling_thread()->IsCurrent());
+  if (dvc_audio_session_->IsInitialized()) {
+    return true;
+  } else {
+    bool ret = false;
+    if (signaling_state() != kClosed)
+      ret = InitializeAudioSession();
+
+    if (!ret && observer != nullptr) {
+      observer->OnFailure(session_error_desc());
+    }
+    return ret;
+  }
+}
+
+template bool DvcPeerConnection::EnsureAudioSessionInitialized(
+    webrtc::CreateSessionDescriptionObserver* observer);
+template bool DvcPeerConnection::EnsureAudioSessionInitialized(
+    webrtc::SetSessionDescriptionObserver* observer);
+
+namespace {
+
+void UpdateDvcCodecs(std::vector<cricket::AudioCodec>& codecs,
+                     const std::vector<cricket::AudioCodec>& dvc_codecs) {
+  auto dvc_codec_filter =
+      [&dvc_codecs](const cricket::AudioCodec& codec) -> bool {
+    if (absl::EqualsIgnoreCase(codec.name, "telephone-event"))
+      return false;  // leave DTMF intact, although the DVC library supports it.
+
+    for (const auto& dvc_codec : dvc_codecs) {
+      if (absl::EqualsIgnoreCase(codec.name, dvc_codec.name))
+        return true;
+    }
+    return false;
+  };
+  codecs.erase(std::remove_if(codecs.begin(), codecs.end(), dvc_codec_filter),
+               codecs.end());
+
+  int audio_codec_idx = 0;
+  for (const auto& codec : dvc_codecs) {
+    if (!absl::EqualsIgnoreCase(codec.name, "telephone-event")) {
+      // Insert all codecs in order to the beginning of the list,
+      // but ignore DTMF.
+      codecs.insert(codecs.begin() + audio_codec_idx++, codec);
+    }
+  }
+}
+
+}  // end anonymous namespace
+
+bool DvcPeerConnection::InitializeAudioSession() {
+  RTC_DCHECK(signaling_thread()->IsCurrent());
+  const std::vector<cricket::AudioCodec>* dvc_codecs = nullptr;
+  std::string session_error;
+  bool result = dvc_audio_session_->Initialize(this, session_error);
+  if (result) {
+    dvc_codecs = &dvc_audio_session_->GetAudioCodecsList();
+  } else {
+    RTC_LOG(LS_WARNING) << "DVC audio session initialization failed.";
+    SetSessionError(SessionError::kTransport, session_error);
+  }
+
+  // Get the codecs supported by the session desc factory; the list contains
+  // both the original Webrtc codecs, and the dummy DVC-2 codec coming from the
+  // dummy DVC-2 en/decoders:
+  std::vector<cricket::AudioCodec> send_codecs;
+  std::vector<cricket::AudioCodec> recv_codecs;
+  webrtc_session_desc_factory_->get_audio_codecs(send_codecs, recv_codecs);
+
+  UpdateDvcCodecs(send_codecs, *dvc_codecs);
+  UpdateDvcCodecs(recv_codecs, *dvc_codecs);
+
+  // Set the updated codecs list:
+  webrtc_session_desc_factory_->set_audio_codecs(send_codecs, recv_codecs);
+  return result;
+}
+
+void DvcPeerConnection::OnAudioSessionSessionDisconnected(
+    AudioSession& session,
+    const std::string& error_desc) {
+  signaling_thread()->Post(
+      RTC_FROM_HERE, this, MSG_PROCESS_DISCONNECTED_AUDIO_SESSION,
+      new rtc::ScopedMessageData<std::string>(new std::string(error_desc)));
+}
+
+void DvcPeerConnection::OnMessage(rtc::Message* msg) {
+  switch (msg->message_id) {
+    case MSG_PROCESS_DISCONNECTED_AUDIO_SESSION: {
+      rtc::ScopedMessageData<std::string>* data =
+          static_cast<rtc::ScopedMessageData<std::string>*>(msg->pdata);
+      std::string error = *data->data().get();
+      delete data;
+
+      RTC_DCHECK(signaling_thread()->IsCurrent());
+      SetSessionError(SessionError::kTransport, error);
+      Close();
+      break;
+    }
+    case MSG_UPDATE_SESSION: {
+      rtc::TypedMessageData<DvcVoiceMediaChannel*>* data =
+          static_cast<rtc::TypedMessageData<DvcVoiceMediaChannel*>*>(
+              msg->pdata);
+      DoUpdate(data->data());
+      delete data;
+      break;
+    }
+    default:
+      PeerConnection::OnMessage(msg);
+      break;
+  }
+}
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
diff --git a/third_party/webrtc/dvc/pc/dvcpeerconnection.h b/third_party/webrtc/dvc/pc/dvcpeerconnection.h
new file mode 100644
index 00000000000..ce6159e09ae
--- /dev/null
+++ b/third_party/webrtc/dvc/pc/dvcpeerconnection.h
@@ -0,0 +1,81 @@
+// Copyright 2020 Dolby Laboratories and Dolby International AB
+// Use of this source code is governed by the MIT license that can be
+// found in the dolby/LICENSE file.
+
+#ifndef WEBRTC_DVC_DVCPEERCONNECTION_H_
+#define WEBRTC_DVC_DVCPEERCONNECTION_H_
+
+#include <atomic>
+
+#include "dvc/audiosession.h"
+#include "dvc/media/engine/dvcvoicemediachannel.h"
+#include "p2p/client/basic_port_allocator.h"
+#include "pc/peer_connection.h"
+
+namespace dolby_voice_client {
+namespace webrtc_integration {
+
+class DvcPeerConnection : public webrtc::PeerConnection,
+                          public AudioSession::Listener {
+ public:
+  explicit DvcPeerConnection(webrtc::PeerConnectionFactory* factory,
+                             std::unique_ptr<webrtc::RtcEventLog> event_log,
+                             std::unique_ptr<webrtc::Call> call);
+
+  void Close() override;
+
+  void CreateOffer(webrtc::CreateSessionDescriptionObserver* observer,
+                   const RTCOfferAnswerOptions& options) RTC_RUN_ON(signaling_thread()) override;
+
+  void CreateAnswer(webrtc::CreateSessionDescriptionObserver* observer,
+                    const RTCOfferAnswerOptions& options) RTC_RUN_ON(signaling_thread()) override;
+
+  cricket::VoiceChannel* CreateVoiceChannel(const std::string& mid) RTC_RUN_ON(signaling_thread()) override;
+
+  void SetLocalDescription(webrtc::SetSessionDescriptionObserver* observer,
+                           webrtc::SessionDescriptionInterface* desc) RTC_RUN_ON(signaling_thread()) override;
+
+  void SetRemoteDescription(
+      std::unique_ptr<webrtc::SessionDescriptionInterface> desc,
+      rtc::scoped_refptr<webrtc::SetRemoteDescriptionObserverInterface>
+          observer) RTC_RUN_ON(signaling_thread()) override;
+  void DestroyChannelInterface(cricket::ChannelInterface* channel) override;
+
+ protected:
+  bool InitializeAudioSession() RTC_RUN_ON(signaling_thread());
+  void ShutdownAudioSession();
+  webrtc::RTCError UpdateSessionState(webrtc::SdpType type,
+                                      cricket::ContentSource source,
+                                      const cricket::SessionDescription* description) RTC_RUN_ON(signaling_thread()) override;
+  webrtc::RTCError UpdateAudioSession(webrtc::SdpType type,
+                                      cricket::ContentSource source) RTC_RUN_ON(signaling_thread());
+  void DoUpdate(DvcVoiceMediaChannel* voice_channel);
+  bool EnsureAudioSessionInitialized(
+      webrtc::SetRemoteDescriptionObserverInterface* observer) RTC_RUN_ON(signaling_thread());
+  void OnSignalReadyToSend(DvcVoiceMediaChannel* dvc_channel, bool ready);
+  bool AttachVoiceChannelToAudioPacketHandler(
+      cricket::VoiceChannel* voice_channel);
+  void DettachVoiceChannelFromAudioPacketHandler(
+      cricket::VoiceChannel* voice_channel);
+
+  template <typename ObserverT>
+  bool EnsureAudioSessionInitialized(ObserverT* observer) RTC_RUN_ON(signaling_thread());
+
+  std::vector<cricket::AudioCodec> GetNegotiatedCodecs() RTC_RUN_ON(signaling_thread());
+  void OnAudioSessionSessionDisconnected(
+      AudioSession& session,
+      const std::string& error_desc) override;
+  void OnMessage(rtc::Message* msg) override;
+
+  enum { MSG_PROCESS_DISCONNECTED_AUDIO_SESSION = 101, MSG_UPDATE_SESSION };
+
+  std::unique_ptr<AudioSession> dvc_audio_session_;
+  std::atomic<bool> pending_update_action_;
+  std::vector<cricket::AudioCodec> last_negotiated_audio_codecs_;
+  bool is_using_dvc_codec_;
+};
+
+}  // namespace webrtc_integration
+}  // namespace dolby_voice_client
+
+#endif /* WEBRTC_DVC_DVCPEERCONNECTION_H_ */
diff --git a/third_party/webrtc/media/BUILD.gn b/third_party/webrtc/media/BUILD.gn
index 48fcdff3135..28107d9fb20 100644
--- a/third_party/webrtc/media/BUILD.gn
+++ b/third_party/webrtc/media/BUILD.gn
@@ -381,6 +381,7 @@ rtc_library("rtc_data") {
     # "SCTP_DEBUG" # Uncomment for SCTP debugging.
   ]
   deps = [
+    "../dvc:dvc_media",
     ":rtc_media_base",
     "..:webrtc_common",
     "../api:call_api",
diff --git a/third_party/webrtc/media/base/codec.cc b/third_party/webrtc/media/base/codec.cc
index 168e7a78297..64366575dfe 100644
--- a/third_party/webrtc/media/base/codec.cc
+++ b/third_party/webrtc/media/base/codec.cc
@@ -19,6 +19,9 @@
 #include "rtc_base/string_encode.h"
 #include "rtc_base/strings/string_builder.h"
 
+#include "dolby/services/dolby_voice_client/vars.h"
+#include "dvc/dvc_constants.h"
+
 namespace cricket {
 namespace {
 
@@ -225,6 +228,20 @@ bool AudioCodec::Matches(const AudioCodec& codec) const {
   // omitted if the number of channels is one."
   // Preference is ignored.
   // TODO(juberti): Treat a zero clockrate as 8000Hz, the RTP default clockrate.
+  using namespace dolby_voice_client::webrtc_integration;
+  if (absl::EqualsIgnoreCase(name.c_str(),
+                             getDolbyValueOr(switches::kDvcCodecName, DVC_CODEC_NAME)) &&
+      absl::EqualsIgnoreCase(codec.name.c_str(),
+                             getDolbyValueOr(switches::kDvcCodecName, DVC_CODEC_NAME))) {
+    if (HasDvc2Params() != codec.HasDvc2Params())
+      return false;
+    if (HasDvc2Params()) {
+      if (Dvc2ProtocolVersion() != codec.Dvc2ProtocolVersion())
+        return false;
+      if (Dvc2SourceSide() != codec.Dvc2SourceSide())
+        return false;
+    }
+  }
   return Codec::Matches(codec) &&
          ((codec.clockrate == 0 /*&& clockrate == 8000*/) ||
           clockrate == codec.clockrate) &&
@@ -247,6 +264,59 @@ webrtc::RtpCodecParameters AudioCodec::ToCodecParameters() const {
   return codec_params;
 }
 
+dolby_voice_client::webrtc_integration::DVC2SourceSide
+AudioCodec::Dvc2SourceSide() const {
+  std::string source;
+  if (GetParam("source", &source)) {
+    if (source == "client")
+      return dolby_voice_client::webrtc_integration::DVC2SourceSide::CLIENT;
+    else if (source == "server")
+      return dolby_voice_client::webrtc_integration::DVC2SourceSide::SERVER;
+  }
+  return dolby_voice_client::webrtc_integration::DVC2SourceSide::SERVER;
+}
+
+int AudioCodec::Dvc2ProtocolVersion() const
+{
+    int version;
+    if (GetParam("version", &version))
+        return version;
+    return 0;
+}
+
+void AudioCodec::SetDvc2Params(
+    const dolby_voice_client::webrtc_integration::DvcAudioCodec& params) {
+  if (params.encoding ==
+          dolby_voice_client::webrtc_integration::DvcRTPEncoding::DVC2 &&
+      params.has_dvc2_params) {
+    SetParam("mode", "cs");
+    SetParam("version", static_cast<int>(params.dvc2_protocol_version));
+    if (params.dvc2_source_side ==
+        dolby_voice_client::webrtc_integration::DVC2SourceSide::CLIENT)
+      SetParam("source", "client");
+    else
+      SetParam("source", "server");
+  }
+}
+
+bool AudioCodec::HasDvc2Params() const
+{
+  using namespace dolby_voice_client::webrtc_integration;
+  if (!absl::EqualsIgnoreCase(name.c_str(),
+                              getDolbyValueOr(switches::kDvcCodecName, DVC_CODEC_NAME)))
+    return false;
+  CodecParameterMap::const_iterator iter = params.find("mode");
+  if (iter == params.end())
+    return false;
+  iter = params.find("source");
+  if (iter == params.end())
+    return false;
+  iter = params.find("version");
+  if (iter == params.end())
+    return false;
+  return true;
+}
+
 std::string VideoCodec::ToString() const {
   char buf[256];
   rtc::SimpleStringBuilder sb(buf);
diff --git a/third_party/webrtc/media/base/codec.h b/third_party/webrtc/media/base/codec.h
index f327199484e..21e551f975d 100644
--- a/third_party/webrtc/media/base/codec.h
+++ b/third_party/webrtc/media/base/codec.h
@@ -22,6 +22,8 @@
 #include "media/base/media_constants.h"
 #include "rtc_base/system/rtc_export.h"
 
+#include "dvc/dvc_conference_factory.h"
+
 namespace cricket {
 
 typedef std::map<std::string, std::string> CodecParameterMap;
@@ -136,6 +138,16 @@ struct AudioCodec : public Codec {
 
   webrtc::RtpCodecParameters ToCodecParameters() const override;
 
+  // DVC2-specific methods added to base class. If we made some AudioCodecDVC
+  // class, then for the remote side the webrtc would still parse SDP and
+  // create generic AudioCodec instance, and matching DVC-2 codecs would be
+  // broken.
+  dolby_voice_client::webrtc_integration::DVC2SourceSide Dvc2SourceSide() const;
+  int Dvc2ProtocolVersion() const;
+  void SetDvc2Params(
+      const dolby_voice_client::webrtc_integration::DvcAudioCodec& params);
+  bool HasDvc2Params() const;
+
   AudioCodec& operator=(const AudioCodec& c);
   AudioCodec& operator=(AudioCodec&& c);
 
diff --git a/third_party/webrtc/media/engine/webrtc_media_engine.cc b/third_party/webrtc/media/engine/webrtc_media_engine.cc
index 751b729eafa..1989e7d981a 100644
--- a/third_party/webrtc/media/engine/webrtc_media_engine.cc
+++ b/third_party/webrtc/media/engine/webrtc_media_engine.cc
@@ -23,11 +23,13 @@
 #include "media/engine/null_webrtc_video_engine.h"
 #endif
 
+#include "dvc/media/engine/dvcvoiceengine.h"
+
 namespace cricket {
 
 std::unique_ptr<MediaEngineInterface> CreateMediaEngine(
     MediaEngineDependencies dependencies) {
-  auto audio_engine = std::make_unique<WebRtcVoiceEngine>(
+  auto audio_engine = std::make_unique<dolby_voice_client::webrtc_integration::DvcVoiceEngine>(
       dependencies.task_queue_factory, std::move(dependencies.adm),
       std::move(dependencies.audio_encoder_factory),
       std::move(dependencies.audio_decoder_factory),
diff --git a/third_party/webrtc/media/engine/webrtc_voice_engine.cc b/third_party/webrtc/media/engine/webrtc_voice_engine.cc
index 97e12ba9c86..c2712e58f2f 100644
--- a/third_party/webrtc/media/engine/webrtc_voice_engine.cc
+++ b/third_party/webrtc/media/engine/webrtc_voice_engine.cc
@@ -1603,7 +1603,6 @@ bool WebRtcVoiceMediaChannel::SetSendCodecs(
           IsCodec(voice_codec, kRedCodecName))) {
       webrtc::SdpAudioFormat format(voice_codec.name, voice_codec.clockrate,
                                     voice_codec.channels, voice_codec.params);
-
       voice_codec_info = engine()->encoder_factory_->QueryAudioEncoder(format);
       if (!voice_codec_info) {
         RTC_LOG(LS_WARNING) << "Unknown codec " << ToString(voice_codec);
diff --git a/third_party/webrtc/media/engine/webrtc_voice_engine.h b/third_party/webrtc/media/engine/webrtc_voice_engine.h
index 7ff8690b2dc..dafd53e95b6 100644
--- a/third_party/webrtc/media/engine/webrtc_voice_engine.h
+++ b/third_party/webrtc/media/engine/webrtc_voice_engine.h
@@ -39,7 +39,7 @@ class WebRtcVoiceMediaChannel;
 
 // WebRtcVoiceEngine is a class to be used with CompositeMediaEngine.
 // It uses the WebRtc VoiceEngine library for audio handling.
-class WebRtcVoiceEngine final : public VoiceEngineInterface {
+class WebRtcVoiceEngine : public VoiceEngineInterface {
   friend class WebRtcVoiceMediaChannel;
 
  public:
@@ -81,7 +81,7 @@ class WebRtcVoiceEngine final : public VoiceEngineInterface {
   // Stops AEC dump.
   void StopAecDump() override;
 
- private:
+ protected:
   // Every option that is "set" will be applied. Every option not "set" will be
   // ignored. This allows us to selectively turn on and off different options
   // easily at any time.
@@ -132,7 +132,7 @@ class WebRtcVoiceEngine final : public VoiceEngineInterface {
 
 // WebRtcVoiceMediaChannel is an implementation of VoiceMediaChannel that uses
 // WebRtc Voice Engine.
-class WebRtcVoiceMediaChannel final : public VoiceMediaChannel,
+class WebRtcVoiceMediaChannel : public VoiceMediaChannel,
                                       public webrtc::Transport {
  public:
   WebRtcVoiceMediaChannel(WebRtcVoiceEngine* engine,
@@ -235,7 +235,7 @@ class WebRtcVoiceMediaChannel final : public VoiceMediaChannel,
     return VoiceMediaChannel::SendRtcp(&packet, rtc_options);
   }
 
- private:
+ protected:
   bool SetOptions(const AudioOptions& options);
   bool SetRecvCodecs(const std::vector<AudioCodec>& codecs);
   bool SetSendCodecs(const std::vector<AudioCodec>& codecs);
diff --git a/third_party/webrtc/modules/rtp_rtcp/include/rtp_rtcp.h b/third_party/webrtc/modules/rtp_rtcp/include/rtp_rtcp.h
index b3cd8f64188..fd80d20590c 100644
--- a/third_party/webrtc/modules/rtp_rtcp/include/rtp_rtcp.h
+++ b/third_party/webrtc/modules/rtp_rtcp/include/rtp_rtcp.h
@@ -146,6 +146,8 @@ class RtpRtcp : public Module, public RtcpFeedbackSenderInterface {
   // Sender
   // **************************************************************************
 
+  virtual void SetAudioClockRate(int clock_rate_hz) = 0;
+
   // Sets the maximum size of an RTP packet, including RTP headers.
   virtual void SetMaxRtpPacketSize(size_t size) = 0;
 
diff --git a/third_party/webrtc/modules/rtp_rtcp/source/rtcp_sender.cc b/third_party/webrtc/modules/rtp_rtcp/source/rtcp_sender.cc
index 0f119ef235f..cb14654479a 100644
--- a/third_party/webrtc/modules/rtp_rtcp/source/rtcp_sender.cc
+++ b/third_party/webrtc/modules/rtp_rtcp/source/rtcp_sender.cc
@@ -184,7 +184,8 @@ RTCPSender::RTCPSender(const RtpRtcp::Configuration& config)
       xr_send_receiver_reference_time_enabled_(false),
       packet_type_counter_observer_(config.rtcp_packet_type_counter_observer),
       send_video_bitrate_allocation_(false),
-      last_payload_type_(-1) {
+      last_payload_type_(-1),
+      audio_clock_rate_(kBogusRtpRateForAudioRtcp) {
   RTC_DCHECK(transport_ != nullptr);
 
   builders_[kRtcpSr] = &RTCPSender::BuildSR;
@@ -204,6 +205,10 @@ RTCPSender::RTCPSender(const RtpRtcp::Configuration& config)
 
 RTCPSender::~RTCPSender() {}
 
+void RTCPSender::SetAudioClockRate(int rate) {
+  audio_clock_rate_ = rate;
+}
+
 RtcpMode RTCPSender::Status() const {
   rtc::CritScope lock(&critical_section_rtcp_sender_);
   return method_;
@@ -463,8 +468,7 @@ std::unique_ptr<rtcp::RtcpPacket> RTCPSender::BuildSR(const RtcpContext& ctx) {
   int rtp_rate = rtp_clock_rates_khz_[last_payload_type_];
   if (rtp_rate <= 0) {
     rtp_rate =
-        (audio_ ? kBogusRtpRateForAudioRtcp : kVideoPayloadTypeFrequency) /
-        1000;
+        (audio_ ? audio_clock_rate_ : kVideoPayloadTypeFrequency) / 1000;
   }
   // Round now_us_ to the closest millisecond, because Ntp time is rounded
   // when converted to milliseconds,
diff --git a/third_party/webrtc/modules/rtp_rtcp/source/rtcp_sender.h b/third_party/webrtc/modules/rtp_rtcp/source/rtcp_sender.h
index 32c1e1dbc10..42ba3dc9b96 100644
--- a/third_party/webrtc/modules/rtp_rtcp/source/rtcp_sender.h
+++ b/third_party/webrtc/modules/rtp_rtcp/source/rtcp_sender.h
@@ -66,6 +66,8 @@ class RTCPSender {
   explicit RTCPSender(const RtpRtcp::Configuration& config);
   virtual ~RTCPSender();
 
+  void SetAudioClockRate(int rate);
+
   RtcpMode Status() const;
   void SetRTCPStatus(RtcpMode method);
 
@@ -294,6 +296,8 @@ class RTCPSender {
   // Map from RTCPPacketType to builder.
   std::map<uint32_t, BuilderFunc> builders_;
 
+  int audio_clock_rate_;
+
   RTC_DISALLOW_IMPLICIT_CONSTRUCTORS(RTCPSender);
 };
 }  // namespace webrtc
diff --git a/third_party/webrtc/modules/rtp_rtcp/source/rtp_rtcp_impl.cc b/third_party/webrtc/modules/rtp_rtcp/source/rtp_rtcp_impl.cc
index 987ae0ec596..c8fcf325f52 100644
--- a/third_party/webrtc/modules/rtp_rtcp/source/rtp_rtcp_impl.cc
+++ b/third_party/webrtc/modules/rtp_rtcp/source/rtp_rtcp_impl.cc
@@ -701,6 +701,10 @@ void ModuleRtpRtcpImpl::SetRemoteSSRC(const uint32_t ssrc) {
   rtcp_receiver_.SetRemoteSSRC(ssrc);
 }
 
+void ModuleRtpRtcpImpl::SetAudioClockRate(int clock_rate_hz_) {
+  rtcp_sender_.SetAudioClockRate(clock_rate_hz_);
+}
+
 // TODO(nisse): Delete video_rate amd fec_rate arguments.
 void ModuleRtpRtcpImpl::BitrateSent(uint32_t* total_rate,
                                     uint32_t* video_rate,
diff --git a/third_party/webrtc/modules/rtp_rtcp/source/rtp_rtcp_impl.h b/third_party/webrtc/modules/rtp_rtcp/source/rtp_rtcp_impl.h
index 976653a4583..226f675b40d 100644
--- a/third_party/webrtc/modules/rtp_rtcp/source/rtp_rtcp_impl.h
+++ b/third_party/webrtc/modules/rtp_rtcp/source/rtp_rtcp_impl.h
@@ -63,6 +63,9 @@ class ModuleRtpRtcpImpl : public RtpRtcp, public RTCPReceiver::ModuleRtpRtcp {
   void SetRemoteSSRC(uint32_t ssrc) override;
 
   // Sender part.
+
+  void SetAudioClockRate(int clock_rate_hz_) override;
+
   void RegisterSendPayloadFrequency(int payload_type,
                                     int payload_frequency) override;
 
diff --git a/third_party/webrtc/pc/BUILD.gn b/third_party/webrtc/pc/BUILD.gn
index c971a375ed3..6480d627726 100644
--- a/third_party/webrtc/pc/BUILD.gn
+++ b/third_party/webrtc/pc/BUILD.gn
@@ -27,6 +27,7 @@ config("rtc_pc_config") {
 
 rtc_library("rtc_pc_base") {
   visibility = [ "*" ]
+  allow_poison = ["audio_codecs"]
   defines = []
   sources = [
     "channel.cc",
@@ -158,6 +159,7 @@ rtc_library("media_protocol_names") {
 
 rtc_library("peerconnection") {
   visibility = [ "*" ]
+  allow_poison = ["audio_codecs"]
   cflags = []
   sources = [
     "audio_rtp_receiver.cc",
@@ -273,6 +275,7 @@ rtc_library("peerconnection") {
     "../rtc_base/third_party/base64",
     "../rtc_base/third_party/sigslot",
     "../stats",
+    "../dvc:dvc_pc",
     "../system_wrappers",
     "../system_wrappers:field_trial",
     "../system_wrappers:metrics",
@@ -284,6 +287,7 @@ rtc_library("peerconnection") {
 
 rtc_source_set("libjingle_peerconnection") {
   visibility = [ "*" ]
+  allow_poison = ["audio_codecs"]
   deps = [
     ":peerconnection",
     "../api:libjingle_peerconnection_api",
diff --git a/third_party/webrtc/pc/channel.h b/third_party/webrtc/pc/channel.h
index 238a8e20fee..c76f80bdc87 100644
--- a/third_party/webrtc/pc/channel.h
+++ b/third_party/webrtc/pc/channel.h
@@ -364,6 +364,7 @@ class VoiceChannel : public BaseChannel {
                           webrtc::SdpType type,
                           std::string* error_desc) override;
 
+public:
   // Last AudioSendParameters sent down to the media_channel() via
   // SetSendParameters.
   AudioSendParameters last_send_params_;
diff --git a/third_party/webrtc/pc/peer_connection.h b/third_party/webrtc/pc/peer_connection.h
index 9065982f007..de08d2abc22 100644
--- a/third_party/webrtc/pc/peer_connection.h
+++ b/third_party/webrtc/pc/peer_connection.h
@@ -328,7 +328,6 @@ class PeerConnection : public PeerConnectionInternal,
  protected:
   ~PeerConnection() override;
 
- private:
   class ImplicitCreateSessionDescriptionObserver;
   friend class ImplicitCreateSessionDescriptionObserver;
   class SetRemoteDescriptionObserverAdapter;
@@ -969,7 +968,7 @@ class PeerConnection : public PeerConnectionInternal,
   // Updates the error state, signaling if necessary.
   void SetSessionError(SessionError error, const std::string& error_desc);
 
-  RTCError UpdateSessionState(SdpType type,
+  virtual RTCError UpdateSessionState(SdpType type,
                               cricket::ContentSource source,
                               const cricket::SessionDescription* description);
   // Push the media parts of the local or remote session description
@@ -1032,7 +1031,7 @@ class PeerConnection : public PeerConnectionInternal,
       RTC_RUN_ON(signaling_thread());
 
   // Helper methods to create media channels.
-  cricket::VoiceChannel* CreateVoiceChannel(const std::string& mid)
+  virtual cricket::VoiceChannel* CreateVoiceChannel(const std::string& mid)
       RTC_RUN_ON(signaling_thread());
   cricket::VideoChannel* CreateVideoChannel(const std::string& mid)
       RTC_RUN_ON(signaling_thread());
@@ -1140,7 +1139,7 @@ class PeerConnection : public PeerConnectionInternal,
 
   // Destroys the given ChannelInterface.
   // The channel cannot be accessed after this method is called.
-  void DestroyChannelInterface(cricket::ChannelInterface* channel);
+  virtual void DestroyChannelInterface(cricket::ChannelInterface* channel);
 
   // JsepTransportController::Observer override.
   //
diff --git a/third_party/webrtc/pc/peer_connection_factory.cc b/third_party/webrtc/pc/peer_connection_factory.cc
index 534c89274ec..b48dbf52797 100644
--- a/third_party/webrtc/pc/peer_connection_factory.cc
+++ b/third_party/webrtc/pc/peer_connection_factory.cc
@@ -44,6 +44,8 @@
 #include "rtc_base/numerics/safe_conversions.h"
 #include "rtc_base/system/file_wrapper.h"
 
+#include "dvc/pc/dvcpeerconnection.h"
+
 namespace webrtc {
 
 rtc::scoped_refptr<PeerConnectionFactoryInterface>
@@ -294,8 +296,9 @@ PeerConnectionFactory::CreatePeerConnection(
       rtc::Bind(&PeerConnectionFactory::CreateCall_w, this, event_log.get()));
 
   rtc::scoped_refptr<PeerConnection> pc(
-      new rtc::RefCountedObject<PeerConnection>(this, std::move(event_log),
-                                                std::move(call)));
+      new rtc::RefCountedObject<
+          dolby_voice_client::webrtc_integration::DvcPeerConnection>(
+          this, std::move(event_log), std::move(call)));
   ActionsBeforeInitializeForTesting(pc);
   if (!pc->Initialize(configuration, std::move(dependencies))) {
     return nullptr;
diff --git a/third_party/webrtc/pc/webrtc_session_description_factory.cc b/third_party/webrtc/pc/webrtc_session_description_factory.cc
index aaef7fdeb67..338cdb6cbea 100644
--- a/third_party/webrtc/pc/webrtc_session_description_factory.cc
+++ b/third_party/webrtc/pc/webrtc_session_description_factory.cc
@@ -292,6 +292,19 @@ cricket::SecurePolicy WebRtcSessionDescriptionFactory::SdesPolicy() const {
   return session_desc_factory_.secure();
 }
 
+void WebRtcSessionDescriptionFactory::set_audio_codecs(const cricket::AudioCodecs& send_codecs,
+                                                       const cricket::AudioCodecs& recv_codecs)
+{
+  session_desc_factory_.set_audio_codecs(send_codecs, recv_codecs);
+}
+
+void WebRtcSessionDescriptionFactory::get_audio_codecs(cricket::AudioCodecs& send_codecs,
+                                                       cricket::AudioCodecs& recv_codecs)
+{
+  send_codecs = session_desc_factory_.audio_send_codecs();
+  recv_codecs = session_desc_factory_.audio_recv_codecs();
+}
+
 void WebRtcSessionDescriptionFactory::OnMessage(rtc::Message* msg) {
   switch (msg->message_id) {
     case MSG_CREATE_SESSIONDESCRIPTION_SUCCESS: {
diff --git a/third_party/webrtc/pc/webrtc_session_description_factory.h b/third_party/webrtc/pc/webrtc_session_description_factory.h
index c707feba003..0a6734d15e4 100644
--- a/third_party/webrtc/pc/webrtc_session_description_factory.h
+++ b/third_party/webrtc/pc/webrtc_session_description_factory.h
@@ -114,6 +114,9 @@ class WebRtcSessionDescriptionFactory : public rtc::MessageHandler,
   sigslot::signal1<const rtc::scoped_refptr<rtc::RTCCertificate>&>
       SignalCertificateReady;
 
+  void set_audio_codecs(const cricket::AudioCodecs& send_codecs,
+                        const cricket::AudioCodecs& recv_codecs);
+  void get_audio_codecs(cricket::AudioCodecs& send_codecs, cricket::AudioCodecs& recv_codecs);
   // For testing.
   bool waiting_for_certificate_for_testing() const {
     return certificate_request_state_ == CERTIFICATE_WAITING;
diff --git a/third_party/webrtc/video/stream_synchronization.cc b/third_party/webrtc/video/stream_synchronization.cc
index 493ed33b1db..3816558fa8a 100644
--- a/third_party/webrtc/video/stream_synchronization.cc
+++ b/third_party/webrtc/video/stream_synchronization.cc
@@ -17,10 +17,17 @@
 
 #include "rtc_base/logging.h"
 
+#include "dvc/dvc_constants.h"
+
 namespace webrtc {
 
 static const int kMaxChangeMs = 80;
+
+static const int kMaxTotalAudioDelayMs =
+    dolby_voice_client::webrtc_integration::DVC_MAX_DELTA_DELAY_MS;
 static const int kMaxDeltaDelayMs = 10000;
+
+
 static const int kFilterLength = 4;
 // Minimum difference between audio and video to warrant a change.
 static const int kMinDeltaMs = 30;
@@ -157,8 +164,18 @@ bool StreamSynchronization::ComputeDelays(int relative_delay_ms,
       std::max(new_audio_delay_ms, channel_delay_.extra_audio_delay_ms);
 
   // Verify we don't go above the maximum allowed audio delay.
+  if (new_audio_delay_ms > kMaxTotalAudioDelayMs) {
+      if (new_video_delay_ms > 0) {
+        auto audio_needs = new_audio_delay_ms - kMaxTotalAudioDelayMs;
+        auto can_get = std::min(new_video_delay_ms, audio_needs);
+        // This is a hack, the values now can go below base target delay.
+        // It's better this way than to let audio and video desynchronize though.
+        new_audio_delay_ms -= can_get;
+        new_video_delay_ms -= can_get;
+      }
+  }
   new_audio_delay_ms =
-      std::min(new_audio_delay_ms, base_target_delay_ms_ + kMaxDeltaDelayMs);
+      std::min(new_audio_delay_ms, kMaxTotalAudioDelayMs);
 
   // Remember our last audio and video delays.
   channel_delay_.last_video_delay_ms = new_video_delay_ms;
